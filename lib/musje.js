(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory(require("Snap"), require("MIDI"));
	else if(typeof define === 'function' && define.amd)
		define(["Snap", "MIDI"], factory);
	else if(typeof exports === 'object')
		exports["musje"] = factory(require("Snap"), require("MIDI"));
	else
		root["musje"] = factory(root["Snap"], root["MIDI"]);
})(this, function(__WEBPACK_EXTERNAL_MODULE_23__, __WEBPACK_EXTERNAL_MODULE_46__) {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var parser = __webpack_require__(1);
	var Score = __webpack_require__(3);
	var Renderer = __webpack_require__(22);
	var util = __webpack_require__(2);
	var PlayerMixin = __webpack_require__(45);
	
	/**
	 * Render the score in jianpu (numbered musical notation).
	 * @member
	 * @function
	 * @param {string} svg
	 * @param {Object} lo - Layout options.
	 */
	Score.prototype.render = function (svg, lo) {
	  new Renderer(svg, lo).render(this);
	};
	
	util.defineProperties(Score.prototype, PlayerMixin);
	
	
	/** @module musje */
	module.exports = {
	
	  /**
	   * Parse source musje string to be a Score instance.
	   * @param {string} input - Input of the musje source code.
	   * @return {Score} - A `Score` instance.
	   */
	  parse: function (input) {
	    var plainScore = parser.parse(input);
	    return new Score(plainScore);
	  },
	
	  /**
	   * Score constructor.
	   * @see {@link Score}
	   */
	  Score: Score,
	
	  /**
	   * Utility functions.
	   * @see {@link util}
	   */
	  util: util
	};


/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	/* parser generated by jison 0.4.17 */
	/*
	  Returns a Parser object of the following structure:
	
	  Parser: {
	    yy: {}
	  }
	
	  Parser.prototype: {
	    yy: {},
	    trace: function(),
	    symbols_: {associative list: name ==> number},
	    terminals_: {associative list: number ==> name},
	    productions_: [...],
	    performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate, $$, _$),
	    table: [...],
	    defaultActions: {...},
	    parseError: function(str, hash),
	    parse: function(input),
	
	    lexer: {
	        EOF: 1,
	        parseError: function(str, hash),
	        setInput: function(input),
	        input: function(),
	        unput: function(str),
	        more: function(),
	        less: function(n),
	        pastInput: function(),
	        upcomingInput: function(),
	        showPosition: function(),
	        test_match: function(regex_match_array, rule_index),
	        next: function(),
	        lex: function(),
	        begin: function(condition),
	        popState: function(),
	        _currentRules: function(),
	        topState: function(),
	        pushState: function(condition),
	
	        options: {
	            ranges: boolean           (optional: true ==> token location info will include a .range[] member)
	            flex: boolean             (optional: true ==> flex-like lexing behaviour where the rules are tested exhaustively to find the longest match)
	            backtrack_lexer: boolean  (optional: true ==> lexer regexes are tested in order and for each matching regex the action code is invoked; the lexer terminates the scan when a token is returned by the action code)
	        },
	
	        performAction: function(yy, yy_, $avoiding_name_collisions, YY_START),
	        rules: [...],
	        conditions: {associative list: name ==> set},
	    }
	  }
	
	
	  token location info (@$, _$, etc.): {
	    first_line: n,
	    last_line: n,
	    first_column: n,
	    last_column: n,
	    range: [start_number, end_number]       (where the numbers are indexes into the input string, regular zero-based)
	  }
	
	
	  the parseError function receives a 'hash' object with these members for lexer and parser errors: {
	    text:        (matched text)
	    token:       (the produced terminal token, if any)
	    line:        (yylineno)
	  }
	  while parser (grammar) errors will also provide these members, i.e. parser errors deliver a superset of attributes: {
	    loc:         (yylloc)
	    expected:    (string describing the set of expected tokens)
	    recoverable: (boolean: TRUE when the parser has a error recovery rule available for this particular error)
	  }
	*/
	var parser = (function(){
	var o=function(k,v,o,l){for(o=o||{},l=k.length;l--;o[k[l]]=v);return o},$V0=[1,11],$V1=[1,15],$V2=[1,16],$V3=[1,17],$V4=[1,18],$V5=[1,19],$V6=[1,20],$V7=[1,23],$V8=[1,27],$V9=[1,34],$Va=[1,35],$Vb=[1,33],$Vc=[1,28],$Vd=[1,29],$Ve=[5,9,10,14,21,22,23,24,25,26,29,34,39,41,48,51,58],$Vf=[2,8],$Vg=[5,9,10,21,22,23,24,25,26,29,34,39,41,48,51,58],$Vh=[5,21,22,23,24,25,26],$Vi=[2,47],$Vj=[1,48],$Vk=[1,49],$Vl=[1,50],$Vm=[1,51],$Vn=[1,52],$Vo=[5,9,10,21,22,23,24,25,26,28,29,34,35,39,41,48,51,53,58],$Vp=[5,9,10,21,22,23,24,25,26,28,29,34,35,39,41,43,44,45,46,47,48,51,53,58],$Vq=[5,9,10,21,22,23,24,25,26,28,29,34,35,39,41,43,44,45,46,47,48,50,51,53,58],$Vr=[1,63],$Vs=[1,64],$Vt=[5,21,22,23,24,25,26,29,34,39,41,48,51,58],$Vu=[5,9,10,21,22,23,24,25,26,28,29,34,35,39,41,43,48,51,53,58],$Vv=[5,9,10,21,22,23,24,25,26,28,29,34,39,41,48,51,53,58],$Vw=[39,41,50];
	var parser = {trace: function trace() { },
	yy: {},
	symbols_: {"0":29,"error":2,"e":3,"maybe_musje":4,"EOF":5,"space":6,"maybe_space":7,"musje":8,"S":9,"NL":10,"score_head":11,"part_list":12,"title":13,"TITLE":14,"COMPOSER":15,"part":16,"measure_list":17,"bar":18,"measure":19,"music_data":20,"|":21,"||":22,"|]":23,"|:":24,":|":25,":|:":26,"slurable":27,"TIE":28,"maybe_duration":30,"voice":31,"time_signature":32,"pitchful":33,"(":34,")":35,"note":36,"chord":37,"pitch":38,"STEP":39,"OCTAVE":40,"ACCIDENTAL":41,"type_modifier":42,"DOT":43,"_":44,"=":45,"HALF":46,"WHOLE":47,"<":48,"pitch_list":49,">":50,"{":51,"voice_list":52,"}":53,"voice_data_list":54,":":55,"voice_data":56,"restslurable_list":57,"BEATS":58,"BEAT_TYPE":59,"$accept":0,"$end":1},
	terminals_: {2:"error",5:"EOF",9:"S",10:"NL",14:"TITLE",15:"COMPOSER",21:"|",22:"||",23:"|]",24:"|:",25:":|",26:":|:",28:"TIE",29:"0",34:"(",35:")",39:"STEP",40:"OCTAVE",41:"ACCIDENTAL",43:"DOT",44:"_",45:"=",46:"HALF",47:"WHOLE",48:"<",50:">",51:"{",53:"}",54:"voice_data_list",55:":",57:"restslurable_list",58:"BEATS",59:"BEAT_TYPE"},
	productions_: [0,[3,2],[4,0],[4,2],[4,3],[4,1],[6,1],[6,1],[7,0],[7,2],[7,2],[8,1],[8,1],[8,2],[11,2],[13,1],[13,2],[12,1],[16,1],[16,3],[17,1],[17,4],[17,3],[19,2],[19,3],[18,1],[18,1],[18,1],[18,1],[18,1],[18,1],[20,1],[20,2],[20,2],[20,1],[20,1],[27,2],[27,3],[27,3],[27,4],[33,1],[33,1],[36,1],[38,1],[38,2],[38,2],[38,3],[30,0],[30,1],[30,1],[30,2],[42,1],[42,1],[42,2],[42,2],[42,3],[42,3],[42,1],[42,1],[37,3],[49,1],[49,2],[31,3],[52,1],[52,3],[56,1],[56,2],[32,2]],
	performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate /* action[1] */, $$ /* vstack */, _$ /* lstack */) {
	/* this == yyval */
	
	var $0 = $$.length - 1;
	switch (yystate) {
	case 1:
	 return $$[$0-1]; 
	break;
	case 2: case 3:
	 this.$ = null; 
	break;
	case 4: case 5:
	 this.$ = $$[$0]; removeLastEmptyMeasure($$[$0]); 
	break;
	case 10:
	 this.$ = $$[$0-1] ? $$[$0-1] + 1 : 1; 
	break;
	case 11:
	this.$ = { head: $$[$0] };
	break;
	case 12:
	this.$ = { parts: $$[$0] };
	break;
	case 13:
	this.$ = { head: $$[$0-1], parts: $$[$0] };
	break;
	case 15:
	 this.$ = { title: $$[$0] }; 
	break;
	case 16:
	 this.$ =  { title: $$[$0-1], composer: $$[$0] }; 
	break;
	case 17: case 60: case 63:
	this.$ = [$$[$0]];
	break;
	case 18:
	this.$ = { measures: $$[$0] };
	break;
	case 19:
	 this.$ = { measures: $$[$0]}; $$[$0][0].data.unshift({ bar: $$[$0-2] }); 
	break;
	case 20:
	 this.$ = [$$[$0]]; 
	break;
	case 21:
	 this.$ = $$[$0-3]; lastItem($$[$0-3]).data.push({ bar: $$[$0-2] }); $$[$0-3].push($$[$0]); 
	break;
	case 22:
	 this.$ = $$[$0-2]; lastItem($$[$0-2]).data.push({ bar: $$[$0-1] }); $$[$0-2].push({ data: [] }); 
	break;
	case 23:
	this.$ = { data: [$$[$0-1]] };
	break;
	case 24:
	 this.$ = $$[$0-2]; $$[$0-2].data.push($$[$0-1]); 
	break;
	case 25:
	this.$ = 'single';
	break;
	case 26:
	this.$ = 'double';
	break;
	case 27:
	this.$ = 'end';
	break;
	case 28:
	this.$ = 'repeat-begin';
	break;
	case 29:
	this.$ = 'repeat-end';
	break;
	case 30:
	this.$ = 'repeat-both';
	break;
	case 32:
	 this.$ = $$[$0-1]; onlyProperty($$[$0-1]).tie = '~'; 
	break;
	case 33:
	this.$ = { rest: { duration: $$[$0] } };
	break;
	case 34:
	this.$ = { voice: $$[$0] };
	break;
	case 36:
	 this.$ = $$[$0-1]; onlyProperty($$[$0-1]).duration = $$[$0]; 
	break;
	case 37:
	
	      this.$ = $$[$0-1];
	      extend(onlyProperty($$[$0-1]), {
	        duration: $$[$0],
	        slur: { begin: 'solid' }
	      });
	    
	break;
	case 38:
	
	      this.$ = $$[$0-2];
	      extend(onlyProperty($$[$0-2]), {
	        duration: $$[$0-1],
	        slur: { end: 'solid' }
	      });
	    
	break;
	case 39:
	
	      this.$ = $$[$0-2];
	      extend(onlyProperty($$[$0-2]), {
	        duration: $$[$0-1],
	        slur: { begin: 'solid', end: 'solid' }
	      });
	    
	break;
	case 40:
	this.$ = { note: $$[$0] };
	break;
	case 41:
	this.$ = { chord: $$[$0] };
	break;
	case 42:
	this.$ = { pitch: $$[$0] };
	break;
	case 43:
	this.$ = { step: +$$[$0] };
	break;
	case 44:
	this.$ = { step: +$$[$0-1], octave: octave($$[$0]) };
	break;
	case 45:
	this.$ = { accidental: $$[$0-1], step: +$$[$0] };
	break;
	case 46:
	this.$ = { accidental: $$[$0-2], step: +$$[$0-1], octave: octave($$[$0]) };
	break;
	case 48:
	this.$ = { type: $$[$0] };
	break;
	case 49:
	this.$ = { type: 4, dot: $$[$0].length };
	break;
	case 50:
	this.$ = { type: $$[$0-1], dot: $$[$0].length };
	break;
	case 51:
	this.$ = 8;
	break;
	case 52:
	this.$ = 16;
	break;
	case 53:
	this.$ = 32;
	break;
	case 54:
	this.$ = 64;
	break;
	case 55:
	this.$ = 128;
	break;
	case 56:
	this.$ = 256;
	break;
	case 57:
	this.$ = 2;
	break;
	case 58:
	this.$ = 1;
	break;
	case 59:
	this.$ = { pitches: $$[$0-1] };
	break;
	case 61: case 66:
	 this.$ = $$[$0-1]; $$[$0-1].push($$[$0]); 
	break;
	case 62:
	this.$ = $$[$0-1];
	break;
	case 64:
	 this.$ = $$[$0-2]; $$[$0-2].push($$[$0-1]); 
	break;
	case 67:
	this.$ = { time: { beats: +$$[$0-1], beatType: +$$[$0] } };
	break;
	}
	},
	table: [{3:1,4:2,5:[2,2],6:3,8:4,9:[1,5],10:[1,6],11:7,12:8,13:9,14:$V0,16:10,17:12,18:13,19:14,20:21,21:$V1,22:$V2,23:$V3,24:$V4,25:$V5,26:$V6,27:22,29:$V7,31:24,32:25,33:26,34:$V8,36:30,37:31,38:32,39:$V9,41:$Va,48:$Vb,51:$Vc,58:$Vd},{1:[3]},{5:[1,36]},o($Ve,$Vf,{7:37}),{5:[2,5]},o($Ve,[2,6]),o($Ve,[2,7]),{5:[2,11],12:38,16:10,17:12,18:13,19:14,20:21,21:$V1,22:$V2,23:$V3,24:$V4,25:$V5,26:$V6,27:22,29:$V7,31:24,32:25,33:26,34:$V8,36:30,37:31,38:32,39:$V9,41:$Va,48:$Vb,51:$Vc,58:$Vd},{5:[2,12]},o($Vg,$Vf,{7:39}),{5:[2,17]},o($Vg,[2,15],{15:[1,40]}),{5:[2,18],18:41,21:$V1,22:$V2,23:$V3,24:$V4,25:$V5,26:$V6},o([9,10,29,34,39,41,48,51,58],$Vf,{7:42}),o($Vh,[2,20],{27:22,31:24,32:25,33:26,36:30,37:31,38:32,20:43,29:$V7,34:$V8,39:$V9,41:$Va,48:$Vb,51:$Vc,58:$Vd}),o($Vg,[2,25]),o($Vg,[2,26]),o($Vg,[2,27]),o($Vg,[2,28]),o($Vg,[2,29]),o($Vg,[2,30]),o($Vg,$Vf,{7:44}),o($Vg,[2,31],{28:[1,45]}),o($Vg,$Vi,{30:46,42:47,43:$Vj,44:$Vk,45:$Vl,46:$Vm,47:$Vn}),o($Vg,[2,34]),o($Vg,[2,35]),o($Vo,$Vi,{42:47,30:53,43:$Vj,44:$Vk,45:$Vl,46:$Vm,47:$Vn}),{33:54,36:30,37:31,38:32,39:$V9,41:$Va,48:$Vb},{52:55,54:[1,56]},{59:[1,57]},o($Vp,[2,40]),o($Vp,[2,41]),o($Vp,[2,42]),{38:59,39:$V9,41:$Va,49:58},o($Vq,[2,43],{40:[1,60]}),{39:[1,61]},{1:[2,1]},{5:[2,3],8:62,9:$Vr,10:$Vs,11:7,12:8,13:9,14:$V0,16:10,17:12,18:13,19:14,20:21,21:$V1,22:$V2,23:$V3,24:$V4,25:$V5,26:$V6,27:22,29:$V7,31:24,32:25,33:26,34:$V8,36:30,37:31,38:32,39:$V9,41:$Va,48:$Vb,51:$Vc,58:$Vd},{5:[2,13]},o($Vt,[2,14],{9:$Vr,10:$Vs}),o($Vg,[2,16]),o($Vg,$Vf,{7:65}),{9:$Vr,10:$Vs,17:66,19:14,20:21,27:22,29:$V7,31:24,32:25,33:26,34:$V8,36:30,37:31,38:32,39:$V9,41:$Va,48:$Vb,51:$Vc,58:$Vd},o($Vg,$Vf,{7:67}),o($Vt,[2,23],{9:$Vr,10:$Vs}),o($Vg,[2,32]),o($Vg,[2,33]),o($Vo,[2,48],{43:[1,68]}),o($Vo,[2,49]),o($Vu,[2,51]),o($Vu,[2,52],{44:[1,69],45:[1,70]}),o($Vu,[2,57]),o($Vu,[2,58]),o($Vv,[2,36],{35:[1,71]}),o($Vo,$Vi,{42:47,30:72,43:$Vj,44:$Vk,45:$Vl,46:$Vm,47:$Vn}),{53:[1,73]},{53:[2,63],55:[1,74]},o($Vg,[2,67]),{38:76,39:$V9,41:$Va,50:[1,75]},o($Vw,[2,60]),o($Vq,[2,44]),o($Vq,[2,45],{40:[1,77]}),{5:[2,4]},o($Ve,[2,9]),o($Ve,[2,10]),o($Vh,[2,22],{20:21,27:22,31:24,32:25,33:26,36:30,37:31,38:32,19:78,9:$Vr,10:$Vs,29:$V7,34:$V8,39:$V9,41:$Va,48:$Vb,51:$Vc,58:$Vd}),{5:[2,19],18:41,21:$V1,22:$V2,23:$V3,24:$V4,25:$V5,26:$V6},o($Vt,[2,24],{9:$Vr,10:$Vs}),o($Vo,[2,50]),o($Vu,[2,53]),o($Vu,[2,54],{44:[1,79],45:[1,80]}),o($Vv,[2,38]),o($Vv,[2,37],{35:[1,81]}),o($Vg,[2,62]),{27:83,33:26,34:$V8,36:30,37:31,38:32,39:$V9,41:$Va,48:$Vb,56:82,57:[1,84]},o($Vp,[2,59]),o($Vw,[2,61]),o($Vq,[2,46]),o($Vh,[2,21],{27:22,31:24,32:25,33:26,36:30,37:31,38:32,20:43,29:$V7,34:$V8,39:$V9,41:$Va,48:$Vb,51:$Vc,58:$Vd}),o($Vu,[2,55]),o($Vu,[2,56]),o($Vv,[2,39]),{53:[2,64]},{53:[2,65]},{27:85,33:26,34:$V8,36:30,37:31,38:32,39:$V9,41:$Va,48:$Vb},{53:[2,66]}],
	defaultActions: {4:[2,5],8:[2,12],10:[2,17],36:[2,1],38:[2,13],62:[2,4],82:[2,64],83:[2,65],85:[2,66]},
	parseError: function parseError(str, hash) {
	    if (hash.recoverable) {
	        this.trace(str);
	    } else {
	        function _parseError (msg, hash) {
	            this.message = msg;
	            this.hash = hash;
	        }
	        _parseError.prototype = Error;
	
	        throw new _parseError(str, hash);
	    }
	},
	parse: function parse(input) {
	    var self = this, stack = [0], tstack = [], vstack = [null], lstack = [], table = this.table, yytext = '', yylineno = 0, yyleng = 0, recovering = 0, TERROR = 2, EOF = 1;
	    var args = lstack.slice.call(arguments, 1);
	    var lexer = Object.create(this.lexer);
	    var sharedState = { yy: {} };
	    for (var k in this.yy) {
	        if (Object.prototype.hasOwnProperty.call(this.yy, k)) {
	            sharedState.yy[k] = this.yy[k];
	        }
	    }
	    lexer.setInput(input, sharedState.yy);
	    sharedState.yy.lexer = lexer;
	    sharedState.yy.parser = this;
	    if (typeof lexer.yylloc == 'undefined') {
	        lexer.yylloc = {};
	    }
	    var yyloc = lexer.yylloc;
	    lstack.push(yyloc);
	    var ranges = lexer.options && lexer.options.ranges;
	    if (typeof sharedState.yy.parseError === 'function') {
	        this.parseError = sharedState.yy.parseError;
	    } else {
	        this.parseError = Object.getPrototypeOf(this).parseError;
	    }
	    function popStack(n) {
	        stack.length = stack.length - 2 * n;
	        vstack.length = vstack.length - n;
	        lstack.length = lstack.length - n;
	    }
	    _token_stack:
	        var lex = function () {
	            var token;
	            token = lexer.lex() || EOF;
	            if (typeof token !== 'number') {
	                token = self.symbols_[token] || token;
	            }
	            return token;
	        };
	    var symbol, preErrorSymbol, state, action, a, r, yyval = {}, p, len, newState, expected;
	    while (true) {
	        state = stack[stack.length - 1];
	        if (this.defaultActions[state]) {
	            action = this.defaultActions[state];
	        } else {
	            if (symbol === null || typeof symbol == 'undefined') {
	                symbol = lex();
	            }
	            action = table[state] && table[state][symbol];
	        }
	                    if (typeof action === 'undefined' || !action.length || !action[0]) {
	                var errStr = '';
	                expected = [];
	                for (p in table[state]) {
	                    if (this.terminals_[p] && p > TERROR) {
	                        expected.push('\'' + this.terminals_[p] + '\'');
	                    }
	                }
	                if (lexer.showPosition) {
	                    errStr = 'Parse error on line ' + (yylineno + 1) + ':\n' + lexer.showPosition() + '\nExpecting ' + expected.join(', ') + ', got \'' + (this.terminals_[symbol] || symbol) + '\'';
	                } else {
	                    errStr = 'Parse error on line ' + (yylineno + 1) + ': Unexpected ' + (symbol == EOF ? 'end of input' : '\'' + (this.terminals_[symbol] || symbol) + '\'');
	                }
	                this.parseError(errStr, {
	                    text: lexer.match,
	                    token: this.terminals_[symbol] || symbol,
	                    line: lexer.yylineno,
	                    loc: yyloc,
	                    expected: expected
	                });
	            }
	        if (action[0] instanceof Array && action.length > 1) {
	            throw new Error('Parse Error: multiple actions possible at state: ' + state + ', token: ' + symbol);
	        }
	        switch (action[0]) {
	        case 1:
	            stack.push(symbol);
	            vstack.push(lexer.yytext);
	            lstack.push(lexer.yylloc);
	            stack.push(action[1]);
	            symbol = null;
	            if (!preErrorSymbol) {
	                yyleng = lexer.yyleng;
	                yytext = lexer.yytext;
	                yylineno = lexer.yylineno;
	                yyloc = lexer.yylloc;
	                if (recovering > 0) {
	                    recovering--;
	                }
	            } else {
	                symbol = preErrorSymbol;
	                preErrorSymbol = null;
	            }
	            break;
	        case 2:
	            len = this.productions_[action[1]][1];
	            yyval.$ = vstack[vstack.length - len];
	            yyval._$ = {
	                first_line: lstack[lstack.length - (len || 1)].first_line,
	                last_line: lstack[lstack.length - 1].last_line,
	                first_column: lstack[lstack.length - (len || 1)].first_column,
	                last_column: lstack[lstack.length - 1].last_column
	            };
	            if (ranges) {
	                yyval._$.range = [
	                    lstack[lstack.length - (len || 1)].range[0],
	                    lstack[lstack.length - 1].range[1]
	                ];
	            }
	            r = this.performAction.apply(yyval, [
	                yytext,
	                yyleng,
	                yylineno,
	                sharedState.yy,
	                action[1],
	                vstack,
	                lstack
	            ].concat(args));
	            if (typeof r !== 'undefined') {
	                return r;
	            }
	            if (len) {
	                stack = stack.slice(0, -1 * len * 2);
	                vstack = vstack.slice(0, -1 * len);
	                lstack = lstack.slice(0, -1 * len);
	            }
	            stack.push(this.productions_[action[1]][0]);
	            vstack.push(yyval.$);
	            lstack.push(yyval._$);
	            newState = table[stack[stack.length - 2]][stack[stack.length - 1]];
	            stack.push(newState);
	            break;
	        case 3:
	            return true;
	        }
	    }
	    return true;
	}};
	
	
	var extend = __webpack_require__(2).extend;
	
	function lastItem(arr) { return arr[arr.length - 1]; }
	
	function onlyProperty(obj) {
	  return obj[Object.keys(obj)[0]];
	}
	
	function octave(str) {
	  var len = str.length;
	  return str.charAt(0) === ',' ? -len : len;
	}
	
	function removeLastEmptyMeasure(score) {
	  var parts = score.parts;
	  if (!parts) { return; }
	
	  parts.forEach(function (part) {
	    var lastMeasure = lastItem(part.measures);
	    if (lastMeasure.data.length === 0) {
	      part.measures.pop();
	    }
	  });
	}
	
	/* generated by jison-lex 0.3.4 */
	var lexer = (function(){
	var lexer = ({
	
	EOF:1,
	
	parseError:function parseError(str, hash) {
	        if (this.yy.parser) {
	            this.yy.parser.parseError(str, hash);
	        } else {
	            throw new Error(str);
	        }
	    },
	
	// resets the lexer, sets new input
	setInput:function (input, yy) {
	        this.yy = yy || this.yy || {};
	        this._input = input;
	        this._more = this._backtrack = this.done = false;
	        this.yylineno = this.yyleng = 0;
	        this.yytext = this.matched = this.match = '';
	        this.conditionStack = ['INITIAL'];
	        this.yylloc = {
	            first_line: 1,
	            first_column: 0,
	            last_line: 1,
	            last_column: 0
	        };
	        if (this.options.ranges) {
	            this.yylloc.range = [0,0];
	        }
	        this.offset = 0;
	        return this;
	    },
	
	// consumes and returns one char from the input
	input:function () {
	        var ch = this._input[0];
	        this.yytext += ch;
	        this.yyleng++;
	        this.offset++;
	        this.match += ch;
	        this.matched += ch;
	        var lines = ch.match(/(?:\r\n?|\n).*/g);
	        if (lines) {
	            this.yylineno++;
	            this.yylloc.last_line++;
	        } else {
	            this.yylloc.last_column++;
	        }
	        if (this.options.ranges) {
	            this.yylloc.range[1]++;
	        }
	
	        this._input = this._input.slice(1);
	        return ch;
	    },
	
	// unshifts one char (or a string) into the input
	unput:function (ch) {
	        var len = ch.length;
	        var lines = ch.split(/(?:\r\n?|\n)/g);
	
	        this._input = ch + this._input;
	        this.yytext = this.yytext.substr(0, this.yytext.length - len);
	        //this.yyleng -= len;
	        this.offset -= len;
	        var oldLines = this.match.split(/(?:\r\n?|\n)/g);
	        this.match = this.match.substr(0, this.match.length - 1);
	        this.matched = this.matched.substr(0, this.matched.length - 1);
	
	        if (lines.length - 1) {
	            this.yylineno -= lines.length - 1;
	        }
	        var r = this.yylloc.range;
	
	        this.yylloc = {
	            first_line: this.yylloc.first_line,
	            last_line: this.yylineno + 1,
	            first_column: this.yylloc.first_column,
	            last_column: lines ?
	                (lines.length === oldLines.length ? this.yylloc.first_column : 0)
	                 + oldLines[oldLines.length - lines.length].length - lines[0].length :
	              this.yylloc.first_column - len
	        };
	
	        if (this.options.ranges) {
	            this.yylloc.range = [r[0], r[0] + this.yyleng - len];
	        }
	        this.yyleng = this.yytext.length;
	        return this;
	    },
	
	// When called from action, caches matched text and appends it on next action
	more:function () {
	        this._more = true;
	        return this;
	    },
	
	// When called from action, signals the lexer that this rule fails to match the input, so the next matching rule (regex) should be tested instead.
	reject:function () {
	        if (this.options.backtrack_lexer) {
	            this._backtrack = true;
	        } else {
	            return this.parseError('Lexical error on line ' + (this.yylineno + 1) + '. You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).\n' + this.showPosition(), {
	                text: "",
	                token: null,
	                line: this.yylineno
	            });
	
	        }
	        return this;
	    },
	
	// retain first n characters of the match
	less:function (n) {
	        this.unput(this.match.slice(n));
	    },
	
	// displays already matched input, i.e. for error messages
	pastInput:function () {
	        var past = this.matched.substr(0, this.matched.length - this.match.length);
	        return (past.length > 20 ? '...':'') + past.substr(-20).replace(/\n/g, "");
	    },
	
	// displays upcoming input, i.e. for error messages
	upcomingInput:function () {
	        var next = this.match;
	        if (next.length < 20) {
	            next += this._input.substr(0, 20-next.length);
	        }
	        return (next.substr(0,20) + (next.length > 20 ? '...' : '')).replace(/\n/g, "");
	    },
	
	// displays the character position where the lexing error occurred, i.e. for error messages
	showPosition:function () {
	        var pre = this.pastInput();
	        var c = new Array(pre.length + 1).join("-");
	        return pre + this.upcomingInput() + "\n" + c + "^";
	    },
	
	// test the lexed token: return FALSE when not a match, otherwise return token
	test_match:function (match, indexed_rule) {
	        var token,
	            lines,
	            backup;
	
	        if (this.options.backtrack_lexer) {
	            // save context
	            backup = {
	                yylineno: this.yylineno,
	                yylloc: {
	                    first_line: this.yylloc.first_line,
	                    last_line: this.last_line,
	                    first_column: this.yylloc.first_column,
	                    last_column: this.yylloc.last_column
	                },
	                yytext: this.yytext,
	                match: this.match,
	                matches: this.matches,
	                matched: this.matched,
	                yyleng: this.yyleng,
	                offset: this.offset,
	                _more: this._more,
	                _input: this._input,
	                yy: this.yy,
	                conditionStack: this.conditionStack.slice(0),
	                done: this.done
	            };
	            if (this.options.ranges) {
	                backup.yylloc.range = this.yylloc.range.slice(0);
	            }
	        }
	
	        lines = match[0].match(/(?:\r\n?|\n).*/g);
	        if (lines) {
	            this.yylineno += lines.length;
	        }
	        this.yylloc = {
	            first_line: this.yylloc.last_line,
	            last_line: this.yylineno + 1,
	            first_column: this.yylloc.last_column,
	            last_column: lines ?
	                         lines[lines.length - 1].length - lines[lines.length - 1].match(/\r?\n?/)[0].length :
	                         this.yylloc.last_column + match[0].length
	        };
	        this.yytext += match[0];
	        this.match += match[0];
	        this.matches = match;
	        this.yyleng = this.yytext.length;
	        if (this.options.ranges) {
	            this.yylloc.range = [this.offset, this.offset += this.yyleng];
	        }
	        this._more = false;
	        this._backtrack = false;
	        this._input = this._input.slice(match[0].length);
	        this.matched += match[0];
	        token = this.performAction.call(this, this.yy, this, indexed_rule, this.conditionStack[this.conditionStack.length - 1]);
	        if (this.done && this._input) {
	            this.done = false;
	        }
	        if (token) {
	            return token;
	        } else if (this._backtrack) {
	            // recover context
	            for (var k in backup) {
	                this[k] = backup[k];
	            }
	            return false; // rule action called reject() implying the next rule should be tested instead.
	        }
	        return false;
	    },
	
	// return next match in input
	next:function () {
	        if (this.done) {
	            return this.EOF;
	        }
	        if (!this._input) {
	            this.done = true;
	        }
	
	        var token,
	            match,
	            tempMatch,
	            index;
	        if (!this._more) {
	            this.yytext = '';
	            this.match = '';
	        }
	        var rules = this._currentRules();
	        for (var i = 0; i < rules.length; i++) {
	            tempMatch = this._input.match(this.rules[rules[i]]);
	            if (tempMatch && (!match || tempMatch[0].length > match[0].length)) {
	                match = tempMatch;
	                index = i;
	                if (this.options.backtrack_lexer) {
	                    token = this.test_match(tempMatch, rules[i]);
	                    if (token !== false) {
	                        return token;
	                    } else if (this._backtrack) {
	                        match = false;
	                        continue; // rule action called reject() implying a rule MISmatch.
	                    } else {
	                        // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)
	                        return false;
	                    }
	                } else if (!this.options.flex) {
	                    break;
	                }
	            }
	        }
	        if (match) {
	            token = this.test_match(match, rules[index]);
	            if (token !== false) {
	                return token;
	            }
	            // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)
	            return false;
	        }
	        if (this._input === "") {
	            return this.EOF;
	        } else {
	            return this.parseError('Lexical error on line ' + (this.yylineno + 1) + '. Unrecognized text.\n' + this.showPosition(), {
	                text: "",
	                token: null,
	                line: this.yylineno
	            });
	        }
	    },
	
	// return next match that has a token
	lex:function lex() {
	        var r = this.next();
	        if (r) {
	            return r;
	        } else {
	            return this.lex();
	        }
	    },
	
	// activates a new lexer condition state (pushes the new lexer condition state onto the condition stack)
	begin:function begin(condition) {
	        this.conditionStack.push(condition);
	    },
	
	// pop the previously active lexer condition state off the condition stack
	popState:function popState() {
	        var n = this.conditionStack.length - 1;
	        if (n > 0) {
	            return this.conditionStack.pop();
	        } else {
	            return this.conditionStack[0];
	        }
	    },
	
	// produce the lexer rule set which is active for the currently active lexer condition state
	_currentRules:function _currentRules() {
	        if (this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1]) {
	            return this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules;
	        } else {
	            return this.conditions["INITIAL"].rules;
	        }
	    },
	
	// return the currently active lexer condition state; when an index argument is provided it produces the N-th previous condition state, if available
	topState:function topState(n) {
	        n = this.conditionStack.length - 1 - Math.abs(n || 0);
	        if (n >= 0) {
	            return this.conditionStack[n];
	        } else {
	            return "INITIAL";
	        }
	    },
	
	// alias for begin(condition)
	pushState:function pushState(condition) {
	        this.begin(condition);
	    },
	
	// return the number of states currently on the stack
	stateStackSize:function stateStackSize() {
	        return this.conditionStack.length;
	    },
	options: {},
	performAction: function anonymous(yy,yy_,$avoiding_name_collisions,YY_START) {
	var YYSTATE=YY_START;
	switch($avoiding_name_collisions) {
	case 0:return 9
	break;
	case 1:return 9
	break;
	case 2:return 9
	break;
	case 3: this.begin('title'); 
	break;
	case 4: yy_.yytext = yy_.yytext.substr(0, yy_.yyleng - 2).trim();
	                          return 14; 
	break;
	case 5: this.begin('INITIAL'); 
	break;
	case 6: this.begin('INITIAL');
	                          yy_.yytext = yy_.yytext.trim();
	                          return 15; 
	break;
	case 7: this.begin('time');
	                          yy_.yytext = yy_.yytext.substr(0, yy_.yyleng - 1);
	                          return 58; 
	break;
	case 8: this.begin('INITIAL'); return 59; 
	break;
	case 9:return 41
	break;
	case 10:return 39
	break;
	case 11:return 40
	break;
	case 12:return 43
	break;
	case 13:return 47
	break;
	case 14:return 46
	break;
	case 15:return 28
	break;
	case 16:return 44
	break;
	case 17:return 45
	break;
	case 18:return '.'
	break;
	case 19:return 29
	break;
	case 20:return 48
	break;
	case 21:return 50
	break;
	case 22:return 34
	break;
	case 23:return 35
	break;
	case 24:return '/'
	break;
	case 25:return '\\'
	break;
	case 26:return 23
	break;
	case 27:return 22
	break;
	case 28:return '[|'
	break;
	case 29:return 24
	break;
	case 30:return 26
	break;
	case 31:return 25
	break;
	case 32:return 21
	break;
	case 33:return 51
	break;
	case 34:return 53
	break;
	case 35:return 55
	break;
	case 36:return 10
	break;
	case 37:return 9
	break;
	case 38:return 5
	break;
	case 39:return 'INVALID'
	break;
	}
	},
	rules: [/^(?:\/\/[^\n]*)/,/^(?:\/\*([\s\S]*?)\*\/)/,/^(?:\/\*[\s\S]*)/,/^(?:<<)/,/^(?:.*>>)/,/^(?:([ \t])*([\n\r]))/,/^(?:.*)/,/^(?:(([1-9]\d{0,2})\/))/,/^(?:([1-9]\d{0,2})[^\d])/,/^(?:(#{1,2}|n|b{1,2}))/,/^(?:[1-7])/,/^(?:,+|'+)/,/^(?:\.+)/,/^(?:( *- *){3})/,/^(?:( *- *))/,/^(?: *~)/,/^(?:[_])/,/^(?:=)/,/^(?:\.)/,/^(?:[0])/,/^(?:<)/,/^(?:>)/,/^(?:\()/,/^(?:\))/,/^(?:\/)/,/^(?:\\)/,/^(?:\|\])/,/^(?:\|\|)/,/^(?:\[\|)/,/^(?:\|:)/,/^(?::\|:)/,/^(?::\|)/,/^(?:\|)/,/^(?:\{)/,/^(?:\})/,/^(?::)/,/^(?:([\n\r]))/,/^(?:([ \t]))/,/^(?:$)/,/^(?:.)/],
	conditions: {"time":{"rules":[8],"inclusive":false},"title":{"rules":[4,5,6],"inclusive":false},"INITIAL":{"rules":[0,1,2,3,7,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39],"inclusive":true}}
	});
	return lexer;
	})();
	parser.lexer = lexer;
	function Parser () {
	  this.yy = {};
	}
	Parser.prototype = parser;parser.Parser = Parser;
	return new Parser;
	})();
	module.exports = parser;

/***/ },
/* 2 */
/***/ function(module, exports) {

	'use strict';
	
	/**
	 * Utility functions
	 * @namespace
	 */
	var util = {};
	
	var IS_OBJECT = { 'funtion': true, 'object': true };
	function isObject(obj) {
	  return IS_OBJECT[typeof obj] && !!obj;
	}
	
	/**
	 * For each object key and value.
	 * @function util.objEach
	 * @param {Object} obj - The object to be iterated.
	 * @param {util~objEachCallback} callback - The callback for each iteration.
	 */
	var objEach =
	util.objEach = function (obj, callback) {
	  if (isObject(obj)) {
	    Object.keys(obj).forEach(function (key) {
	      callback(obj[key], key);
	    });
	  }
	};
	
	/**
	 * Callback that will be called for each iteration in {@link util.objEach}.
	 * @callback util~objEachCallback
	 * @param {*} value - Value of the current property.
	 * @param {string} key - Key of the current property.
	 */
	
	/**
	 * Utility method, extend `obj` with `ext`.
	 * @function
	 * @param {Object} obj - target object to be extended.
	 * @param {Object} ext - the extension object.
	 * @return {Object} The target object.
	 */
	util.extend = function(obj, ext) {
	  objEach(ext, function (val, key) { obj[key] = val; });
	  return obj;
	};
	
	/**
	 * Utility method, checking if `a` and `b` is close *enongh*.
	 * Useful to simulate the floating number equality check.
	 * @function
	 * @param {number} a - a number.
	 * @param {number} b - another number.
	 * @return {boolean} Wether `a` and `b` is close.
	 */
	util.near = function (a, b) {
	  return Math.abs(a - b) < 0.00001;
	};
	
	
	function isAccessorProperty(value) {
	  return isObject(value) &&
	        (typeof value.get === 'function' || typeof value.set === 'function');
	}
	
	/**
	 * Define ES5 getter/setter properties
	 * @param {Object} obj - The object to be defined.
	 * @param {Object} props - ES5 getter/setter properties.
	 * For example:
	 * ```
	 * {
	 *   name: {
	 *     get: function () {...},
	 *     set: function () {...}
	 *   },
	 *   age: {
	 *      get:...
	 *   }
	 * }
	 * ```
	 */
	util.defineProperties = function (obj, props) {
	  objEach(props, function (value, prop) {
	    var descriptor;
	    if (isAccessorProperty(value)) {
	      descriptor = value;
	    } else if (typeof value === 'function') {
	      descriptor = { value: value };
	    } else if (isObject(value) && value.constant) {
	      descriptor = { value: value.constant };
	    } else {
	      descriptor = {
	        value: value,
	        writable: true,
	        enumerable: true
	      };
	    }
	    Object.defineProperty(obj, prop, descriptor);
	  });
	};
	
	util.toJSONWithDefault = true;
	
	util.makeToJSON = function (values, elName) {
	  return function () {
	    if (this.isEmpty) { return; }
	
	    var
	      that = this,
	      result = {};
	
	    objEach(values, function (defaultValue, prop) {
	      if (util.toJSONWithDefault || that[prop] !== defaultValue) {
	        result[prop] = that[prop];
	      }
	    });
	    if (!elName) { return result; }
	
	    var res = {};
	    res[elName] = result;
	    return res;
	  };
	};
	
	module.exports = util;


/***/ },
/* 3 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var util = __webpack_require__(2);
	var ScoreHead = __webpack_require__(4);
	var PartwiseParts = __webpack_require__(5);
	var TimewiseMeasures = __webpack_require__(20);
	
	/**
	 * @class
	 * @param {Object} score - plain score object.
	 * @mixes PlayerMixin
	 */
	function Score(score) {
	  util.extend(this, score);
	}
	
	util.defineProperties(Score.prototype,
	/** @lends Score# */
	{
	  /**
	   * Head of the score.
	   * @type {ScoreHead}
	   */
	  head: {
	    get: function () {
	      return this._head || (this._head = new ScoreHead());
	    },
	    set: function (head) {
	      this._head = new ScoreHead(head);
	    }
	  },
	
	  /**
	   * Partwise parts.
	   * - (Getter)
	   * - (Setter)
	   * @type {PartwiseParts}
	   */
	  parts: {
	    get: function () {
	      return this._parts ||
	            (this._parts = new PartwiseParts(this));
	    },
	    set: function (parts) {
	      this.parts.removeAll();
	      this.parts.addParts(parts);
	      this.measures.fromPartwise();
	    }
	  },
	
	  /**
	   * Timewise measures, generated by the initialize function.
	   * @type {TimewiseMeasures}
	   * @readonly
	   */
	  measures: {
	    get: function () {
	      return this._measures ||
	            (this._measures = new TimewiseMeasures(this));
	    }
	  },
	
	  /**
	   * A cell is identically a measure in a part or a part in a measure.
	   * @param {Function}
	   */
	  walkCells: function (callback) {
	    this.parts.forEach(function (part, p) {
	      part.measures.forEach(function (cell, m) {
	        callback(cell, m, p);
	      });
	    });
	  },
	
	  /**
	   * Walk each music data.
	   * @param {Function} callback
	   */
	  walkMusicData: function (callback) {
	    this.walkCells(function (cell, m, p) {
	      cell.data.forEach(function (data, d) {
	        callback(data, d, m, p);
	      });
	    });
	  },
	
	  /**
	   * Convert score to string.
	   * @return {string} Musje source code.
	   */
	  toString: function () {
	    return this.head + this.parts.map(function (part) {
	      return part.toString();
	    }).join('\n\n');
	  },
	
	  /**
	   * Custom toJSON method.
	   * @method
	   * @return {Object}
	   */
	  toJSON: util.makeToJSON({
	    head: undefined,
	    parts: undefined
	  })
	});
	
	module.exports = Score;


/***/ },
/* 4 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var util = __webpack_require__(2);
	
	/**
	 * Construct head of the score.
	 * @class
	 * @param {Object} head
	 */
	function ScoreHead(head) {
	  util.extend(this, head);
	}
	
	util.defineProperties(ScoreHead.prototype,
	/** @lends ScoreHead# */
	{
	  /**
	   * Title of the score.
	   * @type {string}
	   * @default ''
	   */
	  title: '',
	
	  /**
	   * Subtitle of the score.
	   * @type {string}
	   * @default ''
	   */
	  subtitle: '',
	
	  /**
	   * Subsubtitle of the score.
	   * @type {string}
	   * @default ''
	   */
	  subsubtitle: '',
	
	  /**
	   * Composer of the score.
	   * @type {string}
	   */
	  composer: undefined,
	
	  /**
	   * Arranger of the score.
	   * @type {string}
	   */
	  arranger: undefined,
	
	  /**
	   * Lyricist of the score.
	   * @type {string}
	   */
	  lyricist: undefined,
	
	  /**
	   * Check if the score head is empty.
	   * @type {boolean}
	   * @readonly
	   */
	  isEmpty: {
	    get: function () {
	      return !this.title && !this.subtitle && !this.subsubtitle &&
	             !this.composer && !this.arranger && !this.lyricist;
	    }
	  },
	
	  /**
	   * Convert score head to string.
	   * @return {string} The converted musje head source code.
	   */
	  toString: function () {
	    return '' + (this.title ? ('<<' + this.title + '>>') : '') +
	            (this.composer || '') +
	            '\n';
	  },
	
	  toJSON: util.makeToJSON({
	    title: undefined,
	    subtitle: undefined,
	    subsubtitle: undefined,
	    composer: undefined,
	    lyricist: undefined
	  })
	});
	
	module.exports = ScoreHead;


/***/ },
/* 5 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var util = __webpack_require__(2);
	var PartwisePart = __webpack_require__(6);
	
	/**
	 * Construct partwise score parts.
	 * @class
	 * @classdesc Partwise score parts.
	 * @param score {Score}
	 * @augments {Array}
	 */
	function PartwiseParts(score) {
	  var parts = [];
	  parts._score = score;
	  util.defineProperties(parts, properties);
	  return parts;
	}
	
	/** @lends PartwiseParts# */
	var properties = {
	
	  /**
	   * Reference to the parent score.
	   * @type {Score}
	   * @readonly
	   */
	  score: {
	    get: function () {
	      return this._score;
	    }
	  },
	
	  /**
	   * Add parts.
	   * @param {Object}
	   */
	  addParts: function (parts) {
	    var that = this;
	    parts.forEach(function (part) {
	      that.append(part);
	    });
	  },
	
	  /**
	   * Append a partwise part.
	   * @param {Object} part - Plain partwise part object.
	   * @override
	   */
	  append: function (part) {
	    var index = this.length;
	    var musjePart = new PartwisePart(index, this);
	    this.push(musjePart);
	    musjePart.measures = part.measures;
	  },
	
	  /**
	   * Remove all parts.
	   */
	  removeAll: function () {
	    this.length = 0;
	  }
	};
	
	module.exports = PartwiseParts;


/***/ },
/* 6 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var util = __webpack_require__(2);
	var Cell = __webpack_require__(7);
	
	/**
	 * @class
	 * @param part {Object}
	 * @param index {number} - Index of this part in the parts.
	 * @param parts {PartwiseParts}
	 */
	function PartwisePart(index, parts) {
	  this._index = index;
	  this._parts = parts;
	}
	
	util.defineProperties(PartwisePart.prototype,
	/** @lends PartwisePart# */
	{
	  // head: { $ref: '#/objects/PartHead' },
	
	  /**
	   * Reference to the parent parts instance.
	   * @type {PartwiseParts}
	   * @readonly
	   */
	  parts: {
	    get: function () {
	      return this._parts;
	    }
	  },
	
	  /**
	   * Measure in a partwise part is cells.
	   * @type {Array.<Cell>}
	   */
	  measures: {
	    get: function () {
	      return this._measures || (this._measures = []);
	    },
	    set: function (measures) {
	      var
	        p = this._index,
	        score = this.parts.score,
	        mea = this._measures = [];
	
	      measures.forEach(function (cell, m) {
	        mea.push(new Cell(cell, m, p, score));
	      });
	    }
	  },
	
	  /**
	   * Convert a partwise part to sting.
	   * @return {string} Musje partwise part source code.
	   */
	  toString: function () {
	    return this.measures.map(function (cell) {
	      return cell;
	    }).join(' ');
	  },
	
	  /**
	   * Custom toJSON method.
	   * @return {Object}
	   */
	  toJSON: util.makeToJSON({
	    measures: undefined
	  })
	});
	
	module.exports = PartwisePart;


/***/ },
/* 7 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var util = __webpack_require__(2);
	var near = util.near;
	var Beam = __webpack_require__(8);
	var Classes = {
	  time:  __webpack_require__(9),
	  bar:   __webpack_require__(11),
	  note:  __webpack_require__(12),
	  rest:  __webpack_require__(17),
	  chord: __webpack_require__(18),
	  voice: __webpack_require__(19)
	};
	
	/**
	 * Construct a cell.
	 * Cell is either a measure in a partwise part, or
	 * a part in a timewise measure.
	 * @class
	 * @param cell {Object}
	 * @param mIndex {number} - Measure index of this cell.
	 * @param pIndex {number} - Part index of this cell.
	 * @mixes CellLayout
	 */
	function Cell(cell, mIndex, pIndex, score) {
	  this._mIndex = mIndex;
	  this._pIndex = pIndex;
	  this._score = score;
	  util.extend(this, cell);
	  makeBeams(this, 1);
	}
	
	util.defineProperties(Cell.prototype,
	/** @lends musje.Cell# */
	{
	  /**
	   * Reference to the root score instance.
	   * @type {Score}
	   * @readonly
	   */
	  score: {
	    get: function () {
	      return this._score;
	    }
	  },
	
	  /**
	   * Music data
	   * @type {Array.<MusicDataMixin>}
	   */
	  data: {
	    get: function () {
	      return this._data || (this._data = []);
	    },
	    set: function (data) {
	      var that = this;
	      that.length = 0;
	      data.forEach(function (datum) {
	        that.append(datum);
	      });
	    }
	  },
	
	  /**
	   * Reference to the parent measures.
	   * @type {TimewiseMeasures}
	   * @readonly
	   */
	  measures: {
	    get: function () {
	      return this.score.measures;
	    }
	  },
	
	  /**
	   * Reference to the parent measure.
	   * @type {TimewiseMeasure}
	   * @readonly
	   */
	  measure: {
	    get: function () {
	      return this.measures[this._mIndex];
	    }
	  },
	
	  /**
	   * Reference to the parent parts.
	   * @type {PartwiseParts}
	   * @readonly
	   */
	  parts: {
	    get: function () {
	      return this.score.parts;
	    }
	  },
	
	  /**
	   * Reference to the parent part.
	   * @type {PartwisePart}
	   * @readonly
	   */
	  part: {
	    get: function () {
	      return this.parts[this._pIndex];
	    }
	  },
	
	  /**
	   * Previous cell in the part.
	   * @type {Cell|undefined}
	   * @readonly
	   */
	  prev: {
	    get: function () {
	      return this.part.measures[this._mIndex - 1];
	    }
	  },
	
	  /**
	   * Next cell in the part.
	   * @type {Cell|undefined}
	   * @readonly
	   */
	  next: {
	    get: function () {
	      return this.part.measures[this._mIndex + 1];
	    }
	  },
	
	  /**
	   * The first music data in the cell.
	   * @type {MusicDataMixin|undefined}
	   * @readonly
	   */
	  firstData: {
	    get: function () {
	      return this.data[0];
	    }
	  },
	
	  /**
	   * The last music data in the cell.
	   * @type {MusicDataMixin|undefined}
	   * @readonly
	   */
	  lastData: {
	    get: function () {
	      return this.data[this.data.length - 1];
	    }
	  },
	
	  /**
	   * The left bar of this cell.
	   * @type {Bar|undefined}
	   * @readonly
	   */
	  barLeft: {
	    get: function () {
	      var firstData = this.firstData;
	
	      if (firstData && firstData.$type === 'bar') {
	        return firstData;
	      }
	
	      // Take from the previous measure.
	      var prevCell = this.prev;
	      if (prevCell) {
	        return prevCell.barRight;
	      }
	    }
	  },
	
	  /**
	   * The right bar of this cell.
	   * @type {Bar|undefined}
	   * @readonly
	   */
	  barRight: {
	    get: function () {
	      var lastData = this.lastData;
	      if (lastData && lastData.$type === 'bar') {
	        return lastData;
	      }
	    }
	  },
	
	  /**
	   * Append a music data to the cell.
	   * @param  {Object} musicData - Music data
	   */
	  append: function (musicData) {
	    var type = Object.keys(musicData)[0]; // musicData has only one key
	    var instance = new Classes[type](musicData[type]);
	    instance._cell = this;
	    instance._index = this.data.length;
	    this.data.push(instance);
	  },
	
	  /**
	   * Convert cell to string.
	   * @return {string} Converted cell in musje source code.
	   */
	  toString: function () {
	    return this.data.map(function (musicData) {
	      return musicData.toString();
	    }).join(' ');
	  },
	
	  toJSON: util.makeToJSON({
	    data: undefined
	  })
	});
	
	
	/**
	 * Make beams automatically in group by the groupDur.
	 * @param {number} groupDur - Duration of a beam group in quarter.
	 */
	function makeBeams(that, groupDur) {
	
	  getBeamGroups(that, groupDur).forEach(function (group) {
	    var beamLevel = {};   // it starts from 0, while underbar starts from 1
	
	    function nextHasSameBeamlevel(index, level) {
	      var next = group[index + 1];
	      return next && next.duration.underbar > level;
	    }
	
	    group.forEach(function(data, i) {
	      var underbar = data.duration.underbar;
	      var level;
	
	      for (level = 0; level < underbar; level++) {
	        if (nextHasSameBeamlevel(i, level)) {
	
	          /**
	           * Beams of the note.
	           * - Produced by the {@link Cell#makeBeams} method.
	           * - The above method is call in {@link Score#prepareCells}.
	           * @memberof Note#
	           * @alias beams
	           * @type {Array.<Beam>}
	           */
	          data.beams = data.beams || [];
	
	          if (beamLevel[level]) {
	            data.beams[level] = new Beam('continue', level, data);
	          } else {
	            beamLevel[level] = true;
	            data.beams[level] = new Beam('begin', level, data);
	          }
	        } else {
	          if (beamLevel[level]) {
	            data.beams = data.beams || [];
	            data.beams[level] = new Beam('end', level, data);
	            delete beamLevel[level];
	          }
	        }
	      }
	    });
	  });
	}
	
	function getBeamGroups(that, groupDur) {
	  var counter = 0, group = [], groups = [];
	
	  function inGroup() {
	    return counter < groupDur && !near(counter, groupDur);
	  }
	  function putGroup() {
	    if (group.length > 1) { groups.push(group); }
	    group = [];
	  }
	
	  that.data.forEach(function (musicData) {
	    if (musicData.$type !== 'note' && musicData.$type !== 'rest') {
	      return;
	    }
	    var duration = musicData.duration;
	    var dur = duration.quarter;
	
	    counter += dur;
	
	    if (inGroup()) {
	      if (duration.underbar) { group.push(musicData); }
	    } else if (near(counter, groupDur)) {
	      group.push(musicData);
	      putGroup();
	      counter = 0;
	    } else {
	      putGroup();
	      counter %= groupDur;
	    }
	  });
	
	  putGroup();
	
	  return groups;
	}
	
	module.exports = Cell;


/***/ },
/* 8 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var util = __webpack_require__(2);
	
	/**
	 * A [beam][wiki] is a horizontal or diagonal line used to connect multiple consecutive notes (and occasionally rests) in order to indicate rhythmic grouping. Only eighth notes (quavers) or shorter can be beamed.
	 *
	 * [wiki]: https://en.wikipedia.org/wiki/Beam_(music)
	 *
	 * Beam is created by {@link Cell#makeBeams} and
	 * attached to {@link Durable} in {@link Durable#beams}[level]
	 * @class
	 * @param {string} value - Beam value: `'begin'`, `'continue'` or `'end'`.
	 * @param {number} level - Beam level starting from 0 to up.
	 * @param {Durable} parent - The parent durable music data.
	 */
	function Beam(value, level, parent) {
	  this._value = value;
	  this._level = level;
	  this._parent = parent;
	}
	
	util.defineProperties(Beam.prototype,
	/** @lends Beam# */
	{
	  /**
	   * Parent
	   * @type {Note|Rest|Chord}
	   * @readonly
	   */
	  parent: {
	    get: function () {
	      return this._parent;
	    }
	  },
	
	  /**
	   * Beam value: `'begin'`, `'continue'` or `'end'`.
	   * @type {string}
	   * @readonly
	   */
	  value: {
	    get: function () {
	      return this._value;
	    }
	  },
	
	  /**
	   * Beam level starting from 0 to up.
	   * @type {number}
	   * @readonly
	   */
	  level: {
	    get: function () {
	      return this._level;
	    }
	  },
	
	  /**
	   * The end parent music data of the beam group.
	   * @type {MusicDataMixin}
	   */
	  endDurable: {
	    get: function () {
	      var nextData = this.parent.next;
	      while (nextData && nextData.beams[this.level].value !== 'end') {
	        nextData = nextData.next;
	      }
	      return nextData;
	    }
	  }
	});
	
	module.exports = Beam;


/***/ },
/* 9 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var util = __webpack_require__(2);
	var MusicDataMixin = __webpack_require__(10);
	
	/**
	 * Time signature.
	 * @class
	 * @param time {Object}
	 * @mixes MusicDataMixin
	 * @mixes MusicDataLayoutMixin
	 */
	function Time(time) {
	  util.extend(this, time);
	}
	
	util.defineProperties(Time.prototype,
	/** @lends Time# */
	{
	  /**
	   * Type of time.
	   * @constant
	   * @default time
	   */
	  $type: { constant: 'time' },
	
	  /**
	   * How many beats per measure.
	   * @type {number}
	   * @default
	   */
	  beats: 4,
	
	  /**
	   * Beat type
	   * @type {number}
	   * @default
	   */
	  beatType: 4,
	
	  /**
	   * Convert to musje source code.
	   * @return {string} Musje source code.
	   */
	  toString: function () {
	    return this.beats + '/' + this.beatType;
	  },
	
	  toJSON: util.makeToJSON({
	    beats: 4,
	    beatType: 4
	  }, 'time')
	});
	
	util.defineProperties(Time.prototype, MusicDataMixin);
	
	module.exports = Time;


/***/ },
/* 10 */
/***/ function(module, exports) {

	'use strict';
	
	/**
	 * Music data mixin
	 * @mixin
	 */
	var MusicDataMixin = {
	
	  /**
	   * Reference to the parent cell.
	   * @type {Cell}
	   */
	  cell: {
	    get: function () {
	      return this._cell;
	    }
	  },
	
	  /**
	   * The ascendant system of the music data.
	   * @type {SystemLayout}
	   * @readonly
	   */
	  system: {
	    get: function () {
	      return this.cell.measure.system;
	    }
	  },
	
	  /**
	   * Previous music data.
	   * @type {MusicDataMixin|undefined}
	   * @readonly
	   */
	  prev: {
	    get: function () {
	      return this.cell.data[this._index - 1];
	    }
	  },
	
	  /**
	   * Next music data.
	   * @type {MusicDataMixin|undefined}
	   * @readonly
	   */
	  next: {
	    get: function () {
	      return this.cell.data[this._index + 1];
	    }
	  },
	
	  /**
	   * Previous music data in part, across measure.
	   * @type {MusicDataMixin|undefined}
	   * @readonly
	   */
	  prevInPart: {
	    get: function () {
	      var prev = this.prev, cell = this.cell;
	      while (!prev && cell.prev) {
	        if (!prev) {
	          cell = cell.prev;
	          prev = cell.lastData;
	        }
	      }
	      return prev;
	    }
	  },
	
	  /**
	   * Next music data in part, across measure.
	   * @type {MusicDataMixin|undefined}
	   * @readonly
	   */
	  nextInPart: {
	    get: function () {
	      var next = this.next, cell = this.cell;
	      while (!next && cell.next) {
	        if (!next) {
	          cell = cell.next;
	          next = cell.firstData;
	        }
	      }
	      return next;
	    }
	  },
	
	  /**
	   * Previous music data which has a duration.
	   * @type {MusicDataMixin|undefined}
	   * @readonly
	   */
	  prevDurable: {
	    get: function () {
	      var prev = this.prev;
	      while (prev && !prev.duration) {
	        prev = prev.prev;
	      }
	      return prev;
	    }
	  },
	
	  /**
	   * Next music data which has a duration.
	   * @type {MusicDataMixin|undefined}
	   * @readonly
	   */
	  nextDurable: {
	    get: function () {
	      var next = this.next;
	      while (next && !next.duration) {
	        next = next.next;
	      }
	      return next;
	    }
	  },
	
	  /**
	   * Previous music data which has a duration in part, across measure.
	   * @type {MusicDataMixin|undefined}
	   * @readonly
	   */
	  prevDurableInPart: {
	    get: function () {
	      var prev = this.prevInPart;
	      while (prev && !prev.duration) {
	        prev = prev.prevInPart;
	      }
	      return prev;
	    }
	  },
	
	  /**
	   * Next music data which has a duration in part, across measure.
	   * @type {MusicDataMixin|undefined}
	   * @readonly
	   */
	  nextDurableInPart: {
	    get: function () {
	      var next = this.nextInPart;
	      while (next && !next.duration) {
	        next = next.nextInPart;
	      }
	      return next;
	    }
	  }
	};
	
	module.exports = MusicDataMixin;


/***/ },
/* 11 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var util = __webpack_require__(2);
	var MusicDataMixin = __webpack_require__(10);
	
	var BAR_TO_STRING = {
	  single: '|', double: '||', end: '|]',
	  'repeat-begin': '|:', 'repeat-end': ':|', 'repeat-both': ':|:'
	};
	
	/**
	 * @class
	 * @param {string} bar - The bar value, which can be either of
	 * - 'single' - `|`
	 * - 'double' - `||`
	 * - 'end' - `|]`
	 * - 'repeat-begin' - `|:`
	 * - 'repeat-end' - `:|`
	 * - 'repeat-both' - `:|:`
	 * @mixes MusicDataMixin
	 * @mixes MusicDataLayoutMixin
	 */
	function Bar(bar) {
	  this._value = bar;
	}
	
	util.defineProperties(Bar.prototype,
	/** @lends Bar# */
	{
	  /**
	   * Type of bar.
	   * @constant
	   * @readonly
	   * @default bar
	   */
	  $type: { constant: 'bar' },
	
	  /**
	   * Value of the bar, which is the same as the bar parameter in the constructor.
	   * @type {string}
	   * @default single
	   * @readonly
	   */
	  value: {
	    get: function () {
	      return this._value || (this._value = 'single');
	    }
	  },
	
	  /**
	   * Convert bar to string.
	   * @return {string} Converted string of the barline in musje source code.
	   */
	  toString: function () {
	    return BAR_TO_STRING[this.value];
	  },
	
	  /**
	   * [toJSON description]
	   * @return {Object} { bar: value }
	   */
	  toJSON: function () {
	    return { bar: this.value };
	  }
	});
	
	util.defineProperties(Bar.prototype, MusicDataMixin);
	
	module.exports = Bar;


/***/ },
/* 12 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var util = __webpack_require__(2);
	var MusicDataMixin = __webpack_require__(10);
	var Pitch = __webpack_require__(13);
	var Duration = __webpack_require__(14);
	var Tie = __webpack_require__(15);
	var Slur = __webpack_require__(16);
	
	/**
	 * @class
	 * @param {Object} note
	 * @mixes MusicDataMixin
	 * @mixes MusicDataLayoutMixin
	 */
	function Note(note) {
	  util.extend(this, note);
	}
	
	util.defineProperties(Note.prototype,
	/** @lends Note# */
	{
	  /**
	   * Type of note.
	   * @constant
	   * @default note
	   */
	  $type: { constant: 'note' },
	
	  /**
	   * Pitch of the note.
	   * @type {musje.Pitch}
	   */
	  pitch: {
	    get: function () {
	      return this._pitch || (this._pitch = new Pitch(this));
	    },
	    set: function (pitch) {
	      this._pitch = new Pitch(this, pitch);
	    }
	  },
	
	  /**
	   * Duration of the note.
	   * @type {musje.Duration}
	   */
	  duration: {
	    get: function () {
	      return this._duration || (this._duration = new Duration());
	    },
	    set: function (duration) {
	      this._duration = new Duration(duration);
	    }
	  },
	
	  beams: {
	    get: function () {
	      return this._beams || (this._beams = []);
	    },
	    set: function (beams) {
	      this._beams = beams;
	    }
	  },
	
	  /**
	   * Tie
	   * @type {musje.Tie}
	   */
	  tie: {
	    get: function () {
	      return this._tie || (this._tie = new Tie(this));
	    },
	    set: function (tie) {
	
	      /**
	       * Value of the tie.
	       * @memberof Tie#
	       * @alias value
	       * @type {boolean}
	       */
	      this.tie.value = tie;
	    }
	  },
	
	  /**
	   * Slur
	   * @type {Slur}
	   */
	  slur: {
	    get: function () {
	      return this._slur || (this._slur = new Slur(this));
	    },
	    set: function (slur) {
	      util.extend(this.slur, slur);
	    }
	  },
	
	  /** @method */
	  toString: function () {
	    return this.slur.begin + this.pitch + this.duration +
	           this.slur.end + this.tie.value;
	  },
	
	  toJSON: util.makeToJSON({
	    pitch: undefined,
	    duration: undefined,
	    tie: undefined,
	    slur: undefined
	  }, 'note')
	});
	
	util.defineProperties(Note.prototype, MusicDataMixin);
	
	module.exports = Note;


/***/ },
/* 13 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var util = __webpack_require__(2);
	
	// Constants and helpers
	// =================================================================
	
	var A4_FREQUENCY = 440;
	var A4_MIDI_NUMBER = 69;
	var STEP_TO_MIDI_NUMBER = [undefined, 0, 2, 4, 5, 7, 9, 11];
	var ACCIDENTAL_TO_ALTER = { '#' : 1, '##': 2, n: 0, b : -1, bb: -2 };
	
	function chars(ch, num) {
	  return new Array(num + 1).join(ch);
	}
	
	function octaveString(octave) {
	  return octave > 0 ? chars('\'', octave) :
	         octave < 0 ? chars(',', -octave) : '';
	}
	
	/**
	 * @class
	 * @param parent {Note|Chord}
	 * @param pitch {Object}
	 */
	function Pitch(parent, pitch) {
	  this._parent = parent;
	  util.extend(this, pitch);
	}
	
	util.defineProperties(Pitch.prototype,
	/** @lends Pitch# */
	{
	  /**
	   * Reference to the parent parent.
	   * @type {Note|Chord}
	   * @readonly
	   */
	  parent: {
	    get: function () {
	      return this._parent;
	    }
	  },
	
	  /**
	   * Step is a value of `1`, `2`, `3`, `4`, `5`, `6`, or `7`.
	   * @type {number}
	   * @default
	   */
	  step: 1,
	
	  /**
	   * Octave is an integer value from `-5` to `5` inclusive.
	   * @type {number}
	   * @default
	   */
	  octave: 0,
	
	  /**
	   * Accidental is either of
	   * - `'#'` - sharp
	   * - `'##'` - double sharp
	   * - `'b'` - flat
	   * - `'bb'` - double flat
	   * - `'n'` - natural
	   * - `''` - (none)
	   * @type {string}
	   */
	  accidental: '',
	
	  /**
	   * Alter (from -2 to 2 inclusive).
	   *
	   * If no accidental in this pitch, it might be affected by a previous note in the same cell (the same part and the same measure).
	   * @type {number}
	   * @readonly
	   */
	  alter: {
	    get: function () {
	      if (this.accidental) {
	        return ACCIDENTAL_TO_ALTER[this.accidental];
	      }
	      var al = this.alterLink;
	      return al ? al.alter : 0;
	    }
	  },
	
	  /**
	   * Pitch linked that will affect the alter in this pitch.
	   * @type {Pitch|undefined}
	   * @readonly
	   */
	  alterLink: {
	    get: function () {
	      var prevData = this.parent.prev;
	
	      while(prevData) {
	        if (prevData.$type === 'note' &&
	            prevData.pitch.step === this.step && prevData.pitch.accidental) {
	          return prevData.pitch;
	        }
	        prevData = prevData.prev;
	      }
	    }
	  },
	
	  /**
	   * The MIDI note number of the pitch
	   * @type {number}
	   */
	  midiNumber: {
	    get: function () {
	      return (this.octave + 5) * 12 +
	        STEP_TO_MIDI_NUMBER[this.step] + this.alter;
	    }
	  },
	
	  /**
	   * Frequency of the pitch
	   * @type {number}
	   * @readonly
	   */
	  frequency: {
	    get: function () {
	      return A4_FREQUENCY * Math.pow(2, (this.midiNumber - A4_MIDI_NUMBER) / 12);
	    }
	  },
	
	  /**
	   * Convert to musje source code string.
	   * @return {string} Converted musje source code string.
	   */
	  toString: function () {
	    return this.accidental + this.step + octaveString(this.octave);
	  },
	
	  toJSON: util.makeToJSON({
	    step: 1,
	    octave: 0,
	    accidental: ''
	  })
	});
	
	module.exports = Pitch;


/***/ },
/* 14 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var util = __webpack_require__(2);
	var TYPE_TO_STRING = {
	  1: ' - - - ', 2: ' - ', 4: '', 8: '_', 16: '=', 32: '=_',
	  64: '==', 128: '==_', 256: '===', 512: '===_', 1024: '===='
	};
	var TYPE_TO_UNDERBAR = {
	   1: 0,   2: 0,   4: 0,   8: 1,   16: 2, 32: 3,
	  64: 4, 128: 5, 256: 6, 512: 7, 1024: 8
	};
	var DOT_TO_STRING = ['', '.', '..'];
	
	/**
	 * @class
	 * @param duration {Object}
	 */
	function Duration(duration) {
	  util.extend(this, duration);
	}
	
	util.defineProperties(Duration.prototype,
	/** @lends Duration# */
	{
	  /**
	   * Type of duration.
	   * @constant
	   * @default duration
	   */
	  $type: { constant: 'duration' },
	
	  /**
	   * Beat type
	   * @type {number}
	   * @default
	   */
	  type: 4,
	
	  /**
	   * Dot with value of 0, 1, or 2.
	   * @type {number}
	   * @default
	   */
	  dot: 0,
	
	  /**
	   * `(Getter)` Duration measured in quarter note.
	   * @type {number}
	   */
	  quarter: {
	    get: function () {
	      var d = 4 / this.type;
	      return this.dot === 0 ? d :
	             this.dot === 1 ? d * 1.5 : d * 1.75;
	    }
	  },
	
	  /**
	   * `(Getter)` Duration in second
	   * Affected by the tempo.
	   * @type {number}
	   * @readonly
	   */
	  second: {
	    get: function () {
	      return this.quarter * 60 / 80; // / TEMPO;
	    }
	  },
	
	  /**
	   * `(Getter)` Number of underbars in the beam.
	   * @type {number}
	   * @readonly
	   */
	  underbar: {
	    get: function () {
	      return TYPE_TO_UNDERBAR[this.type] || 0;
	    }
	  },
	
	  /**
	   * @return {string}
	   */
	  toString: function () {
	    return TYPE_TO_STRING[this.type] + DOT_TO_STRING[this.dot];
	  },
	
	  /**
	   * [toJSON description]
	   * @return {Object}
	   */
	  toJSON: util.makeToJSON({
	    type: 4,
	    dot: 0
	  })
	});
	
	module.exports = Duration;


/***/ },
/* 15 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var util = __webpack_require__(2);
	
	/**
	 * Tie of the note.
	 * @class
	 * @param parent {Note|Chord}
	 */
	function Tie(parent) {
	  this._parent = parent;
	}
	
	util.defineProperties(Tie.prototype,
	/** @lends musje.Tie# */
	{
	  /**
	   * Parent note or chord.
	   * @type {Note|Chord}
	   * @readonly
	   */
	  parent: {
	    get: function () {
	      return this._parent;
	    }
	  },
	
	  value: '',
	
	  /**
	   * @readonly
	   */
	  begin: {
	    get: function () {
	      return this.value;
	    }
	  },
	
	  /**
	   * @readonly
	   */
	  end: {
	    get: function () {
	      return this.prevParent;
	    }
	  },
	
	  /**
	   * The previous durable music data in part, if it is a tie begin.
	   * @type {Durable|undefined}
	   * @readonly
	   */
	  prevParent: {
	    get: function () {
	      var prev = this.parent.prevDurableInPart;
	      return prev && prev.tie && prev.tie.value && prev;
	    }
	  },
	
	  /**
	   * The next durable music data in part.
	   * @type {Durable|undefined}
	   * @readonly
	   */
	  nextParent: {
	    get: function () {
	      return this.value && this.parent.nextDurableInPart;
	    }
	  },
	
	  /**
	   * If previous durable music data in part has error.
	   * @type {boolean}
	   * @readonly
	   */
	  prevHasError: {
	    get: function () {
	      var prev = this.prevParent;
	      if (!prev || !prev.pitch) { return true; }
	      return prev.pitch && prev.pitch.midiNumber !== this.parent.pitch.midiNumber;
	    }
	  },
	
	  /**
	   * If next durable music data in part has error.
	   * @type {boolean}
	   * @readonly
	   */
	  nextHasError: {
	    get: function () {
	      var next = this.nextParent;
	      if (!next || !next.pitch) { return true; }
	      return next.pitch.midiNumber !== this.parent.pitch.midiNumber;
	    }
	  },
	
	  toJSON: function () {
	    return this.value;
	  }
	});
	
	module.exports = Tie;


/***/ },
/* 16 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var util = __webpack_require__(2);
	
	/**
	 * Slur
	 * @class
	 * @param parent {Note|Chord}
	 */
	function Slur(parent) {
	  this._parent = parent;
	}
	
	util.defineProperties(Slur.prototype,
	/** @lends Slur# */
	{
	  /**
	   * Parent music data.
	   * @type {Note|Chord}
	   * @readonly
	   */
	  parent: {
	    get: function () {
	      return this._parent;
	    }
	  },
	
	  begin: '',
	
	  end: '',
	
	  /**
	   * Previous slurred parent.
	   * @type {Note|Chord}
	   * @readonly
	   */
	  prevParent: {
	    get: function () {
	      if (!this.end) { return; }
	
	      var prev = this.parent.prevInPart;
	      while(prev) {
	        if (prev.slur && !prev.slur.isEmpty) {
	          return prev;
	        }
	        prev = prev.prevInPart;
	      }
	    }
	  },
	
	  /**
	   * Next Slurred parent.
	   * @type {Note|Chord}
	   * @readonly
	   */
	  nextParent: {
	    get: function () {
	      if (!this.begin) { return; }
	
	      var next = this.parent.nextInPart;
	      while(next) {
	        if (next.slur && !next.slur.isEmpty) {
	          return next;
	        }
	        next = next.nextInPart;
	      }
	    }
	  },
	
	  /**
	   * @todo Nested tie in slur.
	   * @type {boolean}
	   * @readonly
	   */
	  prevCrossTie: {
	    get: function () {
	
	    }
	  },
	
	  /**
	   * @todo Nested tie in slur.
	   * @type {boolean}
	   * @readonly
	   */
	  nextCrossTie: {
	    get: function () {
	
	    }
	  },
	
	  /**
	   * If the previous slur has error.
	   * @type {boolean}
	   * @readonly
	   */
	  prevHasError: {
	    get: function () {
	      var prev = this.prevParent;
	      return !prev || !prev.slur.begin;
	    }
	  },
	
	  /**
	   * If the next slur has error.
	   * @type {boolean}
	   * @readonly
	   */
	  nextHasError: {
	    get: function () {
	      var next = this.nextParent;
	      return !next || !next.slur.end;
	    }
	  },
	
	  /**
	   * If the slur is empty.
	   * @type {boolean}
	   * @readonly
	   */
	  isEmpty: {
	    get: function () {
	      return !(this.begin || this.end);
	    }
	  },
	
	  /**
	   * Convert the slur to JSON object.
	   * @method
	   * @return {Object} JSON object.
	   */
	  toJSON: util.makeToJSON({
	    begin: undefined,
	    end: undefined
	  })
	});
	
	module.exports = Slur;


/***/ },
/* 17 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var util = __webpack_require__(2);
	var MusicDataMixin = __webpack_require__(10);
	var Duration = __webpack_require__(14);
	
	/**
	 * @class
	 * @param {rest} rest
	 * @mixes MusicDataMixin
	 * @mixes MusicDataLayoutMixin
	 */
	function Rest(rest) {
	  util.extend(this, rest);
	}
	
	util.defineProperties(Rest.prototype,
	/** @lends Rest# */
	{
	  /**
	   * Type of rest.
	   * @constant
	   * @default rest
	   */
	  $type: { constant: 'rest' },
	
	  /**
	   * Duration of the rest.
	   * @type {Duration}
	   */
	  duration: {
	    get: function () {
	      return this._duration || (this._duration = new Duration());
	    },
	    set: function (duration) {
	      this._duration = new Duration(duration);
	    }
	  },
	
	  beams: {
	    get: function () {
	      return this._beams || (this._beams = []);
	    },
	    set: function (beams) {
	      this._beams = beams;
	    }
	  },
	
	  /**
	   * Convert the rest to musje source code string.
	   * @return {string} Converted musje source code.
	   */
	  toString: function () {
	    return '0' + this.duration;
	  },
	
	  toJSON: util.makeToJSON({
	    duration: undefined,
	  }, 'rest')
	});
	
	util.defineProperties(Rest.prototype, MusicDataMixin);
	
	module.exports = Rest;


/***/ },
/* 18 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var util = __webpack_require__(2);
	var MusicDataMixin = __webpack_require__(10);
	var Pitch = __webpack_require__(13);
	var Duration = __webpack_require__(14);
	
	/**
	 * @class
	 * @param {Object} chord
	 * @mixes MusicDataMixin
	 * @mixes MusicDataLayoutMixin
	 */
	function Chord(chord) {
	  util.extend(this, chord);
	}
	
	util.defineProperties(Chord.prototype,
	/** @lends Chord# */
	{
	  /**
	   * Type of chord.
	   * @constant
	   * @default chord
	   */
	  $type: { constant: 'chord' },
	
	  /**
	   * Pitches in the chord.
	   * @type {Array.<Pitch>}
	   */
	  pitches: {
	    get: function () {
	      return this._pitches || (this._pitches = []);
	    },
	    set: function (pitches) {
	      this._pitches = pitches.map(function (pitch) {
	        return new Pitch(pitch);
	      });
	    }
	  },
	
	  /**
	   * Duration of the chord.
	   * @type {Duration}
	   */
	  duration: {
	    get: function () {
	      return this._duration || (this._duration = new Duration());
	    },
	    set: function (duration) {
	      this._duration = new Duration(duration);
	    }
	  },
	
	  /**
	   * Convert chord to the musje source code string.
	   * @return {string} Converted musje source code of the chord.
	   */
	  toString: function () {
	    return '<' + this.pitches.map(function (pitch) {
	      return pitch.toString();
	    }).join('') + '>' + this.duration;
	  },
	
	  toJSON: util.makeToJSON({
	    pitches: undefined,
	    duration: undefined,
	  }, 'chord')
	});
	
	util.defineProperties(Chord.prototype, MusicDataMixin);
	
	module.exports = Chord;


/***/ },
/* 19 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var util = __webpack_require__(2);
	var MusicDataMixin = __webpack_require__(10);
	
	/**
	 * @class
	 * @param {Object} voice
	 */
	function Voice(voice) {
	  util.extend(this, voice);
	}
	
	util.defineProperties(Voice.prototype,
	/** @lends Voice# */
	{
	  /**
	   * Type of voice.
	   * @constant
	   * @default voice
	   */
	  $type: { constant: 'voice' },
	
	  /**
	   * Convert the voice to musje source code string.
	   * @return {string} Converted musje source code string.
	   */
	  toString: function () {
	
	  }
	});
	
	util.defineProperties(Voice.prototype, MusicDataMixin);
	
	module.exports = Voice;


/***/ },
/* 20 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var util = __webpack_require__(2);
	var TimewiseMeasure = __webpack_require__(21);
	
	/**
	 * Construct timewise score measures.
	 * @class
	 * @classdesc Timewise score measures.
	 * @param score {Score}
	 * @augments {Array}
	 */
	function TimewiseMeasures(score) {
	  var measures = [];
	  measures._score = score;
	  util.defineProperties(measures, properties);
	  return measures;
	}
	
	/** @lends TimewiseMeasures# */
	var properties = {
	
	  /**
	   * Reference to the parent score.
	   * @type {Score}
	   * @readonly
	   */
	  score: {
	    get: function () {
	      return this._score;
	    }
	  },
	
	  /**
	   * Make timewise score measures from the partwise parts.
	   */
	  fromPartwise: function () {
	    var that = this;
	
	    this.removeAll();
	
	    this.score.walkCells(function (cell, m) {
	      that[m] = that[m] || new TimewiseMeasure(m, that);
	      that[m].parts.push(cell);
	    });
	  },
	
	  /**
	   * Remove all measures.
	   */
	  removeAll: function () {
	    this.length = 0;
	  }
	};
	
	module.exports = TimewiseMeasures;


/***/ },
/* 21 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var util = __webpack_require__(2);
	
	/**
	 * @class
	 * @param measure {Object}
	 * @mixes TimewiseMeasureLayoutMixin
	 */
	function TimewiseMeasure(index, measures) {
	  // this._index = index;
	  this._measures = measures;
	}
	
	util.defineProperties(TimewiseMeasure.prototype,
	/** @lends TimewiseMeasure# */
	{
	  /**
	   * Reference to the parent measures instance.
	   * @member {TimewiseMeasures}
	   */
	  measures: {
	    get: function () {
	      return this._measures;
	    }
	  },
	
	  /**
	   * Parts in timewise measure.
	   * @type {Array.<Cell>}
	   */
	  parts: {
	    get: function () {
	      return this._parts || (this._parts = []);
	    },
	    set: function (parts) {
	      this._parts = parts;
	    }
	  },
	
	  /**
	   * Left bar of the measure.
	   * @type {Bar}
	   * @readonly
	   */
	  barLeft: {
	    get: function () {
	      return this.parts[0].barLeft;
	    }
	  },
	
	  /**
	   * Right bar of the measure.
	   * @type {Bar}
	   * @readonly
	   */
	  barRight: {
	    get: function () {
	      return this.parts[0].barRight;
	    }
	  }
	});
	
	module.exports = TimewiseMeasure;


/***/ },
/* 22 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var Snap = __webpack_require__(23);
	var util = __webpack_require__(2);
	var Layout = __webpack_require__(24);
	var renderBar = __webpack_require__(42);
	var renderDuration = __webpack_require__(43);
	var renderCurve = __webpack_require__(44);
	
	/**
	 * [Renderer description]
	 * @class
	 * @param svg {string}
	 * @param lo {Object}
	 */
	function Renderer(svg, lo) {
	  this._lo = util.extend(Layout.options, lo);
	  this.layout = new Layout(svg, this._lo);
	}
	
	util.defineProperties(Renderer.prototype,
	/** @lends Renderer# */
	{
	  render: function (score) {
	    this._score = score;
	    this.layout.flow(score);
	    this.renderHeader();
	    this.renderContent();
	  },
	
	  renderHeader: function () {
	    var lo = this._lo;
	    var header = this.layout.header;
	    var el = header.el;
	    var width = header.width;
	
	    el.text(width / 2, lo.titleFontSize, this._score.head.title)
	      .attr({
	        fontSize: lo.titleFontSize,
	        fontWeight: lo.titleFontWeight,
	        textAnchor: 'middle'
	      });
	
	    el.text(width, lo.titleFontSize * 1.5, this._score.head.composer)
	      .attr({
	        fontSize: lo.composerFontSize,
	        fontWeight: lo.composerFontWeight,
	        textAnchor: 'end'
	      });
	
	    header.height = el.getBBox().height;
	  },
	
	  renderContent: function () {
	    var lo = this._lo;
	
	    this.layout.content.systems.forEach(function (system) {
	      var measures = system.measures;
	      measures.forEach(function (measure) {
	        renderBar(measure, lo);
	        measure.parts.forEach(function (cell) {
	          renderCell(cell, lo);
	        });
	      });
	    });
	  }
	});
	
	function renderNote(note, cell, lo) {
	  note.el = cell.el.g().transform(Snap.matrix().translate(note.x, note.y));
	  note.el.use(note.def.pitchDef.el);
	  renderDuration(note, lo);
	}
	
	function renderCell(cell, lo) {
	  cell.data.forEach(function (data) {
	    switch (data.$type) {
	    case 'rest':
	      renderNote(data, cell, lo);
	      break;
	    case 'note':
	      renderNote(data, cell, lo);
	      renderCurve('tie', data);
	      renderCurve('slur', data);
	      break;
	    case 'time':
	      data.el = cell.el.use(data.def.el).attr({
	        x: data.x, y: data.y
	      });
	      break;
	    }
	  });
	}
	
	module.exports = Renderer;


/***/ },
/* 23 */
/***/ function(module, exports) {

	module.exports = __WEBPACK_EXTERNAL_MODULE_23__;

/***/ },
/* 24 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var util = __webpack_require__(2);
	var layoutOptions = __webpack_require__(25);
	var Defs = __webpack_require__(26);
	var SvgLayout = __webpack_require__(34);
	var BodyLayout = __webpack_require__(35);
	var HeaderLayout = __webpack_require__(36);
	var ContentLayout = __webpack_require__(37);
	
	var TimewiseMeasure = __webpack_require__(21);
	var TimewiseMeasureLayoutMixin = __webpack_require__(39);
	var Cell = __webpack_require__(7);
	var CellLayoutMixin = __webpack_require__(40);
	var MusicDataLayoutMixin = __webpack_require__(41);
	[
	  __webpack_require__(9),
	  __webpack_require__(11),
	  __webpack_require__(12),
	  __webpack_require__(17),
	  __webpack_require__(18),
	  __webpack_require__(19)
	].forEach(function (Class) {
	  util.defineProperties(Class.prototype, MusicDataLayoutMixin);
	});
	util.defineProperties(TimewiseMeasure.prototype, TimewiseMeasureLayoutMixin);
	util.defineProperties(Cell.prototype, CellLayoutMixin);
	
	/**
	 * @class
	 * @param svg {string}
	 * @param options {Object} Layout options
	 */
	function Layout(svg, options) {
	  this.options = options;
	  this.svg = svg;
	
	  this.svg = new SvgLayout(this);
	  this.body = new BodyLayout(this);
	  this.header = new HeaderLayout(this);
	  this.content = new ContentLayout(this);
	
	  this.defs = new Defs(this);
	}
	
	Layout.options = layoutOptions;
	
	util.defineProperties(Layout.prototype,
	/** @lends Layout# */
	{
	  /**
	   * @param  {Score} score
	   */
	  flow: function (score) {
	    init(this, score);
	    this.content.flow(score.measures);
	  }
	});
	
	function init(that, score) {
	  var measures = score.measures;
	  measures.forEach(function (measure, m) {
	    measure = measures[m];
	    measure.layout = that;
	    measure.parts.forEach(function (cell) {
	      cell.layout = that;
	      cell.flow();
	    });
	  });
	}
	module.exports = Layout;


/***/ },
/* 25 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var util = __webpack_require__(2);
	
	var layoutOptions = {
	  mode: 'block', // inline | block | paper
	  // width: 650,
	  // height: 600,
	  marginTop: 25,
	  marginRight: 30,
	  marginBottom: 25,
	  marginLeft: 30,
	  margin: {
	    get: function () {
	      return [this.marginTop, this.marginRight, this.marginBottom, this.marginLeft];
	    },
	    set: function (arr) {
	      switch (arr.length) {
	      case 1:
	        this.marginTop = this.marginRight = this.marginBottom = this.marginLeft = arr[0];
	        return;
	      case 2:
	        this.marginTop = this.marginBottom = arr[0];
	        this.marginRight = this.marginLeft = arr[1];
	        return;
	      case 4:
	        this.marginTop = arr[0];
	        this.marginRight = arr[1];
	        this.marginBottom = arr[2];
	        this.marginLeft = arr[3];
	        return;
	      default:
	        throw new Error('Invalid input for margin.');
	      }
	    }
	  },
	  fontSize: 20,
	  fontFamily: 'Helvetica, Arial, Sans Serif',
	
	  titleFontSize: '110%',
	  // titleFontFamily
	  titleFontWeight: 'bold',
	  composerFontSize: '90%',
	  // composerFontFamily:
	  composerFontWeight: 'bold',
	  // composerFontStyle,
	  timeFontSize: '95%',
	  timeFontWeight: 'bold',
	
	  headerSep: '100%',
	  systemSep: '180%',
	  musicDataSep: '20%',
	
	  partHeight: '120%',
	  partSep: '80%',
	
	  measurePaddingLeft: '50%',
	  measurePaddingRight: '50%',
	
	  barlineHeight: '120%',
	  thinBarlineWidth: '4%',
	  thickBarlineWidth: '16%',
	  barlineSep: '18%',
	  barlineDotRadius: '7.5%',
	  barlineDotSep: '22%',
	
	  accidentalFontSize: '95%',
	  accidentalShift: '10%',
	
	  octaveRadius: '6.6%',
	  octaveOffset: '0%',
	  octaveSep: '23%',
	
	  stepBaselineShift: '12%',  // for step without lower octave and underline
	
	  typeStrokeWidth: '5%',
	  typebarOffset: '30%',   // 1 - - -
	  typebarLength: '55%',   // off len sep len sep len (dot) ext
	  typebarSep: '45%',      // 1 -
	  typebarExt: '20%',      // off len (dot) ext
	  underbarSep: '17%',
	
	  dotOffset: '60%',       // for type = 2
	  dotRadius: '6.6%',      // 1 - . .
	  dotSep: '60%',          // off len dotOff . dotSep . ext
	  t4DotOffset: '30%',
	  t4DotSep: '50%',
	  t4DotExt: '25%',
	  t4DotBaselineShift: '20%'
	};
	
	var fontSize = layoutOptions.fontSize;
	
	util.objEach(layoutOptions, function (value, key) {
	  if (typeof value !== 'string') { return; }
	
	  var unit = value.replace(/[\d\.]+/, '');
	  value = +value.replace(/[^\d\.]+/, '');
	
	  switch (unit) {
	  case '%':
	    layoutOptions[key] = fontSize * value / 100;
	    break;
	  case '': // fall through
	  case 'px':
	    layoutOptions[key] = value;
	    break;
	  case 'others to be implemented':
	    break;
	  }
	});
	
	module.exports = layoutOptions;


/***/ },
/* 26 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var util = __webpack_require__(2);
	var AccidentalDef = __webpack_require__(27);
	var BarDef = __webpack_require__(29);
	var DurationDef = __webpack_require__(30);
	var PitchDef = __webpack_require__(31);
	var TimeDef = __webpack_require__(32);
	
	var defIdMixins = __webpack_require__(33);
	var Time = __webpack_require__(9);
	var Bar = __webpack_require__(11);
	var Note = __webpack_require__(12);
	var Rest = __webpack_require__(17);
	var Pitch = __webpack_require__(13);
	var Duration = __webpack_require__(14);
	util.defineProperties(Time.prototype, defIdMixins.Time);
	util.defineProperties(Bar.prototype, defIdMixins.Bar);
	util.defineProperties(Note.prototype, defIdMixins.Note);
	util.defineProperties(Rest.prototype, defIdMixins.Rest);
	util.defineProperties(Pitch.prototype, defIdMixins.Pitch);
	util.defineProperties(Duration.prototype, defIdMixins.Duration);
	
	
	/**
	 * @class
	 * @param {Layout} layout
	 */
	function Defs(layout) {
	  this._layout = layout;
	}
	
	util.defineProperties(Defs.prototype,
	/** @lends Defs# */
	{
	  /**
	   * Get the svg def of the music data.
	   * @param  musicData {MusicDataMixin} music data
	   * @return {Def}
	   */
	  get: function (musicData) {
	    var id = musicData.defId;
	    return this[id] || (this[id] = makeDef(id, musicData, this));
	  },
	
	  getAccidental: function (accidental) {
	    var id = 'a' + accidental.replace(/#/g, 's');
	    return this[id] ||
	          (this[id] = new AccidentalDef(id, accidental, this._layout));
	  },
	
	  _getPitch: function (id, pitch, underbar) {
	    return this[id] ||
	          (this[id] = new PitchDef(id, pitch, underbar, this));
	  }
	});
	
	
	function makeDef(id, musicData, defs) {
	  switch (musicData.$type) {
	  case 'bar':
	    return new BarDef(id, musicData, defs._layout);
	  case 'time':
	    return new TimeDef(id, musicData, defs._layout);
	  case 'note':
	    return makeNoteDef(musicData, defs);
	  case 'rest':
	    return makeRestDef(musicData, defs);
	  case 'duration':
	    return new DurationDef(id, musicData, defs._layout);
	  default:
	    return { width: 0, height: 0 };
	  }
	}
	
	function makeNoteDef(note, defs) {
	  var underbar = note.duration.underbar;
	  var pitchId = note.pitch.defId + underbar;
	  var pitchDef = defs._getPitch(pitchId, note.pitch, underbar);
	  var durationDef = defs.get(note.duration);
	  return {
	    pitchDef: pitchDef,
	    durationDef: durationDef,
	    height: pitchDef.height,
	    width: pitchDef.width + durationDef.width *
	                            (underbar ? pitchDef.scale.x : 1)
	  };
	}
	
	function makeRestDef(rest, defs) {
	  var restNote = new Note({
	    pitch: { step: 0 }, duration: rest.duration
	  });
	  return makeNoteDef(restNote, defs);
	}
	
	module.exports = Defs;


/***/ },
/* 27 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var Snap = __webpack_require__(23);
	var svgPaths = __webpack_require__(28);
	
	/**
	 * SVG definition for accidental.
	 * @class
	 * @param {string} id         [description]
	 * @param {string} accidental [description]
	 * @param {Layout} layout     [description]
	 */
	function AccidentalDef(id, accidental, layout) {
	  var lo = layout.options;
	  var el = this.el = layout.svg.el.g().attr('id', id);
	  var accKey = accidental.replace(/bb/, 'b'); // double flat to be synthesized
	  var pathData = svgPaths[accKey];
	  var ratio = svgPaths.ACCIDENTAL_RATIOS[accKey];
	  var shift = svgPaths.ACCIDENTAL_SHIFTS[accKey];
	  var path = el.path(pathData);
	  var bb = el.getBBox();
	
	  path.transform(Snap.matrix()
	    .translate(0.1 * lo.accidentalShift, -lo.accidentalShift)
	    .scale(ratio * lo.accidentalFontSize)
	    .translate(-bb.x, shift - bb.y2)
	  );
	
	  // Combine two flat to be double flat.
	  if (accidental === 'bb') {
	    el.use(path).attr('x', lo.accidentalFontSize * 0.24);
	    el.transform('scale(0.9,1)');
	  }
	
	  bb = el.getBBox();
	  this.width = bb.width * 1.2;
	
	  el.toDefs();
	}
	
	module.exports = AccidentalDef;


/***/ },
/* 28 */
/***/ function(module, exports) {

	'use strict';
	
	var svgPaths = {
	
	  // https://upload.wikimedia.org/wikipedia/commons/a/a6/Sharp.svg
	  '#': 'M6.102,7.457V2.753L8.102,2.201V6.881L6.102,7.457zM10.04,6.319L8.665,6.713V2.033L10.04,1.649V-0.295L8.665,0.089V-4.69277H8.102V0.234L6.102,0.809V-3.84077H5.571V0.986L4.196,1.371V3.319L5.571,2.935V7.606L4.196,7.989V9.929L5.571,9.545V14.299L6.102,14.29977V9.375L8.102,8.825V13.45077H8.665V8.651L10.04,8.266V6.319z',
	
	  // https://upload.wikimedia.org/wikipedia/commons/3/3a/DoubleSharp.svg
	  '##': 'M5.009,8.30721C4.27443,8.19192 3.52769,8.19209 2.7858,8.19294C2.77007,7.65011 2.85674,7.0729 2.6415,6.56343C2.49821,6.22426 2.22532,5.95665 1.98269,5.68155C1.59552,6.0278 1.27751,6.48475 1.24704,7.01638C1.21706,7.40767 1.23902,7.80085 1.2322,8.19294C0.4904,8.20416-0.25918,8.16828-0.991,8.314C-0.84988,7.5863-0.88195,6.84171-0.86917,6.1048C-0.3043,6.08953 0.30023,6.17101 0.82484,5.92526C1.13441,5.78023 1.39653,5.55295 1.6591,5.33676C1.3173,4.94965 0.87346,4.60861 0.33665,4.57651C-0.06427,4.54485-0.46734,4.56793-0.86917,4.56097C-0.89434,3.82949-0.80895,3.08855-0.96079,2.3663C-0.23733,2.49697 0.50065,2.46343 1.2322,2.47284C1.24306,2.99383 1.18483,3.53381 1.33191,4.0355C1.44414,4.41838 1.74978,4.71293 2.0051,5.01521C2.36553,4.70111 2.69057,4.30706 2.75011,3.81412C2.804,3.36793 2.76123,2.91977 2.7858,2.47284C3.52263,2.45348 4.28215,2.54713 4.99535,2.314C4.88891,3.05711 4.87889,3.81152 4.88717,4.56097C4.36127,4.57582 3.80954,4.51747 3.30955,4.69457C2.92975,4.8291 2.63114,5.12341 2.32869,5.38325C2.65661,5.71867 3.0516,6.02802 3.5403,6.07368C3.98834,6.11554 4.43829,6.09658 4.88717,6.1048C4.89828,6.83958 4.86193,7.5825 5.009,8.30721z',
	
	  // https://upload.wikimedia.org/wikipedia/commons/b/ba/Flat.svg
	  b: 'M8.166,3.657C8.166,4.232 7.950425,4.78273 7.359,5.52188C6.732435,6.30494 6.205,6.75313 5.51,7.28013V3.848C5.668,3.449 5.901,3.126 6.21,2.878C6.518,2.631 6.83,2.507 7.146,2.507C7.668,2.507 7.999,2.803 8.142,3.393C8.158,3.441 8.166,3.529 8.166,3.657zM8.091,1.257C7.66,1.257 7.222,1.376 6.776,1.615C6.33,1.853 5.908,2.172 5.51,2.569V-4.70267H4.947 V7.75213C4.947,8.10413 5.043,8.28013 5.235,8.28013C5.346,8.28013 5.483913,8.18713 5.69,8.06413C6.27334,7.71598 6.636935,7.48332 7.032,7.23788C7.482617,6.95792 7.99,6.631 8.661,5.991C9.124,5.526 9.459,5.057 9.667,4.585C9.874,4.112 9.978,3.644 9.978,3.179C9.978,2.491 9.795,2.002 9.429,1.713C9.015,1.409 8.568,1.257 8.091,1.257z',
	
	  // https://upload.wikimedia.org/wikipedia/commons/f/f4/Music-natural.svg
	  n: 'M 0,14.112V41.52h-1.248V31.248l-6.672,1.728V5.232h1.2v10.704l6.72,-1.824zm-6.72,6.432v7.536l5.472,-1.44v-7.536l-5.472,1.44z',
	
	  ACCIDENTAL_RATIOS: { '#': 0.043, 'n': 0.023, '##': 0.062, b: 0.057 },
	  ACCIDENTAL_SHIFTS: { '#': 1, 'n': 2, '##': -4, b: 0 }
	};
	
	module.exports = svgPaths;


/***/ },
/* 29 */
/***/ function(module, exports) {

	'use strict';
	
	/**
	 * SVG definition for barline.
	 * @class
	 * @param {string} id     [description]
	 * @param {Bar} bar    [description]
	 * @param {Layout} layout [description]
	 */
	function BarDef(id, bar, layout) {
	  var lo = layout.options;
	  var x = 0;
	  var lineWidth;
	  this.el = layout.svg.el.g().attr('id', id).toDefs();
	
	  switch (bar.value) {
	  case 'single':
	    lineWidth = lo.thinBarlineWidth;
	    addBarline(this, x, lineWidth);
	    x += lineWidth;
	    break;
	  case 'double':
	    lineWidth = lo.thinBarlineWidth;
	    addBarline(this, x, lineWidth);
	    x += lineWidth + lo.barlineSep;
	    addBarline(this, x, lineWidth);
	    x += lineWidth;
	    break;
	  case 'end':
	    lineWidth = lo.thinBarlineWidth;
	    addBarline(this, x, lineWidth);
	    x += lineWidth + lo.barlineSep;
	    lineWidth = lo.thickBarlineWidth;
	    addBarline(this, x, lineWidth);
	    x += lineWidth;
	    break;
	  case 'repeat-begin':
	    lineWidth = lo.thickBarlineWidth;
	    addBarline(this, x, lineWidth);
	    x += lineWidth + lo.barlineSep;
	    lineWidth = lo.thinBarlineWidth;
	    addBarline(this, x, lineWidth);
	    x += lineWidth + lo.barlineDotSep + lo.barlineDotRadius;
	    break;
	  case 'repeat-end':
	    x = lo.barlineDotSep + lo.barlineDotRadius;
	    lineWidth = lo.thinBarlineWidth;
	    addBarline(this, x, lineWidth);
	    x += lineWidth + lo.barlineSep;
	    lineWidth = lo.thickBarlineWidth;
	    addBarline(this, x, lineWidth);
	    x += lineWidth;
	    break;
	  case 'repeat-both':
	    x = lo.barlineDotSep + lo.barlineDotRadius;
	    lineWidth = lo.thinBarlineWidth;
	    addBarline(this, x, lineWidth);
	    x += lineWidth + lo.barlineSep;
	    lineWidth = lo.thickBarlineWidth;
	    addBarline(this, x, lineWidth);
	    x += lineWidth + lo.barlineSep;
	    lineWidth = lo.thinBarlineWidth;
	    addBarline(this, x, lineWidth);
	    x += lineWidth + lo.barlineDotSep + lo.barlineDotRadius;
	    break;
	  }
	  this.width = x;
	}
	
	function addBarline(that, x, width) {
	  that.el.rect(x, 0, width, 1);
	}
	
	module.exports = BarDef;


/***/ },
/* 30 */
/***/ function(module, exports) {

	'use strict';
	
	/**
	 * SVG definition for duration.
	 * @class
	 * @param {string} id       [description]
	 * @param {Duration} duration [description]
	 * @param {Layout} layout   [description]
	 */
	function DurationDef(id, duration, layout) {
	  this._id = id;
	  this._layout = layout;
	
	  // only make def el for:
	  // id = d10, d11, d12, d20, d21, d20, d41, d40
	  switch (duration.type) {
	  case 1:   // whole note
	    makeEl(this);
	    makeType1(this, id, duration.dot);
	    break;
	  case 2:   // half note
	    makeEl(this);
	    makeType2(this, id, duration.dot);
	    break;
	  default:  // other note types type quarter note def
	    if (duration.dot === 0) {
	      this.width = 0 ;
	    } else {
	      makeEl(this);
	      makeType4(this, id, duration.dot);
	    }
	  }
	}
	
	function makeType1(that, id, dot) {
	  var lo = that._layout.options;
	  var x = lo.typebarOffset;
	
	  addLine(that, x);
	  x += lo.typebarLength + lo.typebarSep;
	  addLine(that, x);
	  x += lo.typebarLength + lo.typebarSep;
	  addLine(that, x);
	  x += lo.typebarLength;
	
	  that.width = addDot(that, x, dot, 1);
	}
	
	function makeType2(that, id, dot) {
	  var lo = that._layout.options;
	  var x = lo.typebarOffset;
	
	  addLine(that, lo.typebarOffset);
	  x += lo.typebarLength;
	  that.width = addDot(that, x, dot, 2);
	}
	
	function makeType4(that, id, dot) {
	  var lo = that._layout.options;
	  var x = lo.t4DotOffset;
	  that.el.circle(x, -lo.t4DotBaselineShift, lo.dotRadius);
	
	  if (dot > 1) {
	    x += lo.t4DotSep;
	    that.el.circle(x, -lo.t4DotBaselineShift, lo.dotRadius);
	  }
	  that.width = x + lo.t4DotExt;
	}
	
	function makeEl(that) {
	  that.el = that._layout.svg.el.g()
	              .attr('id', that._id)
	              .toDefs();
	}
	
	function addLine(that, x) {
	  var lo = that._layout.options;
	  that.el.rect(x, -lo.typeStrokeWidth,
	               lo.typebarLength, lo.typeStrokeWidth);
	}
	
	// Add dot for type 1 (whole) or type 2 (half) note.
	function addDot(that, x, dot, type) {
	  var lo = that._layout.options;
	
	  if (dot > 0) {
	    x += lo.dotOffset * (type === 1 ? 1.2 : 1);
	    that.el.circle(x, 0, lo.dotRadius);
	  }
	  if (dot > 1) {
	    x += lo.dotSep * (type === 1 ? 1.2 : 1);
	    that.el.circle(x, 0, lo.dotRadius);
	  }
	  return x + lo.typebarExt;
	}
	
	module.exports = DurationDef;


/***/ },
/* 31 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var Snap = __webpack_require__(23);
	var util = __webpack_require__(2);
	
	/**
	 * SVG definition for pitch.
	 * The `PitchDef` is defined by properties: a s o u
	 * accidental step octave underbar
	 * @class
	 * @param id {string}     [description]
	 * @param pitch {Pitch}   [description]
	 * @param layout {Layout} [description]
	 */
	function PitchDef(id, pitch, underbar, defs) {
	  var layout = this._layout = defs._layout;
	  var accidental = pitch.accidental;
	  var octave = pitch.octave;
	  var scale = getScale(accidental, octave, underbar);
	  var el = this.el = layout.svg.el.g()
	    .attr({
	      id: id,
	      stroke: 'black',
	      strokeWidth: 2 - (scale.x + scale.y)
	    });
	  var matrix, sbbox, pbbox;
	
	  this._defs = defs;
	  addAccidental(this, accidental);
	  addStep(this, pitch.step);
	  addOctave(this, octave);
	
	  matrix = getMatrix(this, scale, octave, underbar);
	  el.transform(matrix);
	
	  sbbox = this._sbbox;
	  sbbox = getBBoxAfterTransform(this.el, sbbox, matrix);
	
	  pbbox = el.getBBox();
	  el.toDefs();
	
	  util.extend(this, {
	    scale: scale,
	    matrix: matrix,
	    width: pbbox.width,
	    height: -pbbox.y,
	    stepCx: sbbox.cx,
	    stepY: sbbox.y,
	    stepCy: sbbox.cy,
	    stepY2: sbbox.y2,
	    stepTop: octave > 0 ? pbbox.y : sbbox.y + layout.options.fontSize * 0.2
	  });
	}
	
	function addAccidental(that, accidental) {
	  if (!accidental) {
	    that._accidentalX2 = 0;
	    return;
	  }
	  var accDef = that._defs.getAccidental(accidental);
	  that.el.use(accDef.el).attr('y', -that._layout.options.accidentalShift);
	  that._accidentalX2 = accDef.width;
	}
	
	function addStep(that, step) {
	  that._sbbox = that.el
	    .text(that._accidentalX2, 0, '' + step)
	    .attr('font-size', that._layout.options.fontSize)
	    .getBBox();
	}
	
	function addOctave(that, octave) {
	  if (!octave) { return; }
	
	  var lo = that._layout.options;
	  var octaveRadius = lo.octaveRadius;
	  var octaveOffset = lo.octaveOffset;
	  var octaveSep = lo.octaveSep;
	  var octaveEl = that.el.g();
	  var i;
	
	  if (octave > 0) {
	    for (i = 0; i < octave; i++) {
	      octaveEl.circle(that._sbbox.cx, that._sbbox.y + octaveOffset - octaveSep * i, octaveRadius);
	    }
	  } else {
	    for (i = 0; i > octave; i--) {
	      octaveEl.circle(
	        that._sbbox.cx,
	        that._sbbox.y2 - octaveOffset - octaveSep * i, octaveRadius
	      );
	    }
	  }
	  that.el.add(octaveEl);
	}
	
	// Transform the pitch to be in a good baseline position and
	// scale it to be more square.
	function getMatrix(that, scale, octave, underbar) {
	  var lo = that._layout.options;
	  var pbbox = that.el.getBBox();
	  var dy = (octave >= 0 && underbar === 0 ? -lo.stepBaselineShift : 0) -
	                          underbar * lo.underbarSep;
	  return Snap.matrix()
	    .translate(-pbbox.x, dy)
	    .scale(scale.x, scale.y)
	    .translate(0, util.near(pbbox.y2, that._sbbox.y2) ? 0 : -pbbox.y2);
	}
	
	function getBBoxAfterTransform(container, bbox, matrix) {
	  var rect = container.rect(bbox.x, bbox.y, bbox.width, bbox.height);
	  var g = container.g(rect);
	  rect.transform(matrix);
	  bbox = g.getBBox();
	  g.remove();
	  return bbox;
	}
	
	function getScale(hasAccidental, octave, underbar) {
	  var absOctave = Math.abs(octave);
	  return {
	    x: Math.pow(0.97, absOctave + underbar + (hasAccidental ? 2 : 0)),
	    y: Math.pow(0.95, absOctave + underbar + (hasAccidental ? 1 : 0))
	  };
	}
	
	module.exports = PitchDef;


/***/ },
/* 32 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var Snap = __webpack_require__(23);
	
	/**
	 * SVG definition for time signature.
	 * @class
	 * @param {string} id     [description]
	 * @param {Time} time   [description]
	 * @param {Layout} layout [description]
	 */
	function TimeDef(id, time, layout) {
	  var lo = layout.options;
	  var timeFontSize = lo.timeFontSize;
	  var lineExtend = timeFontSize * 0.1;
	  var el = this.el = layout.svg.el.g()
	    .attr({
	      id: id,
	      fontSize: timeFontSize,
	      fontWeight: lo.timeFontWeight,
	      textAnchor: 'middle'
	    });
	  var lineY = -0.85 * timeFontSize;
	  var bb;
	
	  el.text(0, -1 * timeFontSize, time.beats);
	  el.text(0, 0, time.beatType);   // baseline y = 0
	  bb = el.getBBox();
	  el.line(bb.x - lineExtend, lineY, bb.x2 + lineExtend, lineY);
	  el.transform(Snap.matrix().scale(1, 0.8).translate(lineExtend - bb.x, 0));
	
	  bb = el.getBBox();
	  el.toDefs();
	
	  this.width = bb.width;
	  this.height = -bb.y;
	}
	
	module.exports = TimeDef;


/***/ },
/* 33 */
/***/ function(module, exports) {

	'use strict';
	
	var BAR_TO_ID = {
	  single: 'bs', double: 'bd', end: 'be',
	  'repeat-begin': 'brb', 'repeat-end': 'bre', 'repeat-both': 'brbe'
	};
	
	var defIdMixins = {
	
	  /**
	   * Def id used in the SVG <defs> element.
	   * ```
	   * id := 't' beats '-' beatType
	   * ```
	   * E.g. `t3-4`
	   * @member
	   * @alias musje.Time#defId
	   * @type {string}
	   * @readonly
	   */
	  Time: {
	    defId: {
	      get: function () {
	        return ['t', this.beats, '-', this.beatType].join('');
	      }
	    }
	  },
	
	  /**
	   * Def id used in the SVG <defs> element.
	   * ```
	   * defId    Bar value
	   * ----------------------
	   * 'bs'   - single
	   * 'bd'   - double
	   * 'be'   - repeat-end
	   * 'brb'  - repeat-begin
	   * 'bre'  - repeat-end
	   * 'brbe' - repeat-both
	   * ```
	   * @member
	   * @alias musje.Bar#defId
	   * @type {string}
	   * @readonly
	   */
	  Bar: {
	    defId: {
	      get: function () {
	        return BAR_TO_ID[this.value];
	      }
	    }
	  },
	
	  /**
	   * Unique def id of the note used in the SVG <defs> element.
	   * ```
	   * defId := 'n' accidental step octave type dot
	   * ```
	   * E.g.
	   * ```
	   * Note     defId
	   * ------------------
	   * 1        n1040
	   * b3-      nb3020
	   * #5'_.    ns5181
	   * 6,,      n6-2
	   * ```
	   * @member
	   * @alias musje.Note#defId
	   * @type {string}
	   * @readonly
	   */
	  Note: {
	    defId: {
	      get: function () {
	        var pitch = this.pitch, duration = this.duration;
	        return [
	          'n', pitch.accidental.replace(/#/g, 's'),
	          pitch.step, pitch.octave, duration.type, duration.dot
	        ].join('');
	      }
	    }
	  },
	
	  /**
	   * Unique def id of the rest used in the SVG <defs> element.
	   * ```
	   * defId := 'r' type dot
	   * ```
	   * E.g.
	   * ```
	   * Rest     defId
	   * ----------------
	   * 0        r40
	   * 0 -      r20
	   * 0=.      r161
	   * ```
	   *
	   * @member
	   * @alias musje.Rest#defId
	   * @type {string}
	   * @readonly
	   */
	  Rest: {
	    defId: {
	      get: function () {
	        var duration = this.duration;
	        return 'r' + duration.type + duration.dot;
	      }
	    }
	  },
	
	  /**
	   * Def id used in the SVG <defs> element.
	   * ```
	   * defId := 'p' accidental step octave
	   * ```
	   * @member
	   * @alias musje.Pitch#defId
	   * @type {string}
	   * @readonly
	   */
	  Pitch: {
	    defId: {
	      get: function () {
	        return ['p', this.accidental.replace(/#/g, 's'),
	                     this.step, this.octave].join('');
	      }
	    }
	  },
	
	  /**
	   * Def id used in the SVG <defs> element.
	   * ```
	   * defId := 'd' type dot
	   * ```
	   * *E.g.*
	   * ```
	   * Note     defId
	   * ----------------
	   * 1.       d41
	   * 1_       d80
	   * 1=       d160
	   * 1-..     d22
	   * ```
	   * @member
	   * @alias musje.Duration#defId
	   * @type {string}
	   * @readonly
	   */
	  Duration: {
	    defId: {
	      get: function () {
	        return 'd' + this.type + this.dot;
	      }
	    }
	  }
	};
	
	module.exports = defIdMixins;


/***/ },
/* 34 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var Snap = __webpack_require__(23);
	var util = __webpack_require__(2);
	
	/**
	 * @class
	 * @param layout {Layout}
	 */
	function SvgLayout(layout) {
	  this._layout = layout;
	  var lo = layout.options;
	  this._el = Snap(layout.svg)
	    .attr({ fontFamily: lo.fontFamily })
	    .addClass('musje');
	  this.el.clear();
	  this.width = lo.width;
	}
	
	util.defineProperties(SvgLayout.prototype,
	/** @lends SvgLayout# */
	{
	  el: {
	    get: function () {
	      return this._el;
	    }
	  },
	
	  /**
	   * Width of the svg.
	   * @type {number}
	   */
	  width: {
	    get: function () {
	      return this._w;
	    },
	    set: function (w) {
	      this._w = w;
	      this.el.attr('width', w);
	      var body = this._layout.body;
	      if (body) { body.width = w; }
	    }
	  },
	
	  /**
	   * Height of the svg.
	   * @type {number}
	   */
	  height: {
	    get: function () {
	      return this._h;
	    },
	    set: function (h) {
	      this._h = h;
	      this.el.attr('height', h);
	    }
	  }
	});
	
	module.exports = SvgLayout;


/***/ },
/* 35 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var Snap = __webpack_require__(23);
	var util = __webpack_require__(2);
	
	/**
	 * Body
	 * @class
	 * @param {Layout} layout
	 */
	function BodyLayout(layout) {
	  this._layout = layout;
	  var svg = layout.svg;
	  var lo = layout.options;
	  this._el = svg.el.g()
	      .transform(Snap.matrix().translate(lo.marginLeft, lo.marginTop))
	      .addClass('mus-body');
	  this.width = lo.width - lo.marginLeft - lo.marginRight;
	}
	
	util.defineProperties(BodyLayout.prototype,
	/** @lends BodyLayout# */
	{
	  el: {
	    get: function () {
	      return this._el;
	    }
	  },
	
	  /**
	   * Width of the body.
	   * - (Getter) Get the body width.
	   * - (Setter) Set the body width and this also induces setting the
	   * header and content width if one exists.
	   * @type {number}
	   */
	  width: {
	    get: function () {
	      return this._w;
	    },
	    set: function (w) {
	      this._w = w;
	      var layout = this._layout;
	      if (layout.header) { layout.header.width = w; }
	      if (layout.content) { layout.content.width = w; }
	    }
	  },
	
	  /**
	   * Height of the body.
	   * - (Getter) Get the body height.
	   * - (Setter) Set the body height and this will also cause the height of svg to vary.
	   * @type {number}
	   */
	  height: {
	    get: function () {
	      return this._h;
	    },
	    set: function (h) {
	      var layout = this._layout, lo = layout.options;
	      layout.svg.height = h + lo.marginTop + lo.marginBottom;
	      this._h = h;
	    }
	  }
	});
	
	module.exports = BodyLayout;


/***/ },
/* 36 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var util = __webpack_require__(2);
	
	/**
	 * Header layout.
	 * @class
	 * @param {Layout} layout
	 */
	function HeaderLayout(layout) {
	  this._layout = layout;
	  this.el = layout.body.el.g().addClass('mus-header');
	  this.width = layout.body.width;
	}
	
	util.defineProperties(HeaderLayout.prototype,
	/** @lends HeaderLayout# */
	{
	  /**
	   * Width of the header.
	   * @type {number}
	   */
	  width: {
	    get: function () {
	      return this._w;
	    },
	    set: function (w) {
	      this._w = w;
	    }
	  },
	
	  /**
	   * Height of the header.
	   * @type {number}
	   */
	  height: {
	    get: function () {
	      return this._h;
	    },
	    set: function (h) {
	      this._h = h;
	      var layout = this._layout;
	      layout.content.y = h ? h + layout.options.headerSep : 0;
	    }
	  }
	});
	
	module.exports = HeaderLayout;


/***/ },
/* 37 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var Snap = __webpack_require__(23);
	var util = __webpack_require__(2);
	var SystemLayout = __webpack_require__(38);
	
	/**
	 * @class
	 * @param {Object} layout - Reference to the parent layout instance.
	 */
	function ContentLayout(layout) {
	  this.layout = layout;
	  this.el = layout.body.el.g().addClass('mus-content');
	  this.width = layout.body.width;
	}
	
	util.defineProperties(ContentLayout.prototype,
	/** @lends ContentLayout# */
	{
	  y: {
	    get: function () {
	      return this._y;
	    },
	    set: function (y) {
	      this._y = y;
	      this.el.transform(Snap.matrix().translate(0, y));
	      resizeBody(this);
	    }
	  },
	
	  width: {
	    get: function () {
	      return this._w;
	    },
	    set: function (w) {
	      this._w = w;
	    }
	  },
	
	  height: {
	    get: function () {
	      var last = this.systems[this.systems.length - 1];
	      return last ? last.y + last.height : 0;
	    }
	  },
	
	  /**
	   * @param scoreMeasure {musje.TimewiseMeasures} The timewise score measure.
	   */
	  flow: function (scoreMeasures) {
	    makeSystems(this, scoreMeasures);
	    balanceSystems(this);
	    this.systems.forEach(function (system) { system.flow(); });
	  }
	});
	
	function resizeBody(that) {
	  var layout = that.layout, hHeight = layout.header.height;
	
	  layout.body.height = that.height +
	        (hHeight ? hHeight + layout.options.headerSep : 0);
	}
	
	/**
	 * Divide measures in timewise score into the systems.
	 * @param scoreMeasure {musje.TimewiseMeasures} The timewise score measure.
	 */
	function makeSystems(that, scoreMeasures) {
	  var layout = that.layout;
	  var lo = layout.options;
	  var measurePadding = lo.measurePaddingLeft + lo.measurePaddingRight;
	  var system = new SystemLayout(layout, 0);
	  var systems = that.systems = [system];
	
	  scoreMeasures.forEach(function (measure) {
	    var minWidth = measure.minWidth + measurePadding +
	                  (measure.barLeftInSystem.width +
	                   measure.barRightInSystem.width) / 2;
	
	    // Continue put this measure in the system.
	    if (system.minWidth + minWidth < that.width) {
	      system.measures.push(measure);
	
	    // New system
	    } else {
	      system = new SystemLayout(layout, systems.length);
	      systems.push(system);
	      system.measures.push(measure);
	    }
	  });
	}
	
	function getMaxLengthSystem(that) {
	  var maxLength = 0, i, system;
	
	  that.systems.forEach(function (system) {
	    maxLength = Math.max(maxLength, system.measures.length);
	  });
	
	  // Find the first max length system backward.
	  for(i = that.systems.length - 1; i >= 0; i--) {
	    system = that.systems[i];
	    if (system.measures.length === maxLength) { return system; }
	  }
	}
	
	function isNotBalancable(that) {
	  var systems = that.systems;
	  var len = systems.length;
	  return len === 1 ||       // only 1 system
	        (len === 2 && systems[1].minWidth < that.width * 0.4); // 1 2/5 systems
	}
	
	function balanceSystems(that) {
	  if (isNotBalancable(that)) { return; }
	
	  var systems = that.systems;
	  var last = systems[systems.length - 1];
	  var system = getMaxLengthSystem(that);
	  var next, prev;
	
	  // Move measures down to balance the last system.
	  while (last.measures.length < system.measures.length - 1) {
	
	    // Move a measure tail-to-head downward to the last measure.
	    while (true) {
	      next = system.next;
	      if (!next) { break; }
	      next.measures.unshift(system.measures.pop());
	      system = next;
	    }
	    system = getMaxLengthSystem(that);
	  }
	
	  // Move back measures if the system exceeds the content width.
	  system = last;
	  while (system) {
	    prev = system.prev;
	    while (system.minWidth > that.width) {
	      prev.measures.push(system.measures.shift());
	    }
	    system = prev;
	  }
	}
	
	module.exports = ContentLayout;


/***/ },
/* 38 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var Snap = __webpack_require__(23);
	var util = __webpack_require__(2);
	
	/**
	 * @class
	 * @param {number} index
	 * @param {Layout} layout
	 */
	function SystemLayout(layout, index) {
	  this._index = index;
	  this._layout = layout;
	  this._el = layout.content.el.g().addClass('mus-system');
	}
	
	util.defineProperties(SystemLayout.prototype,
	/** @lends SystemLayout# */
	{
	  el: {
	    get: function () {
	      return this._el;
	    }
	  },
	
	  /**
	   * Measures in a system.
	   * @type {Array.<TimewiseMeasure>}
	   * @readonly
	   */
	  measures: {
	    get: function () {
	      return this._measures || (this._measures = []);
	    }
	  },
	
	  /**
	   * Previous system.
	   * @type {SystemLayout}
	   */
	  prev: {
	    get: function () {
	      return this._layout.content.systems[this._index - 1];
	    }
	  },
	
	  /**
	   * Next system.
	   * @type {SystemLayout}
	   */
	  next: {
	    get: function () {
	      return this._layout.content.systems[this._index + 1];
	    }
	  },
	
	  y: {
	    get: function () {
	      return this._y;
	    },
	    set: function (y) {
	      this._y = y;
	      this.el.transform(Snap.matrix().translate(0, y));
	    }
	  },
	
	  width: {
	    get: function () {
	      return this._layout.content.width;
	    }
	  },
	
	  minWidth: {
	    get: function () {
	      var min = 0;
	      this.measures.forEach(function (measure) {
	        min += measure.minWidth;
	      });
	      return min;
	    }
	  },
	
	  content: {
	    get: function () {
	      return this._layout.content;
	    }
	  },
	
	  systems: {
	    get: function () {
	      return this.content.systems;
	    }
	  },
	
	  flow: function () {
	    var system = this;
	    var minHeight = 0;
	    var x = 0;
	
	    tuneMeasuresWidths(this);
	
	    this.measures.forEach(function (measure, m) {
	      measure.system = system;
	      measure._sIndex = m;
	      measure.flow();
	      measure.x = x;
	      x += measure.width;
	      minHeight = Math.max(minHeight, measure.minHeight);
	    });
	
	    var prev = this.prev;
	    this.y = prev ? prev.y + prev.height + this._layout.options.systemSep : 0;
	    this.height = minHeight;
	  }
	});
	
	function tuneMeasuresWidths(that) {
	  if (!isTunable(that)) { return; }
	
	  var pairs = getPairs(that.measures);
	  var length = pairs.length;
	  var widthLeft = that.width;
	  var itemLeft = length;
	  var i = 0;    // i + itemLeft === length
	  var width;
	
	  while (i < length) {
	    if (widthLeft >= pairs[i].width * itemLeft) {
	      width = widthLeft / itemLeft;
	      do {
	        pairs[i].measure.width = width;
	        i++;
	      } while (i < length);
	      break;
	    } else {
	      width = pairs[i].width;
	      pairs[i].measure.width = width;
	      widthLeft -= width;
	      i++;
	      itemLeft--;
	    }
	  }
	}
	
	function isTunable(that) {
	  var ctWidth = that.content.width;
	  var s = that._index;
	  var ssLen = that.systems.length;
	  return ssLen > 2 ||
	     (ssLen === 1 && that.minWidth > ctWidth * 0.7) ||
	     (ssLen === 2 && (s === 0 ||
	                     (s === 1 && that.minWidth > ctWidth * 0.4)));
	}
	
	function descendingSort(a, b) { return b.width - a.width; }
	
	function getPairs(measures) {
	  return measures.map(function (measure) {
	    return {
	      width: measure.minWidth,
	      measure: measure
	    };
	  }).sort(descendingSort);
	}
	
	module.exports = SystemLayout;


/***/ },
/* 39 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var Snap = __webpack_require__(23);
	
	/**
	 * TimewiseMeasure Layout mixin.
	 * @mixin
	 */
	var TimewiseMeasureLayoutMixin = {
	
	  /**
	   * Measure SVG group element.
	   * @type {Snap.Element}
	   * @readonly
	   */
	  el: {
	    get: function () {
	      return this._el;
	    }
	  },
	
	  /**
	   * Minimun width of the measure.
	   * @type {number}
	   */
	  minWidth: {
	    get: function () {
	      var minWidth = 0;
	      this.parts.forEach(function (cell) {
	        minWidth = Math.max(minWidth, cell.minWidth);
	      });
	      return minWidth + this.padding;
	    }
	  },
	
	  /**
	   * Reference to the parent system of this measure.
	   * - (Getter)
	   * - (Setter) The measure el will be created, and the height of the measure will be set.
	   * @type {SystemLayout}
	   */
	  system: {
	    get: function () {
	      return this._s;
	    },
	    set: function (system) {
	      this._s = system;
	      this._el = system.el.g().addClass('mus-measure');
	    }
	  },
	
	  padding: {
	    get: function () {
	      var lo = this.layout.options;
	      return lo.measurePaddingRight + lo.measurePaddingLeft;
	    }
	  },
	
	  outerWidth: {
	    get: function () {
	      return this.outerWidthLeft + this.outerWidthRight;
	    }
	  },
	
	  outerWidthLeft: {
	    get: function () {
	      return this.layout.options.measurePaddingLeft +
	              this.barLeftInSystem.width / 2;
	    }
	  },
	
	  outerWidthRight: {
	    get: function () {
	      return this.layout.options.measurePaddingRight +
	              this.barRightInSystem.width / 2;
	    }
	  },
	
	  /**
	   * Width of the measure.
	   * - (Getter)
	   * - (Setter) Set width of the measure and also set the widths of the containing cells.
	   * @type {number}
	   */
	  width: {
	    get: function () {
	      return this._w || (this._w = this.minWidth);
	    },
	    set: function (w) {
	      this._w = w;
	      var outerWidth = this.outerWidth;
	
	      this.parts.forEach(function (cell) {
	        cell.width = w - outerWidth;
	      });
	    }
	  },
	
	  height: {
	    get: function () {
	      return this.system.height;
	    }
	  },
	
	  minHeight: {
	    get: function () {
	      var
	        minHeight = 0,
	        partSep = this.layout.options.partSep;
	
	      this.parts.forEach(function (cell) {
	        minHeight += cell.height + partSep;
	      });
	      return minHeight ? minHeight - partSep : 0;
	    }
	  },
	
	  /**
	   * The x position of the measure in the system.
	   * - (Getter)
	   * - (Setter) Set x cause the measure element to translate.
	   * @type {number}
	   */
	  x: {
	    get: function () {
	      return this._x;
	    },
	    set: function (x) {
	      this._x = x;
	      this.el.transform(Snap.matrix().translate(x, 0));
	    }
	  },
	
	  /**
	   * If the measure in the beginning of the system.
	   * @type {boolean}
	   * @readonly
	   */
	  inSystemBegin: {
	    get: function () {
	      return this._sIndex === 0;
	    }
	  },
	
	  /**
	   * If the measure in the end of the system.
	   * @type {boolean}
	   * @readonly
	   */
	  inSystemEnd: {
	    get: function () {
	      return this._sIndex === this.system.measures.length - 1;
	    }
	  },
	
	  /**
	   * Left bar of the measure in system.
	   * @type {musje.Bar}
	   * @readonly
	   */
	  barLeftInSystem: {
	    get: function () {
	      return this.parts[0].barLeftInSystem;
	    }
	  },
	
	  /**
	   * Right bar of the measure in system.
	   * @type {Bar}
	   * @readonly
	   */
	  barRightInSystem: {
	    get: function () {
	      return this.parts[0].barRightInSystem;
	    }
	  },
	
	  /**
	   * Flow the measure.
	   */
	  flow: function () {
	    var measure = this;
	    measure.parts.forEach(function (cell) {
	
	      /**
	       * Cell SVG group element.
	       * @memberof CellLayout#
	       * @alias el
	       * @type {Snap.Element}
	       * @readonly
	       */
	      cell.el = measure.el.g().addClass('mus-cell');
	
	      cell.x = measure.outerWidthLeft;
	
	      // cell.drawBox();
	    });
	  },
	
	  /**
	   * Draw box of the cell.
	   * @return {Snap.Element} The box SVG rect element.
	   */
	  drawBox: function () {
	    this._boxEl = this.el.rect(0, 0, this.width, this.height)
	                            .attr({ stroke: 'green', fill: 'none' });
	  },
	
	  /**
	   * Clear the box SVG element.
	   */
	  clearBox: function () {
	    this._boxEl.remove();
	    this._boxEl = undefined;
	  }
	};
	
	module.exports = TimewiseMeasureLayoutMixin;


/***/ },
/* 40 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var Snap = __webpack_require__(23);
	var Bar = __webpack_require__(11);
	
	/**
	 * @mixin
	 */
	var CellLayoutMixin = {
	
	  /**
	   * Width
	   * - (Getter) Get the cell width.
	   * - (Setter) Set the cell width, and this will cause the cell to reflow.
	   * @type {number}
	   */
	  width: {
	    get: function () {
	      return this._w;
	    },
	    set: function (w) {
	      this._w = w;
	      reflow(this);
	    }
	  },
	
	  height: {
	    get: function () {
	      return this.layout.options.partHeight;
	    }
	  },
	
	  /**
	   * The x position of the cell in parent timewise measure.
	   * - Set the x value will cause the cell element translate.
	   * @type {number}
	   */
	  x: {
	    get: function () {
	      return this._x;
	    },
	    set: function (x) {
	      this._x = x;
	      this.el.transform(Snap.matrix().translate(x, this.y2));
	    }
	  },
	
	  /**
	   * The y2 position of the cell in parent timewise measure.
	   * - Set the y2 value will cause the cell element translate.
	   * @type {number}
	   */
	  y2: {
	    get: function () {
	      var
	        lo = this.layout.options,
	        p = this._pIndex;
	
	      return p ? (p + 1) * lo.partHeight + p * lo.partSep : lo.partHeight;
	    }
	  },
	
	  /**
	   * The left bar of this cell.
	   * - barLeft at first measure of a system:
	   * ```
	   * |]  -> |
	   * :|  -> |
	   * :|: -> |:
	   * ```
	   * @type {musje.Bar}
	   * @readonly
	   */
	  barLeftInSystem: {
	    get: function () {
	      var bar = this.barLeft;
	      if (!bar) { return { width: 0, height: 0 }; }
	
	      // First measure in the system.
	      if (this.measure.inSystemBegin) {
	        if (bar.value === 'end' || bar.value === 'repeat-end') {
	          bar = new Bar('single');
	        } else if (bar.value === 'repeat-both') {
	          bar = new Bar('repeat-begin');
	        }
	      }
	      bar.def = this.layout.defs.get(bar);
	      return bar;
	    }
	  },
	
	  /**
	   * The right bar of this cell.
	   * - barRight at last measure of a system:
	   * ```
	   *  |: ->  |
	   * :|: -> :|
	   * ```
	   * @type {musje.Bar}
	   * @readonly
	   */
	  barRightInSystem: {
	    get: function () {
	      var
	        bar = this.barRight,
	        system = this.measure.system;
	
	      if (!bar) { return { width: 0, height: 0 }; }
	
	      // Last measure in the system.
	      if (system && this.measure.inSystemEnd) {
	        if (bar.value === 'repeat-begin') {
	          bar = new Bar('single');
	        } else if (bar.value === 'repeat-both') {
	          bar = new Bar('repeat-end');
	        }
	      }
	      bar.def = this.layout.defs.get(bar);
	      return bar;
	    }
	  },
	
	  /**
	   * Flow the cell.
	   */
	  flow: function () {
	    var defs = this.layout.defs;
	    var lo = this.layout.options;
	    var x = 0;
	    var minHeight;
	
	    this.data.forEach(function (data) {
	      var def = data.def = defs.get(data);
	      data.x = x;
	      data.y = 0;
	      x += def.width + lo.musicDataSep;
	      minHeight = Math.min(minHeight, def.height);
	    });
	
	    this.minWidth = x;
	    this.minHeight = minHeight;
	  },
	
	  /**
	   * Draw box of the cell.
	   * @return {Element} The box SVG rect element.
	   */
	  drawBox: function () {
	    this._boxEl = this.el.rect(0, -this.height, this.width, this.height)
	                         .addClass('bbox');
	    return this._boxEl;
	  },
	
	  /**
	   * Clear the box SVG element.
	   */
	  clearBox: function () {
	    this._boxEl.remove();
	    this._boxEl = undefined;
	  }
	};
	
	// Reflow the cell.
	function reflow(that) {
	  that.data.forEach(function (data) {
	    data.x *= that.width / that.minWidth;
	  });
	}
	
	module.exports = CellLayoutMixin;


/***/ },
/* 41 */
/***/ function(module, exports) {

	'use strict';
	
	/**
	 * Layout mixin for the music data
	 * @mixin
	 */
	var MusicDataLayoutMixin = {
	
	  /**
	   * The x position of the music data in the cell.
	   * @type {number}
	   */
	  x: {
	    get: function () {
	      return this._x;
	    },
	    set: function (x) {
	      this._x = x;
	      if (this.el) {
	        this.el.attr('x', x);
	      }
	    }
	  },
	
	  /**
	   * The y position of the music data in the cell.
	   * @type {number}
	   */
	  y: {
	    get: function () {
	      return this._y;
	    },
	    set: function (y) {
	      this._y = y;
	      if (this.el) { this.el.attr('y', y); }
	    }
	  },
	
	  /**
	   * The x position of the music data in the system.
	   * @type {number}
	   */
	  systemX: {
	    get: function () {
	      return this.x + this.cell.x + this.cell.measure.x;
	    }
	  },
	
	  /**
	   * The width of the music data.
	   * @type {number}
	   * @readonly
	   */
	  width: {
	    get: function () {
	      return this.def.width;
	    }
	  }
	};
	
	module.exports = MusicDataLayoutMixin;


/***/ },
/* 42 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var Snap = __webpack_require__(23);
	
	// @param m {number} Measure index in measures.
	// @param len {number} Length of measures.
	function renderBar(measure, lo) {
	  var bar = measure.barRightInSystem;
	  var el;
	
	  if (bar.def) {
	    el = render(bar, measure, lo);
	
	    // Align end in system end.
	    if (measure.inSystemEnd) {
	      translate(el, measure.width - bar.width);
	
	    // Others align middle.
	    } else {
	      translate(el, measure.width - bar.width / 2);
	    }
	  }
	
	  // Render right bar and align begin in system begin.
	  if (measure.inSystemBegin) {
	    bar = measure.barLeftInSystem;
	    if (bar.def) {
	      render(bar, measure, lo);
	    }
	  }
	}
	
	function renderDots(el, x, radius, measureHeight) {
	  var cy = measureHeight / 2;
	  var dy = measureHeight * 0.15;
	
	  el.circle(x, cy - dy, radius);
	  el.circle(x, cy + dy, radius);
	}
	
	function render(bar, measure, lo) {
	  var el = measure.el.g().addClass('mus-barline');
	
	  el.use(bar.def.el).transform(Snap.matrix().scale(1, measure.height));
	
	  switch (bar.value) {
	  case 'repeat-begin':
	    renderDots(el, bar.width - lo.barlineDotRadius, lo.barlineDotRadius, measure.height);
	    break;
	  case 'repeat-end':
	    renderDots(el, lo.barlineDotRadius, lo.barlineDotRadius, measure.height);
	    break;
	  case 'repeat-both':
	    renderDots(el, bar.width - lo.barlineDotRadius, lo.barlineDotRadius, measure.height);
	    renderDots(el, lo.barlineDotRadius, lo.barlineDotRadius, measure.height);
	    break;
	  }
	
	  return el;
	}
	
	function translate(el, x) {
	  el.transform(Snap.matrix().translate(x, 0));
	}
	
	module.exports = renderBar;


/***/ },
/* 43 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var Snap = __webpack_require__(23);
	
	function renderDuration(note, lo) {
	  var durationDef = note.def.durationDef;
	  var pitchDef = note.def.pitchDef;
	  var underbar = note.duration.underbar;
	  var y = 0;
	
	  // Whole and half notes
	  if (note.duration.type < 4) {
	    note.el.use(durationDef.el).attr({
	      x: pitchDef.width,
	      y: pitchDef.stepCy
	    });
	
	  // Quarter or shorter notes
	  } else {
	
	    // Add dots
	    if (note.duration.dot) {
	      note.el.g().transform(Snap.matrix().translate(pitchDef.width, 0))
	        .use(durationDef.el).transform(pitchDef.matrix);
	    }
	
	    // Add underbars for eigth or shorter notes
	    if (underbar) {
	      for (var i = 0; i < underbar; i++) {
	
	        // Only render beam for the begin one.
	        if (note.beams[i]) {
	          if (note.beams[i].value === 'begin') {
	            renderUnderbar(note, note.beams[i].endDurable, y, lo);
	          }
	
	        // Unbeamed underbar
	        } else {
	          renderUnderbar(note, note, y, lo);
	        }
	        y -= lo.underbarSep;
	      }
	    }
	  }
	}
	
	function renderUnderbar(note1, note2, y, lo) {
	  note1.el.line(0, y, note2.x - note1.x + note2.width, y)
	         .attr('stroke-width', lo.typeStrokeWidth);
	}
	
	module.exports = renderDuration;


/***/ },
/* 44 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var Snap = __webpack_require__(23);
	
	function renderCurve(type, note) {
	  var next, prev, prevHasError, nextHasError;
	
	  if (note[type].end) {
	    prev = note[type].prevParent;
	    prevHasError = note[type].prevHasError;
	
	    if (!prev || prev.system !== note.system) {
	      renderEndCurve(note, prevHasError);
	    } else if (prevHasError) {
	      renderCompleteCurve(note, prev, prevHasError);
	    }
	  }
	
	  if (note[type].begin) {
	    next = note[type].nextParent;
	    nextHasError = note[type].nextHasError;
	
	    if (!next || next.system !== note.system) {
	      renderBeginCurve(note, nextHasError);
	    } else {
	      renderCompleteCurve(note, next, nextHasError);
	    }
	  }
	}
	
	function getCurvePath(x1, y1, x2, y2) {
	  var dx = x2 - x1;
	  var dy = y2 - y1;
	  var c1x = 0; //-0.1 * dx;
	  var c1y = 0; //-0.1 * dy;
	  var c2x = dx; //1.1 * dx;
	  var c2y = dy; //1.1 * dy;
	
	  return Snap.format('M{x1},{y1}c{c1x},{c1y} {c2x},{c2y} {dx},{dy}c{c3x},{c3y} {c4x},{c4y} {negDx},{negDy}', {
	    x1: x1,
	    y1: y1,
	    c1x: c1x,
	    c1y: c1y - 8,
	    c2x: c2x,
	    c2y: c2y - 8,
	    dx: dx,
	    dy: dy,
	    c3x: -c1x,
	    c3y: -c1y - 10,
	    c4x: -c2x,
	    c4y: -c2y - 10,
	    negDx: -dx,
	    negDy: -dy
	  });
	}
	
	function renderEndCurve(note, error) {
	  var x1 = note.def.pitchDef.stepCx;
	  var y1 = note.def.pitchDef.stepTop;
	  var x2 = - note.systemX - 3;
	  var el = note.el.path(getCurvePath(x1, y1, x2, y1 - 3));
	
	  if (error) { el.addClass('mus-error'); }
	  return el;
	}
	
	function renderBeginCurve(note, error) {
	  var x1 = note.def.pitchDef.stepCx;
	  var y1 = note.def.pitchDef.stepTop;
	  var x2 = note.system.width - note.systemX + 3;
	  var el = note.el.path(getCurvePath(x1, y1, x2, y1 - 3));
	
	  if (error) { el.addClass('mus-error'); }
	  return el;
	}
	
	function renderCompleteCurve(note1, note2, error) {
	  var x1 = note1.def.pitchDef.stepCx;
	  var y1 = note1.def.pitchDef.stepTop;
	  var x2 = note2.def.pitchDef.stepCx;
	  var y2 = note2.def.pitchDef.stepTop;
	  var noteDx = note2.systemX - note1.systemX;
	  var el = note1.el.path(getCurvePath(x1, y1, noteDx + x2, y2));
	
	  if (error) { el.addClass('mus-error'); }
	  return el;
	}
	
	module.exports = renderCurve;


/***/ },
/* 45 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var MIDI = __webpack_require__(46);
	
	var timeouts = [];
	
	/**
	 * Player mixin.
	 * @mixin
	 */
	var PlayerMixin = {
	
	  /**
	   * Start playing the song.
	   */
	  play: function() {
	    var measures = this.parts[0].measures;
	    var time = 0; //audioCtx.currentTime
	
	    measures.forEach(function (cell) {
	      cell.data.forEach(function (data) {
	        switch (data.$type) {
	        case 'note':
	          // playNote(time, dur, freq);
	          timeouts.push(midiPlayNote(data, time));
	          time += data.duration.second;
	          break;
	        case 'rest':
	          time += data.duration.second;
	          break;
	        }
	      });
	    });
	  },
	
	  /**
	   * Stop playing the song.
	   */
	  stop: function () {
	    timeouts.forEach(function (timeout) {
	      clearTimeout(timeout);
	    });
	    timeouts = [];
	  }
	};
	
	// if (window.AudioContext) {
	//   var audioCtx = new window.AudioContext();
	//   var gainNode = audioCtx.createGain();
	//   gainNode.connect(audioCtx.destination);
	//   gainNode.gain.value = 0.5;  // set the volume
	// }
	
	// // var oscillator = audioCtx.createOscillator();
	// // oscillator.connect(gainNode);
	// // oscillator.type = 'square'; // sine | square | sawtooth | triangle | custom
	
	// function playNote(time, dur, freq) {
	//   if (!audioCtx) { return; }
	
	//   var oscillator = audioCtx.createOscillator();
	//   oscillator.type = 'sine';
	//   oscillator.connect(audioCtx.destination);
	//   oscillator.frequency.value = freq;
	//   oscillator.start(time);
	//   oscillator.stop(time + dur - 0.05);
	// }
	
	function midiPlayNote(note, time) {
	  var midiNumber = note.pitch.midiNumber;
	  var dur = note.duration.second;
	
	  function play() {
	    if (!note.tie.prevParent || note.tie.prevHasError) {
	      MIDI.noteOn(0, midiNumber, 100, 0);
	    }
	    if (!note.tie.nextParent || note.tie.nextHasError) {
	      MIDI.noteOff(0, midiNumber, dur);
	    }
	
	    note.el.addClass('mus-playing');
	
	    setTimeout(function () {
	      note.el.removeClass('mus-playing');
	    }, dur * 800 + 100);
	
	    console.log('Play: ' + note, time, dur, midiNumber);
	  }
	
	  return setTimeout(play, time * 800);
	}
	
	module.exports = PlayerMixin;


/***/ },
/* 46 */
/***/ function(module, exports) {

	module.exports = __WEBPACK_EXTERNAL_MODULE_46__;

/***/ }
/******/ ])
});
;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay91bml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uIiwid2VicGFjazovLy93ZWJwYWNrL2Jvb3RzdHJhcCA0ZmUyZmM2MmU5MTUzMjVmNmUzNSIsIndlYnBhY2s6Ly8vLi9zcmMvbWFpbi5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvcGFyc2VyL3BhcnNlci5qaXNvbiIsIndlYnBhY2s6Ly8vLi9zcmMvdXRpbC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvbW9kZWwvU2NvcmUuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL21vZGVsL1Njb3JlSGVhZC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvbW9kZWwvUGFydHdpc2VQYXJ0cy5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvbW9kZWwvUGFydHdpc2VQYXJ0LmpzIiwid2VicGFjazovLy8uL3NyYy9tb2RlbC9DZWxsLmpzIiwid2VicGFjazovLy8uL3NyYy9tb2RlbC9CZWFtLmpzIiwid2VicGFjazovLy8uL3NyYy9tb2RlbC9UaW1lLmpzIiwid2VicGFjazovLy8uL3NyYy9tb2RlbC9NdXNpY0RhdGFNaXhpbi5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvbW9kZWwvQmFyLmpzIiwid2VicGFjazovLy8uL3NyYy9tb2RlbC9Ob3RlLmpzIiwid2VicGFjazovLy8uL3NyYy9tb2RlbC9QaXRjaC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvbW9kZWwvRHVyYXRpb24uanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL21vZGVsL1RpZS5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvbW9kZWwvU2x1ci5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvbW9kZWwvUmVzdC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvbW9kZWwvQ2hvcmQuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL21vZGVsL1ZvaWNlLmpzIiwid2VicGFjazovLy8uL3NyYy9tb2RlbC9UaW1ld2lzZU1lYXN1cmVzLmpzIiwid2VicGFjazovLy8uL3NyYy9tb2RlbC9UaW1ld2lzZU1lYXN1cmUuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3JlbmRlcmVyL1JlbmRlcmVyL1JlbmRlcmVyLmpzIiwid2VicGFjazovLy9leHRlcm5hbCBcIlNuYXBcIiIsIndlYnBhY2s6Ly8vLi9zcmMvcmVuZGVyZXIvTGF5b3V0L0xheW91dC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvcmVuZGVyZXIvTGF5b3V0L2xheW91dE9wdGlvbnMuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3JlbmRlcmVyL2RlZnMvRGVmcy5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvcmVuZGVyZXIvZGVmcy9BY2NpZGVudGFsRGVmLmpzIiwid2VicGFjazovLy8uL3NyYy9yZW5kZXJlci9zdmdQYXRocy5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvcmVuZGVyZXIvZGVmcy9CYXJEZWYuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3JlbmRlcmVyL2RlZnMvRHVyYXRpb25EZWYuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3JlbmRlcmVyL2RlZnMvUGl0Y2hEZWYuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3JlbmRlcmVyL2RlZnMvVGltZURlZi5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvcmVuZGVyZXIvZGVmcy9kZWZJZE1peGlucy5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvcmVuZGVyZXIvTGF5b3V0L1N2Z0xheW91dC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvcmVuZGVyZXIvTGF5b3V0L0JvZHlMYXlvdXQuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3JlbmRlcmVyL0xheW91dC9IZWFkZXJMYXlvdXQuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3JlbmRlcmVyL0xheW91dC9Db250ZW50TGF5b3V0LmpzIiwid2VicGFjazovLy8uL3NyYy9yZW5kZXJlci9MYXlvdXQvU3lzdGVtTGF5b3V0LmpzIiwid2VicGFjazovLy8uL3NyYy9yZW5kZXJlci9MYXlvdXQvVGltZXdpc2VNZWFzdXJlTGF5b3V0TWl4aW4uanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3JlbmRlcmVyL0xheW91dC9DZWxsTGF5b3V0TWl4aW4uanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3JlbmRlcmVyL0xheW91dC9NdXNpY0RhdGFMYXlvdXRNaXhpbi5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvcmVuZGVyZXIvUmVuZGVyZXIvcmVuZGVyQmFyLmpzIiwid2VicGFjazovLy8uL3NyYy9yZW5kZXJlci9SZW5kZXJlci9yZW5kZXJEdXJhdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvcmVuZGVyZXIvUmVuZGVyZXIvcmVuZGVyQ3VydmUuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3BsYXllci9QbGF5ZXJNaXhpbi5qcyIsIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJNSURJXCIiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELE87QUNWQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx1QkFBZTtBQUNmO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOzs7Ozs7O0FDdENBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLE9BQU87QUFDbEIsWUFBVyxPQUFPO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFhLE9BQU87QUFDcEIsZUFBYyxNQUFNO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0EsWUFBVztBQUNYO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVc7QUFDWDtBQUNBO0FBQ0E7Ozs7Ozs7QUM5Q0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVU7QUFDVjtBQUNBLGdCQUFlLGtDQUFrQztBQUNqRCxrQkFBaUIs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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7O0FBRWI7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBeUI7QUFDekI7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBdUIsa0JBQWtCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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O0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsbUNBQWtDLFFBQVE7O0FBRTFDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7O0FBRUQ7Ozs7Ozs7QUNoSEE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0EsWUFBVyxPQUFPO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBd0IsZUFBZTtBQUN2QyxlQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7OztBQUdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQVksVUFBVTtBQUN0QixJQUFHO0FBQ0g7QUFDQTs7QUFFQTs7Ozs7OztBQ2hHQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsT0FBTztBQUNsQixZQUFXLE9BQU87QUFDbEIsWUFBVyxPQUFPO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBQ3hDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHVCQUFzQixnREFBZ0Q7QUFDdEUsdUJBQXNCO0FBQ3RCOztBQUVBOzs7Ozs7O0FDcEJBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsT0FBTztBQUNsQixZQUFXLElBQUk7QUFDZixZQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDekVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsT0FBTztBQUNsQixZQUFXLFNBQVM7QUFDcEIsWUFBVyxPQUFPO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDaEdBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWMsT0FBTztBQUNyQixrQkFBaUIsTUFBTTtBQUN2QixtQkFBa0IsT0FBTztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBZ0IsUUFBUTs7QUFFeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0JBQWUsWUFBWTtBQUMzQjtBQUNBO0FBQ0EsSUFBRztBQUNILGdCQUFlLFlBQVk7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQzlIQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLE9BQU87QUFDbEIsWUFBVyxLQUFLO0FBQ2hCLFlBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQSxnQ0FBK0I7QUFDL0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDdENBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQy9KQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsNEJBQTRCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0EsYUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWlCLGdCQUFnQjtBQUNqQztBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBLGFBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7QUFFRDs7Ozs7OztBQzNEQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSwyQkFBMEIseUJBQXlCO0FBQ25ELDRCQUEyQiwwQkFBMEI7QUFDckQ7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7O0FBRUQ7Ozs7Ozs7QUNsRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBVyxPQUFPO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBLGFBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDOztBQUVEOzs7Ozs7O0FDL0NBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBVyxPQUFPO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQSwyQkFBMEIsdUJBQXVCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTRDLGVBQWUsRUFBRTtBQUM3RDtBQUNBLEVBQUM7O0FBRUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHlCQUF3Qix1QkFBdUI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQSxtQ0FBa0MsUUFBUTtBQUMxQztBQUNBLGdEQUErQyxlQUFlO0FBQzlEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrREFBOEQ7QUFDOUQ7O0FBRUE7QUFDQSwrQkFBOEIsUUFBUTs7QUFFdEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxtQkFBa0IsT0FBTztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDakpBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVcsT0FBTztBQUNsQixZQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0EsYUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBLGFBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0EsYUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDOztBQUVEO0FBQ0EsMEJBQXlCLFFBQVE7O0FBRWpDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBWTtBQUNaOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxnQ0FBK0IsMEJBQTBCOztBQUV6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7O0FBRUE7Ozs7Ozs7QUNyS0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBLGFBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBLGFBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQSxhQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0EsYUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBLGFBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxNQUFLO0FBQ0wsSUFBRzs7QUFFSDtBQUNBO0FBQ0EsZUFBYyxhQUFhO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLG9DQUFtQyxnQ0FBZ0M7QUFDbkUsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDek5BOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxhQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLGFBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWlCLFNBQVMsdUJBQXVCOztBQUVqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtCQUFpQixTQUFTLHVCQUF1Qjs7QUFFakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBLGVBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIOztBQUVBOzs7Ozs7O0FDektBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQSxhQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBLHFCQUFvQixzQkFBc0I7QUFDMUM7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQSxhQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBLGFBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDNURBOztBQUVBOztBQUVBLGNBQWEsT0FBTztBQUNwQixnQkFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDakVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHNCQUFxQixjQUFjOztBQUVuQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDbkRBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWM7QUFDZCxlQUFjO0FBQ2QsZ0JBQWU7QUFDZixnQkFBZTs7QUFFZix5QkFBd0IsR0FBRyxFQUFFLEdBQUcsRUFBRSxJQUFJLEVBQUUsSUFBSSxFQUFFLElBQUksRUFBRSxJQUFJLEVBQUUsR0FBRyxFQUFFLEdBQUcsRUFBRSxJQUFJLEVBQUUsSUFBSSxFQUFFLElBQUksRUFBRSxJQUFJLEVBQUUsTUFBTSxFQUFFLE1BQU07QUFDMUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGVBQWMsMEJBQTBCO0FBQ3hDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxlQUFjLDBCQUEwQjtBQUN4QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGVBQWMsMEJBQTBCO0FBQ3hDO0FBQ0E7O0FBRUE7Ozs7Ozs7QUN4RkE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWlCOztBQUVqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1AsTUFBSztBQUNMLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUErQjtBQUMvQjs7QUFFQTtBQUNBO0FBQ0Esa0NBQWlDOztBQUVqQztBQUNBLHNCQUFxQixRQUFROztBQUU3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FDNUZBLGlEIiwiZmlsZSI6Ii4vbGliL211c2plLmpzIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIHdlYnBhY2tVbml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uKHJvb3QsIGZhY3RvcnkpIHtcblx0aWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnKVxuXHRcdG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeShyZXF1aXJlKFwiU25hcFwiKSwgcmVxdWlyZShcIk1JRElcIikpO1xuXHRlbHNlIGlmKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZClcblx0XHRkZWZpbmUoW1wiU25hcFwiLCBcIk1JRElcIl0sIGZhY3RvcnkpO1xuXHRlbHNlIGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jylcblx0XHRleHBvcnRzW1wibXVzamVcIl0gPSBmYWN0b3J5KHJlcXVpcmUoXCJTbmFwXCIpLCByZXF1aXJlKFwiTUlESVwiKSk7XG5cdGVsc2Vcblx0XHRyb290W1wibXVzamVcIl0gPSBmYWN0b3J5KHJvb3RbXCJTbmFwXCJdLCByb290W1wiTUlESVwiXSk7XG59KSh0aGlzLCBmdW5jdGlvbihfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFXzIzX18sIF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfNDZfXykge1xucmV0dXJuIFxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIHdlYnBhY2svdW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvblxuICoqLyIsIiBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbiBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG5cbiBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cbiBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKVxuIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuXG4gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbiBcdFx0XHRleHBvcnRzOiB7fSxcbiBcdFx0XHRpZDogbW9kdWxlSWQsXG4gXHRcdFx0bG9hZGVkOiBmYWxzZVxuIFx0XHR9O1xuXG4gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4gXHRcdG1vZHVsZS5sb2FkZWQgPSB0cnVlO1xuXG4gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbiBcdH1cblxuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbiBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG5cbiBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIlwiO1xuXG4gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbiBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogd2VicGFjay9ib290c3RyYXAgNGZlMmZjNjJlOTE1MzI1ZjZlMzVcbiAqKi8iLCIndXNlIHN0cmljdCc7XHJcblxyXG52YXIgcGFyc2VyID0gcmVxdWlyZSgnLi9wYXJzZXIvcGFyc2VyLmppc29uJyk7XHJcbnZhciBTY29yZSA9IHJlcXVpcmUoJy4vbW9kZWwvU2NvcmUnKTtcclxudmFyIFJlbmRlcmVyID0gcmVxdWlyZSgnLi9yZW5kZXJlci9SZW5kZXJlci9SZW5kZXJlcicpO1xyXG52YXIgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpO1xyXG52YXIgUGxheWVyTWl4aW4gPSByZXF1aXJlKCcuL3BsYXllci9QbGF5ZXJNaXhpbicpO1xyXG5cclxuLyoqXHJcbiAqIFJlbmRlciB0aGUgc2NvcmUgaW4gamlhbnB1IChudW1iZXJlZCBtdXNpY2FsIG5vdGF0aW9uKS5cclxuICogQG1lbWJlclxyXG4gKiBAZnVuY3Rpb25cclxuICogQHBhcmFtIHtzdHJpbmd9IHN2Z1xyXG4gKiBAcGFyYW0ge09iamVjdH0gbG8gLSBMYXlvdXQgb3B0aW9ucy5cclxuICovXHJcblNjb3JlLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoc3ZnLCBsbykge1xyXG4gIG5ldyBSZW5kZXJlcihzdmcsIGxvKS5yZW5kZXIodGhpcyk7XHJcbn07XHJcblxyXG51dGlsLmRlZmluZVByb3BlcnRpZXMoU2NvcmUucHJvdG90eXBlLCBQbGF5ZXJNaXhpbik7XHJcblxyXG5cclxuLyoqIEBtb2R1bGUgbXVzamUgKi9cclxubW9kdWxlLmV4cG9ydHMgPSB7XHJcblxyXG4gIC8qKlxyXG4gICAqIFBhcnNlIHNvdXJjZSBtdXNqZSBzdHJpbmcgdG8gYmUgYSBTY29yZSBpbnN0YW5jZS5cclxuICAgKiBAcGFyYW0ge3N0cmluZ30gaW5wdXQgLSBJbnB1dCBvZiB0aGUgbXVzamUgc291cmNlIGNvZGUuXHJcbiAgICogQHJldHVybiB7U2NvcmV9IC0gQSBgU2NvcmVgIGluc3RhbmNlLlxyXG4gICAqL1xyXG4gIHBhcnNlOiBmdW5jdGlvbiAoaW5wdXQpIHtcclxuICAgIHZhciBwbGFpblNjb3JlID0gcGFyc2VyLnBhcnNlKGlucHV0KTtcclxuICAgIHJldHVybiBuZXcgU2NvcmUocGxhaW5TY29yZSk7XHJcbiAgfSxcclxuXHJcbiAgLyoqXHJcbiAgICogU2NvcmUgY29uc3RydWN0b3IuXHJcbiAgICogQHNlZSB7QGxpbmsgU2NvcmV9XHJcbiAgICovXHJcbiAgU2NvcmU6IFNjb3JlLFxyXG5cclxuICAvKipcclxuICAgKiBVdGlsaXR5IGZ1bmN0aW9ucy5cclxuICAgKiBAc2VlIHtAbGluayB1dGlsfVxyXG4gICAqL1xyXG4gIHV0aWw6IHV0aWxcclxufTtcclxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NyYy9tYWluLmpzXG4gKiogbW9kdWxlIGlkID0gMFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyogcGFyc2VyIGdlbmVyYXRlZCBieSBqaXNvbiAwLjQuMTcgKi9cbi8qXG4gIFJldHVybnMgYSBQYXJzZXIgb2JqZWN0IG9mIHRoZSBmb2xsb3dpbmcgc3RydWN0dXJlOlxuXG4gIFBhcnNlcjoge1xuICAgIHl5OiB7fVxuICB9XG5cbiAgUGFyc2VyLnByb3RvdHlwZToge1xuICAgIHl5OiB7fSxcbiAgICB0cmFjZTogZnVuY3Rpb24oKSxcbiAgICBzeW1ib2xzXzoge2Fzc29jaWF0aXZlIGxpc3Q6IG5hbWUgPT0+IG51bWJlcn0sXG4gICAgdGVybWluYWxzXzoge2Fzc29jaWF0aXZlIGxpc3Q6IG51bWJlciA9PT4gbmFtZX0sXG4gICAgcHJvZHVjdGlvbnNfOiBbLi4uXSxcbiAgICBwZXJmb3JtQWN0aW9uOiBmdW5jdGlvbiBhbm9ueW1vdXMoeXl0ZXh0LCB5eWxlbmcsIHl5bGluZW5vLCB5eSwgeXlzdGF0ZSwgJCQsIF8kKSxcbiAgICB0YWJsZTogWy4uLl0sXG4gICAgZGVmYXVsdEFjdGlvbnM6IHsuLi59LFxuICAgIHBhcnNlRXJyb3I6IGZ1bmN0aW9uKHN0ciwgaGFzaCksXG4gICAgcGFyc2U6IGZ1bmN0aW9uKGlucHV0KSxcblxuICAgIGxleGVyOiB7XG4gICAgICAgIEVPRjogMSxcbiAgICAgICAgcGFyc2VFcnJvcjogZnVuY3Rpb24oc3RyLCBoYXNoKSxcbiAgICAgICAgc2V0SW5wdXQ6IGZ1bmN0aW9uKGlucHV0KSxcbiAgICAgICAgaW5wdXQ6IGZ1bmN0aW9uKCksXG4gICAgICAgIHVucHV0OiBmdW5jdGlvbihzdHIpLFxuICAgICAgICBtb3JlOiBmdW5jdGlvbigpLFxuICAgICAgICBsZXNzOiBmdW5jdGlvbihuKSxcbiAgICAgICAgcGFzdElucHV0OiBmdW5jdGlvbigpLFxuICAgICAgICB1cGNvbWluZ0lucHV0OiBmdW5jdGlvbigpLFxuICAgICAgICBzaG93UG9zaXRpb246IGZ1bmN0aW9uKCksXG4gICAgICAgIHRlc3RfbWF0Y2g6IGZ1bmN0aW9uKHJlZ2V4X21hdGNoX2FycmF5LCBydWxlX2luZGV4KSxcbiAgICAgICAgbmV4dDogZnVuY3Rpb24oKSxcbiAgICAgICAgbGV4OiBmdW5jdGlvbigpLFxuICAgICAgICBiZWdpbjogZnVuY3Rpb24oY29uZGl0aW9uKSxcbiAgICAgICAgcG9wU3RhdGU6IGZ1bmN0aW9uKCksXG4gICAgICAgIF9jdXJyZW50UnVsZXM6IGZ1bmN0aW9uKCksXG4gICAgICAgIHRvcFN0YXRlOiBmdW5jdGlvbigpLFxuICAgICAgICBwdXNoU3RhdGU6IGZ1bmN0aW9uKGNvbmRpdGlvbiksXG5cbiAgICAgICAgb3B0aW9uczoge1xuICAgICAgICAgICAgcmFuZ2VzOiBib29sZWFuICAgICAgICAgICAob3B0aW9uYWw6IHRydWUgPT0+IHRva2VuIGxvY2F0aW9uIGluZm8gd2lsbCBpbmNsdWRlIGEgLnJhbmdlW10gbWVtYmVyKVxuICAgICAgICAgICAgZmxleDogYm9vbGVhbiAgICAgICAgICAgICAob3B0aW9uYWw6IHRydWUgPT0+IGZsZXgtbGlrZSBsZXhpbmcgYmVoYXZpb3VyIHdoZXJlIHRoZSBydWxlcyBhcmUgdGVzdGVkIGV4aGF1c3RpdmVseSB0byBmaW5kIHRoZSBsb25nZXN0IG1hdGNoKVxuICAgICAgICAgICAgYmFja3RyYWNrX2xleGVyOiBib29sZWFuICAob3B0aW9uYWw6IHRydWUgPT0+IGxleGVyIHJlZ2V4ZXMgYXJlIHRlc3RlZCBpbiBvcmRlciBhbmQgZm9yIGVhY2ggbWF0Y2hpbmcgcmVnZXggdGhlIGFjdGlvbiBjb2RlIGlzIGludm9rZWQ7IHRoZSBsZXhlciB0ZXJtaW5hdGVzIHRoZSBzY2FuIHdoZW4gYSB0b2tlbiBpcyByZXR1cm5lZCBieSB0aGUgYWN0aW9uIGNvZGUpXG4gICAgICAgIH0sXG5cbiAgICAgICAgcGVyZm9ybUFjdGlvbjogZnVuY3Rpb24oeXksIHl5XywgJGF2b2lkaW5nX25hbWVfY29sbGlzaW9ucywgWVlfU1RBUlQpLFxuICAgICAgICBydWxlczogWy4uLl0sXG4gICAgICAgIGNvbmRpdGlvbnM6IHthc3NvY2lhdGl2ZSBsaXN0OiBuYW1lID09PiBzZXR9LFxuICAgIH1cbiAgfVxuXG5cbiAgdG9rZW4gbG9jYXRpb24gaW5mbyAoQCQsIF8kLCBldGMuKToge1xuICAgIGZpcnN0X2xpbmU6IG4sXG4gICAgbGFzdF9saW5lOiBuLFxuICAgIGZpcnN0X2NvbHVtbjogbixcbiAgICBsYXN0X2NvbHVtbjogbixcbiAgICByYW5nZTogW3N0YXJ0X251bWJlciwgZW5kX251bWJlcl0gICAgICAgKHdoZXJlIHRoZSBudW1iZXJzIGFyZSBpbmRleGVzIGludG8gdGhlIGlucHV0IHN0cmluZywgcmVndWxhciB6ZXJvLWJhc2VkKVxuICB9XG5cblxuICB0aGUgcGFyc2VFcnJvciBmdW5jdGlvbiByZWNlaXZlcyBhICdoYXNoJyBvYmplY3Qgd2l0aCB0aGVzZSBtZW1iZXJzIGZvciBsZXhlciBhbmQgcGFyc2VyIGVycm9yczoge1xuICAgIHRleHQ6ICAgICAgICAobWF0Y2hlZCB0ZXh0KVxuICAgIHRva2VuOiAgICAgICAodGhlIHByb2R1Y2VkIHRlcm1pbmFsIHRva2VuLCBpZiBhbnkpXG4gICAgbGluZTogICAgICAgICh5eWxpbmVubylcbiAgfVxuICB3aGlsZSBwYXJzZXIgKGdyYW1tYXIpIGVycm9ycyB3aWxsIGFsc28gcHJvdmlkZSB0aGVzZSBtZW1iZXJzLCBpLmUuIHBhcnNlciBlcnJvcnMgZGVsaXZlciBhIHN1cGVyc2V0IG9mIGF0dHJpYnV0ZXM6IHtcbiAgICBsb2M6ICAgICAgICAgKHl5bGxvYylcbiAgICBleHBlY3RlZDogICAgKHN0cmluZyBkZXNjcmliaW5nIHRoZSBzZXQgb2YgZXhwZWN0ZWQgdG9rZW5zKVxuICAgIHJlY292ZXJhYmxlOiAoYm9vbGVhbjogVFJVRSB3aGVuIHRoZSBwYXJzZXIgaGFzIGEgZXJyb3IgcmVjb3ZlcnkgcnVsZSBhdmFpbGFibGUgZm9yIHRoaXMgcGFydGljdWxhciBlcnJvcilcbiAgfVxuKi9cbnZhciBwYXJzZXIgPSAoZnVuY3Rpb24oKXtcbnZhciBvPWZ1bmN0aW9uKGssdixvLGwpe2ZvcihvPW98fHt9LGw9ay5sZW5ndGg7bC0tO29ba1tsXV09dik7cmV0dXJuIG99LCRWMD1bMSwxMV0sJFYxPVsxLDE1XSwkVjI9WzEsMTZdLCRWMz1bMSwxN10sJFY0PVsxLDE4XSwkVjU9WzEsMTldLCRWNj1bMSwyMF0sJFY3PVsxLDIzXSwkVjg9WzEsMjddLCRWOT1bMSwzNF0sJFZhPVsxLDM1XSwkVmI9WzEsMzNdLCRWYz1bMSwyOF0sJFZkPVsxLDI5XSwkVmU9WzUsOSwxMCwxNCwyMSwyMiwyMywyNCwyNSwyNiwyOSwzNCwzOSw0MSw0OCw1MSw1OF0sJFZmPVsyLDhdLCRWZz1bNSw5LDEwLDIxLDIyLDIzLDI0LDI1LDI2LDI5LDM0LDM5LDQxLDQ4LDUxLDU4XSwkVmg9WzUsMjEsMjIsMjMsMjQsMjUsMjZdLCRWaT1bMiw0N10sJFZqPVsxLDQ4XSwkVms9WzEsNDldLCRWbD1bMSw1MF0sJFZtPVsxLDUxXSwkVm49WzEsNTJdLCRWbz1bNSw5LDEwLDIxLDIyLDIzLDI0LDI1LDI2LDI4LDI5LDM0LDM1LDM5LDQxLDQ4LDUxLDUzLDU4XSwkVnA9WzUsOSwxMCwyMSwyMiwyMywyNCwyNSwyNiwyOCwyOSwzNCwzNSwzOSw0MSw0Myw0NCw0NSw0Niw0Nyw0OCw1MSw1Myw1OF0sJFZxPVs1LDksMTAsMjEsMjIsMjMsMjQsMjUsMjYsMjgsMjksMzQsMzUsMzksNDEsNDMsNDQsNDUsNDYsNDcsNDgsNTAsNTEsNTMsNThdLCRWcj1bMSw2M10sJFZzPVsxLDY0XSwkVnQ9WzUsMjEsMjIsMjMsMjQsMjUsMjYsMjksMzQsMzksNDEsNDgsNTEsNThdLCRWdT1bNSw5LDEwLDIxLDIyLDIzLDI0LDI1LDI2LDI4LDI5LDM0LDM1LDM5LDQxLDQzLDQ4LDUxLDUzLDU4XSwkVnY9WzUsOSwxMCwyMSwyMiwyMywyNCwyNSwyNiwyOCwyOSwzNCwzOSw0MSw0OCw1MSw1Myw1OF0sJFZ3PVszOSw0MSw1MF07XG52YXIgcGFyc2VyID0ge3RyYWNlOiBmdW5jdGlvbiB0cmFjZSgpIHsgfSxcbnl5OiB7fSxcbnN5bWJvbHNfOiB7XCIwXCI6MjksXCJlcnJvclwiOjIsXCJlXCI6MyxcIm1heWJlX211c2plXCI6NCxcIkVPRlwiOjUsXCJzcGFjZVwiOjYsXCJtYXliZV9zcGFjZVwiOjcsXCJtdXNqZVwiOjgsXCJTXCI6OSxcIk5MXCI6MTAsXCJzY29yZV9oZWFkXCI6MTEsXCJwYXJ0X2xpc3RcIjoxMixcInRpdGxlXCI6MTMsXCJUSVRMRVwiOjE0LFwiQ09NUE9TRVJcIjoxNSxcInBhcnRcIjoxNixcIm1lYXN1cmVfbGlzdFwiOjE3LFwiYmFyXCI6MTgsXCJtZWFzdXJlXCI6MTksXCJtdXNpY19kYXRhXCI6MjAsXCJ8XCI6MjEsXCJ8fFwiOjIyLFwifF1cIjoyMyxcInw6XCI6MjQsXCI6fFwiOjI1LFwiOnw6XCI6MjYsXCJzbHVyYWJsZVwiOjI3LFwiVElFXCI6MjgsXCJtYXliZV9kdXJhdGlvblwiOjMwLFwidm9pY2VcIjozMSxcInRpbWVfc2lnbmF0dXJlXCI6MzIsXCJwaXRjaGZ1bFwiOjMzLFwiKFwiOjM0LFwiKVwiOjM1LFwibm90ZVwiOjM2LFwiY2hvcmRcIjozNyxcInBpdGNoXCI6MzgsXCJTVEVQXCI6MzksXCJPQ1RBVkVcIjo0MCxcIkFDQ0lERU5UQUxcIjo0MSxcInR5cGVfbW9kaWZpZXJcIjo0MixcIkRPVFwiOjQzLFwiX1wiOjQ0LFwiPVwiOjQ1LFwiSEFMRlwiOjQ2LFwiV0hPTEVcIjo0NyxcIjxcIjo0OCxcInBpdGNoX2xpc3RcIjo0OSxcIj5cIjo1MCxcIntcIjo1MSxcInZvaWNlX2xpc3RcIjo1MixcIn1cIjo1MyxcInZvaWNlX2RhdGFfbGlzdFwiOjU0LFwiOlwiOjU1LFwidm9pY2VfZGF0YVwiOjU2LFwicmVzdHNsdXJhYmxlX2xpc3RcIjo1NyxcIkJFQVRTXCI6NTgsXCJCRUFUX1RZUEVcIjo1OSxcIiRhY2NlcHRcIjowLFwiJGVuZFwiOjF9LFxudGVybWluYWxzXzogezI6XCJlcnJvclwiLDU6XCJFT0ZcIiw5OlwiU1wiLDEwOlwiTkxcIiwxNDpcIlRJVExFXCIsMTU6XCJDT01QT1NFUlwiLDIxOlwifFwiLDIyOlwifHxcIiwyMzpcInxdXCIsMjQ6XCJ8OlwiLDI1OlwiOnxcIiwyNjpcIjp8OlwiLDI4OlwiVElFXCIsMjk6XCIwXCIsMzQ6XCIoXCIsMzU6XCIpXCIsMzk6XCJTVEVQXCIsNDA6XCJPQ1RBVkVcIiw0MTpcIkFDQ0lERU5UQUxcIiw0MzpcIkRPVFwiLDQ0OlwiX1wiLDQ1OlwiPVwiLDQ2OlwiSEFMRlwiLDQ3OlwiV0hPTEVcIiw0ODpcIjxcIiw1MDpcIj5cIiw1MTpcIntcIiw1MzpcIn1cIiw1NDpcInZvaWNlX2RhdGFfbGlzdFwiLDU1OlwiOlwiLDU3OlwicmVzdHNsdXJhYmxlX2xpc3RcIiw1ODpcIkJFQVRTXCIsNTk6XCJCRUFUX1RZUEVcIn0sXG5wcm9kdWN0aW9uc186IFswLFszLDJdLFs0LDBdLFs0LDJdLFs0LDNdLFs0LDFdLFs2LDFdLFs2LDFdLFs3LDBdLFs3LDJdLFs3LDJdLFs4LDFdLFs4LDFdLFs4LDJdLFsxMSwyXSxbMTMsMV0sWzEzLDJdLFsxMiwxXSxbMTYsMV0sWzE2LDNdLFsxNywxXSxbMTcsNF0sWzE3LDNdLFsxOSwyXSxbMTksM10sWzE4LDFdLFsxOCwxXSxbMTgsMV0sWzE4LDFdLFsxOCwxXSxbMTgsMV0sWzIwLDFdLFsyMCwyXSxbMjAsMl0sWzIwLDFdLFsyMCwxXSxbMjcsMl0sWzI3LDNdLFsyNywzXSxbMjcsNF0sWzMzLDFdLFszMywxXSxbMzYsMV0sWzM4LDFdLFszOCwyXSxbMzgsMl0sWzM4LDNdLFszMCwwXSxbMzAsMV0sWzMwLDFdLFszMCwyXSxbNDIsMV0sWzQyLDFdLFs0MiwyXSxbNDIsMl0sWzQyLDNdLFs0MiwzXSxbNDIsMV0sWzQyLDFdLFszNywzXSxbNDksMV0sWzQ5LDJdLFszMSwzXSxbNTIsMV0sWzUyLDNdLFs1NiwxXSxbNTYsMl0sWzMyLDJdXSxcbnBlcmZvcm1BY3Rpb246IGZ1bmN0aW9uIGFub255bW91cyh5eXRleHQsIHl5bGVuZywgeXlsaW5lbm8sIHl5LCB5eXN0YXRlIC8qIGFjdGlvblsxXSAqLywgJCQgLyogdnN0YWNrICovLCBfJCAvKiBsc3RhY2sgKi8pIHtcbi8qIHRoaXMgPT0geXl2YWwgKi9cblxudmFyICQwID0gJCQubGVuZ3RoIC0gMTtcbnN3aXRjaCAoeXlzdGF0ZSkge1xuY2FzZSAxOlxuIHJldHVybiAkJFskMC0xXTsgXG5icmVhaztcbmNhc2UgMjogY2FzZSAzOlxuIHRoaXMuJCA9IG51bGw7IFxuYnJlYWs7XG5jYXNlIDQ6IGNhc2UgNTpcbiB0aGlzLiQgPSAkJFskMF07IHJlbW92ZUxhc3RFbXB0eU1lYXN1cmUoJCRbJDBdKTsgXG5icmVhaztcbmNhc2UgMTA6XG4gdGhpcy4kID0gJCRbJDAtMV0gPyAkJFskMC0xXSArIDEgOiAxOyBcbmJyZWFrO1xuY2FzZSAxMTpcbnRoaXMuJCA9IHsgaGVhZDogJCRbJDBdIH07XG5icmVhaztcbmNhc2UgMTI6XG50aGlzLiQgPSB7IHBhcnRzOiAkJFskMF0gfTtcbmJyZWFrO1xuY2FzZSAxMzpcbnRoaXMuJCA9IHsgaGVhZDogJCRbJDAtMV0sIHBhcnRzOiAkJFskMF0gfTtcbmJyZWFrO1xuY2FzZSAxNTpcbiB0aGlzLiQgPSB7IHRpdGxlOiAkJFskMF0gfTsgXG5icmVhaztcbmNhc2UgMTY6XG4gdGhpcy4kID0gIHsgdGl0bGU6ICQkWyQwLTFdLCBjb21wb3NlcjogJCRbJDBdIH07IFxuYnJlYWs7XG5jYXNlIDE3OiBjYXNlIDYwOiBjYXNlIDYzOlxudGhpcy4kID0gWyQkWyQwXV07XG5icmVhaztcbmNhc2UgMTg6XG50aGlzLiQgPSB7IG1lYXN1cmVzOiAkJFskMF0gfTtcbmJyZWFrO1xuY2FzZSAxOTpcbiB0aGlzLiQgPSB7IG1lYXN1cmVzOiAkJFskMF19OyAkJFskMF1bMF0uZGF0YS51bnNoaWZ0KHsgYmFyOiAkJFskMC0yXSB9KTsgXG5icmVhaztcbmNhc2UgMjA6XG4gdGhpcy4kID0gWyQkWyQwXV07IFxuYnJlYWs7XG5jYXNlIDIxOlxuIHRoaXMuJCA9ICQkWyQwLTNdOyBsYXN0SXRlbSgkJFskMC0zXSkuZGF0YS5wdXNoKHsgYmFyOiAkJFskMC0yXSB9KTsgJCRbJDAtM10ucHVzaCgkJFskMF0pOyBcbmJyZWFrO1xuY2FzZSAyMjpcbiB0aGlzLiQgPSAkJFskMC0yXTsgbGFzdEl0ZW0oJCRbJDAtMl0pLmRhdGEucHVzaCh7IGJhcjogJCRbJDAtMV0gfSk7ICQkWyQwLTJdLnB1c2goeyBkYXRhOiBbXSB9KTsgXG5icmVhaztcbmNhc2UgMjM6XG50aGlzLiQgPSB7IGRhdGE6IFskJFskMC0xXV0gfTtcbmJyZWFrO1xuY2FzZSAyNDpcbiB0aGlzLiQgPSAkJFskMC0yXTsgJCRbJDAtMl0uZGF0YS5wdXNoKCQkWyQwLTFdKTsgXG5icmVhaztcbmNhc2UgMjU6XG50aGlzLiQgPSAnc2luZ2xlJztcbmJyZWFrO1xuY2FzZSAyNjpcbnRoaXMuJCA9ICdkb3VibGUnO1xuYnJlYWs7XG5jYXNlIDI3OlxudGhpcy4kID0gJ2VuZCc7XG5icmVhaztcbmNhc2UgMjg6XG50aGlzLiQgPSAncmVwZWF0LWJlZ2luJztcbmJyZWFrO1xuY2FzZSAyOTpcbnRoaXMuJCA9ICdyZXBlYXQtZW5kJztcbmJyZWFrO1xuY2FzZSAzMDpcbnRoaXMuJCA9ICdyZXBlYXQtYm90aCc7XG5icmVhaztcbmNhc2UgMzI6XG4gdGhpcy4kID0gJCRbJDAtMV07IG9ubHlQcm9wZXJ0eSgkJFskMC0xXSkudGllID0gJ34nOyBcbmJyZWFrO1xuY2FzZSAzMzpcbnRoaXMuJCA9IHsgcmVzdDogeyBkdXJhdGlvbjogJCRbJDBdIH0gfTtcbmJyZWFrO1xuY2FzZSAzNDpcbnRoaXMuJCA9IHsgdm9pY2U6ICQkWyQwXSB9O1xuYnJlYWs7XG5jYXNlIDM2OlxuIHRoaXMuJCA9ICQkWyQwLTFdOyBvbmx5UHJvcGVydHkoJCRbJDAtMV0pLmR1cmF0aW9uID0gJCRbJDBdOyBcbmJyZWFrO1xuY2FzZSAzNzpcblxuICAgICAgdGhpcy4kID0gJCRbJDAtMV07XG4gICAgICBleHRlbmQob25seVByb3BlcnR5KCQkWyQwLTFdKSwge1xuICAgICAgICBkdXJhdGlvbjogJCRbJDBdLFxuICAgICAgICBzbHVyOiB7IGJlZ2luOiAnc29saWQnIH1cbiAgICAgIH0pO1xuICAgIFxuYnJlYWs7XG5jYXNlIDM4OlxuXG4gICAgICB0aGlzLiQgPSAkJFskMC0yXTtcbiAgICAgIGV4dGVuZChvbmx5UHJvcGVydHkoJCRbJDAtMl0pLCB7XG4gICAgICAgIGR1cmF0aW9uOiAkJFskMC0xXSxcbiAgICAgICAgc2x1cjogeyBlbmQ6ICdzb2xpZCcgfVxuICAgICAgfSk7XG4gICAgXG5icmVhaztcbmNhc2UgMzk6XG5cbiAgICAgIHRoaXMuJCA9ICQkWyQwLTJdO1xuICAgICAgZXh0ZW5kKG9ubHlQcm9wZXJ0eSgkJFskMC0yXSksIHtcbiAgICAgICAgZHVyYXRpb246ICQkWyQwLTFdLFxuICAgICAgICBzbHVyOiB7IGJlZ2luOiAnc29saWQnLCBlbmQ6ICdzb2xpZCcgfVxuICAgICAgfSk7XG4gICAgXG5icmVhaztcbmNhc2UgNDA6XG50aGlzLiQgPSB7IG5vdGU6ICQkWyQwXSB9O1xuYnJlYWs7XG5jYXNlIDQxOlxudGhpcy4kID0geyBjaG9yZDogJCRbJDBdIH07XG5icmVhaztcbmNhc2UgNDI6XG50aGlzLiQgPSB7IHBpdGNoOiAkJFskMF0gfTtcbmJyZWFrO1xuY2FzZSA0MzpcbnRoaXMuJCA9IHsgc3RlcDogKyQkWyQwXSB9O1xuYnJlYWs7XG5jYXNlIDQ0OlxudGhpcy4kID0geyBzdGVwOiArJCRbJDAtMV0sIG9jdGF2ZTogb2N0YXZlKCQkWyQwXSkgfTtcbmJyZWFrO1xuY2FzZSA0NTpcbnRoaXMuJCA9IHsgYWNjaWRlbnRhbDogJCRbJDAtMV0sIHN0ZXA6ICskJFskMF0gfTtcbmJyZWFrO1xuY2FzZSA0NjpcbnRoaXMuJCA9IHsgYWNjaWRlbnRhbDogJCRbJDAtMl0sIHN0ZXA6ICskJFskMC0xXSwgb2N0YXZlOiBvY3RhdmUoJCRbJDBdKSB9O1xuYnJlYWs7XG5jYXNlIDQ4OlxudGhpcy4kID0geyB0eXBlOiAkJFskMF0gfTtcbmJyZWFrO1xuY2FzZSA0OTpcbnRoaXMuJCA9IHsgdHlwZTogNCwgZG90OiAkJFskMF0ubGVuZ3RoIH07XG5icmVhaztcbmNhc2UgNTA6XG50aGlzLiQgPSB7IHR5cGU6ICQkWyQwLTFdLCBkb3Q6ICQkWyQwXS5sZW5ndGggfTtcbmJyZWFrO1xuY2FzZSA1MTpcbnRoaXMuJCA9IDg7XG5icmVhaztcbmNhc2UgNTI6XG50aGlzLiQgPSAxNjtcbmJyZWFrO1xuY2FzZSA1MzpcbnRoaXMuJCA9IDMyO1xuYnJlYWs7XG5jYXNlIDU0OlxudGhpcy4kID0gNjQ7XG5icmVhaztcbmNhc2UgNTU6XG50aGlzLiQgPSAxMjg7XG5icmVhaztcbmNhc2UgNTY6XG50aGlzLiQgPSAyNTY7XG5icmVhaztcbmNhc2UgNTc6XG50aGlzLiQgPSAyO1xuYnJlYWs7XG5jYXNlIDU4OlxudGhpcy4kID0gMTtcbmJyZWFrO1xuY2FzZSA1OTpcbnRoaXMuJCA9IHsgcGl0Y2hlczogJCRbJDAtMV0gfTtcbmJyZWFrO1xuY2FzZSA2MTogY2FzZSA2NjpcbiB0aGlzLiQgPSAkJFskMC0xXTsgJCRbJDAtMV0ucHVzaCgkJFskMF0pOyBcbmJyZWFrO1xuY2FzZSA2MjpcbnRoaXMuJCA9ICQkWyQwLTFdO1xuYnJlYWs7XG5jYXNlIDY0OlxuIHRoaXMuJCA9ICQkWyQwLTJdOyAkJFskMC0yXS5wdXNoKCQkWyQwLTFdKTsgXG5icmVhaztcbmNhc2UgNjc6XG50aGlzLiQgPSB7IHRpbWU6IHsgYmVhdHM6ICskJFskMC0xXSwgYmVhdFR5cGU6ICskJFskMF0gfSB9O1xuYnJlYWs7XG59XG59LFxudGFibGU6IFt7MzoxLDQ6Miw1OlsyLDJdLDY6Myw4OjQsOTpbMSw1XSwxMDpbMSw2XSwxMTo3LDEyOjgsMTM6OSwxNDokVjAsMTY6MTAsMTc6MTIsMTg6MTMsMTk6MTQsMjA6MjEsMjE6JFYxLDIyOiRWMiwyMzokVjMsMjQ6JFY0LDI1OiRWNSwyNjokVjYsMjc6MjIsMjk6JFY3LDMxOjI0LDMyOjI1LDMzOjI2LDM0OiRWOCwzNjozMCwzNzozMSwzODozMiwzOTokVjksNDE6JFZhLDQ4OiRWYiw1MTokVmMsNTg6JFZkfSx7MTpbM119LHs1OlsxLDM2XX0sbygkVmUsJFZmLHs3OjM3fSksezU6WzIsNV19LG8oJFZlLFsyLDZdKSxvKCRWZSxbMiw3XSksezU6WzIsMTFdLDEyOjM4LDE2OjEwLDE3OjEyLDE4OjEzLDE5OjE0LDIwOjIxLDIxOiRWMSwyMjokVjIsMjM6JFYzLDI0OiRWNCwyNTokVjUsMjY6JFY2LDI3OjIyLDI5OiRWNywzMToyNCwzMjoyNSwzMzoyNiwzNDokVjgsMzY6MzAsMzc6MzEsMzg6MzIsMzk6JFY5LDQxOiRWYSw0ODokVmIsNTE6JFZjLDU4OiRWZH0sezU6WzIsMTJdfSxvKCRWZywkVmYsezc6Mzl9KSx7NTpbMiwxN119LG8oJFZnLFsyLDE1XSx7MTU6WzEsNDBdfSksezU6WzIsMThdLDE4OjQxLDIxOiRWMSwyMjokVjIsMjM6JFYzLDI0OiRWNCwyNTokVjUsMjY6JFY2fSxvKFs5LDEwLDI5LDM0LDM5LDQxLDQ4LDUxLDU4XSwkVmYsezc6NDJ9KSxvKCRWaCxbMiwyMF0sezI3OjIyLDMxOjI0LDMyOjI1LDMzOjI2LDM2OjMwLDM3OjMxLDM4OjMyLDIwOjQzLDI5OiRWNywzNDokVjgsMzk6JFY5LDQxOiRWYSw0ODokVmIsNTE6JFZjLDU4OiRWZH0pLG8oJFZnLFsyLDI1XSksbygkVmcsWzIsMjZdKSxvKCRWZyxbMiwyN10pLG8oJFZnLFsyLDI4XSksbygkVmcsWzIsMjldKSxvKCRWZyxbMiwzMF0pLG8oJFZnLCRWZix7Nzo0NH0pLG8oJFZnLFsyLDMxXSx7Mjg6WzEsNDVdfSksbygkVmcsJFZpLHszMDo0Niw0Mjo0Nyw0MzokVmosNDQ6JFZrLDQ1OiRWbCw0NjokVm0sNDc6JFZufSksbygkVmcsWzIsMzRdKSxvKCRWZyxbMiwzNV0pLG8oJFZvLCRWaSx7NDI6NDcsMzA6NTMsNDM6JFZqLDQ0OiRWayw0NTokVmwsNDY6JFZtLDQ3OiRWbn0pLHszMzo1NCwzNjozMCwzNzozMSwzODozMiwzOTokVjksNDE6JFZhLDQ4OiRWYn0sezUyOjU1LDU0OlsxLDU2XX0sezU5OlsxLDU3XX0sbygkVnAsWzIsNDBdKSxvKCRWcCxbMiw0MV0pLG8oJFZwLFsyLDQyXSksezM4OjU5LDM5OiRWOSw0MTokVmEsNDk6NTh9LG8oJFZxLFsyLDQzXSx7NDA6WzEsNjBdfSksezM5OlsxLDYxXX0sezE6WzIsMV19LHs1OlsyLDNdLDg6NjIsOTokVnIsMTA6JFZzLDExOjcsMTI6OCwxMzo5LDE0OiRWMCwxNjoxMCwxNzoxMiwxODoxMywxOToxNCwyMDoyMSwyMTokVjEsMjI6JFYyLDIzOiRWMywyNDokVjQsMjU6JFY1LDI2OiRWNiwyNzoyMiwyOTokVjcsMzE6MjQsMzI6MjUsMzM6MjYsMzQ6JFY4LDM2OjMwLDM3OjMxLDM4OjMyLDM5OiRWOSw0MTokVmEsNDg6JFZiLDUxOiRWYyw1ODokVmR9LHs1OlsyLDEzXX0sbygkVnQsWzIsMTRdLHs5OiRWciwxMDokVnN9KSxvKCRWZyxbMiwxNl0pLG8oJFZnLCRWZix7Nzo2NX0pLHs5OiRWciwxMDokVnMsMTc6NjYsMTk6MTQsMjA6MjEsMjc6MjIsMjk6JFY3LDMxOjI0LDMyOjI1LDMzOjI2LDM0OiRWOCwzNjozMCwzNzozMSwzODozMiwzOTokVjksNDE6JFZhLDQ4OiRWYiw1MTokVmMsNTg6JFZkfSxvKCRWZywkVmYsezc6Njd9KSxvKCRWdCxbMiwyM10sezk6JFZyLDEwOiRWc30pLG8oJFZnLFsyLDMyXSksbygkVmcsWzIsMzNdKSxvKCRWbyxbMiw0OF0sezQzOlsxLDY4XX0pLG8oJFZvLFsyLDQ5XSksbygkVnUsWzIsNTFdKSxvKCRWdSxbMiw1Ml0sezQ0OlsxLDY5XSw0NTpbMSw3MF19KSxvKCRWdSxbMiw1N10pLG8oJFZ1LFsyLDU4XSksbygkVnYsWzIsMzZdLHszNTpbMSw3MV19KSxvKCRWbywkVmksezQyOjQ3LDMwOjcyLDQzOiRWaiw0NDokVmssNDU6JFZsLDQ2OiRWbSw0NzokVm59KSx7NTM6WzEsNzNdfSx7NTM6WzIsNjNdLDU1OlsxLDc0XX0sbygkVmcsWzIsNjddKSx7Mzg6NzYsMzk6JFY5LDQxOiRWYSw1MDpbMSw3NV19LG8oJFZ3LFsyLDYwXSksbygkVnEsWzIsNDRdKSxvKCRWcSxbMiw0NV0sezQwOlsxLDc3XX0pLHs1OlsyLDRdfSxvKCRWZSxbMiw5XSksbygkVmUsWzIsMTBdKSxvKCRWaCxbMiwyMl0sezIwOjIxLDI3OjIyLDMxOjI0LDMyOjI1LDMzOjI2LDM2OjMwLDM3OjMxLDM4OjMyLDE5Ojc4LDk6JFZyLDEwOiRWcywyOTokVjcsMzQ6JFY4LDM5OiRWOSw0MTokVmEsNDg6JFZiLDUxOiRWYyw1ODokVmR9KSx7NTpbMiwxOV0sMTg6NDEsMjE6JFYxLDIyOiRWMiwyMzokVjMsMjQ6JFY0LDI1OiRWNSwyNjokVjZ9LG8oJFZ0LFsyLDI0XSx7OTokVnIsMTA6JFZzfSksbygkVm8sWzIsNTBdKSxvKCRWdSxbMiw1M10pLG8oJFZ1LFsyLDU0XSx7NDQ6WzEsNzldLDQ1OlsxLDgwXX0pLG8oJFZ2LFsyLDM4XSksbygkVnYsWzIsMzddLHszNTpbMSw4MV19KSxvKCRWZyxbMiw2Ml0pLHsyNzo4MywzMzoyNiwzNDokVjgsMzY6MzAsMzc6MzEsMzg6MzIsMzk6JFY5LDQxOiRWYSw0ODokVmIsNTY6ODIsNTc6WzEsODRdfSxvKCRWcCxbMiw1OV0pLG8oJFZ3LFsyLDYxXSksbygkVnEsWzIsNDZdKSxvKCRWaCxbMiwyMV0sezI3OjIyLDMxOjI0LDMyOjI1LDMzOjI2LDM2OjMwLDM3OjMxLDM4OjMyLDIwOjQzLDI5OiRWNywzNDokVjgsMzk6JFY5LDQxOiRWYSw0ODokVmIsNTE6JFZjLDU4OiRWZH0pLG8oJFZ1LFsyLDU1XSksbygkVnUsWzIsNTZdKSxvKCRWdixbMiwzOV0pLHs1MzpbMiw2NF19LHs1MzpbMiw2NV19LHsyNzo4NSwzMzoyNiwzNDokVjgsMzY6MzAsMzc6MzEsMzg6MzIsMzk6JFY5LDQxOiRWYSw0ODokVmJ9LHs1MzpbMiw2Nl19XSxcbmRlZmF1bHRBY3Rpb25zOiB7NDpbMiw1XSw4OlsyLDEyXSwxMDpbMiwxN10sMzY6WzIsMV0sMzg6WzIsMTNdLDYyOlsyLDRdLDgyOlsyLDY0XSw4MzpbMiw2NV0sODU6WzIsNjZdfSxcbnBhcnNlRXJyb3I6IGZ1bmN0aW9uIHBhcnNlRXJyb3Ioc3RyLCBoYXNoKSB7XG4gICAgaWYgKGhhc2gucmVjb3ZlcmFibGUpIHtcbiAgICAgICAgdGhpcy50cmFjZShzdHIpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGZ1bmN0aW9uIF9wYXJzZUVycm9yIChtc2csIGhhc2gpIHtcbiAgICAgICAgICAgIHRoaXMubWVzc2FnZSA9IG1zZztcbiAgICAgICAgICAgIHRoaXMuaGFzaCA9IGhhc2g7XG4gICAgICAgIH1cbiAgICAgICAgX3BhcnNlRXJyb3IucHJvdG90eXBlID0gRXJyb3I7XG5cbiAgICAgICAgdGhyb3cgbmV3IF9wYXJzZUVycm9yKHN0ciwgaGFzaCk7XG4gICAgfVxufSxcbnBhcnNlOiBmdW5jdGlvbiBwYXJzZShpbnB1dCkge1xuICAgIHZhciBzZWxmID0gdGhpcywgc3RhY2sgPSBbMF0sIHRzdGFjayA9IFtdLCB2c3RhY2sgPSBbbnVsbF0sIGxzdGFjayA9IFtdLCB0YWJsZSA9IHRoaXMudGFibGUsIHl5dGV4dCA9ICcnLCB5eWxpbmVubyA9IDAsIHl5bGVuZyA9IDAsIHJlY292ZXJpbmcgPSAwLCBURVJST1IgPSAyLCBFT0YgPSAxO1xuICAgIHZhciBhcmdzID0gbHN0YWNrLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgICB2YXIgbGV4ZXIgPSBPYmplY3QuY3JlYXRlKHRoaXMubGV4ZXIpO1xuICAgIHZhciBzaGFyZWRTdGF0ZSA9IHsgeXk6IHt9IH07XG4gICAgZm9yICh2YXIgayBpbiB0aGlzLnl5KSB7XG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGhpcy55eSwgaykpIHtcbiAgICAgICAgICAgIHNoYXJlZFN0YXRlLnl5W2tdID0gdGhpcy55eVtrXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBsZXhlci5zZXRJbnB1dChpbnB1dCwgc2hhcmVkU3RhdGUueXkpO1xuICAgIHNoYXJlZFN0YXRlLnl5LmxleGVyID0gbGV4ZXI7XG4gICAgc2hhcmVkU3RhdGUueXkucGFyc2VyID0gdGhpcztcbiAgICBpZiAodHlwZW9mIGxleGVyLnl5bGxvYyA9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBsZXhlci55eWxsb2MgPSB7fTtcbiAgICB9XG4gICAgdmFyIHl5bG9jID0gbGV4ZXIueXlsbG9jO1xuICAgIGxzdGFjay5wdXNoKHl5bG9jKTtcbiAgICB2YXIgcmFuZ2VzID0gbGV4ZXIub3B0aW9ucyAmJiBsZXhlci5vcHRpb25zLnJhbmdlcztcbiAgICBpZiAodHlwZW9mIHNoYXJlZFN0YXRlLnl5LnBhcnNlRXJyb3IgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhpcy5wYXJzZUVycm9yID0gc2hhcmVkU3RhdGUueXkucGFyc2VFcnJvcjtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnBhcnNlRXJyb3IgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YodGhpcykucGFyc2VFcnJvcjtcbiAgICB9XG4gICAgZnVuY3Rpb24gcG9wU3RhY2sobikge1xuICAgICAgICBzdGFjay5sZW5ndGggPSBzdGFjay5sZW5ndGggLSAyICogbjtcbiAgICAgICAgdnN0YWNrLmxlbmd0aCA9IHZzdGFjay5sZW5ndGggLSBuO1xuICAgICAgICBsc3RhY2subGVuZ3RoID0gbHN0YWNrLmxlbmd0aCAtIG47XG4gICAgfVxuICAgIF90b2tlbl9zdGFjazpcbiAgICAgICAgdmFyIGxleCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciB0b2tlbjtcbiAgICAgICAgICAgIHRva2VuID0gbGV4ZXIubGV4KCkgfHwgRU9GO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB0b2tlbiAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICB0b2tlbiA9IHNlbGYuc3ltYm9sc19bdG9rZW5dIHx8IHRva2VuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRva2VuO1xuICAgICAgICB9O1xuICAgIHZhciBzeW1ib2wsIHByZUVycm9yU3ltYm9sLCBzdGF0ZSwgYWN0aW9uLCBhLCByLCB5eXZhbCA9IHt9LCBwLCBsZW4sIG5ld1N0YXRlLCBleHBlY3RlZDtcbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICBzdGF0ZSA9IHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdO1xuICAgICAgICBpZiAodGhpcy5kZWZhdWx0QWN0aW9uc1tzdGF0ZV0pIHtcbiAgICAgICAgICAgIGFjdGlvbiA9IHRoaXMuZGVmYXVsdEFjdGlvbnNbc3RhdGVdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKHN5bWJvbCA9PT0gbnVsbCB8fCB0eXBlb2Ygc3ltYm9sID09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgc3ltYm9sID0gbGV4KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhY3Rpb24gPSB0YWJsZVtzdGF0ZV0gJiYgdGFibGVbc3RhdGVdW3N5bWJvbF07XG4gICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBhY3Rpb24gPT09ICd1bmRlZmluZWQnIHx8ICFhY3Rpb24ubGVuZ3RoIHx8ICFhY3Rpb25bMF0pIHtcbiAgICAgICAgICAgICAgICB2YXIgZXJyU3RyID0gJyc7XG4gICAgICAgICAgICAgICAgZXhwZWN0ZWQgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKHAgaW4gdGFibGVbc3RhdGVdKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnRlcm1pbmFsc19bcF0gJiYgcCA+IFRFUlJPUikge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXhwZWN0ZWQucHVzaCgnXFwnJyArIHRoaXMudGVybWluYWxzX1twXSArICdcXCcnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobGV4ZXIuc2hvd1Bvc2l0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIGVyclN0ciA9ICdQYXJzZSBlcnJvciBvbiBsaW5lICcgKyAoeXlsaW5lbm8gKyAxKSArICc6XFxuJyArIGxleGVyLnNob3dQb3NpdGlvbigpICsgJ1xcbkV4cGVjdGluZyAnICsgZXhwZWN0ZWQuam9pbignLCAnKSArICcsIGdvdCBcXCcnICsgKHRoaXMudGVybWluYWxzX1tzeW1ib2xdIHx8IHN5bWJvbCkgKyAnXFwnJztcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBlcnJTdHIgPSAnUGFyc2UgZXJyb3Igb24gbGluZSAnICsgKHl5bGluZW5vICsgMSkgKyAnOiBVbmV4cGVjdGVkICcgKyAoc3ltYm9sID09IEVPRiA/ICdlbmQgb2YgaW5wdXQnIDogJ1xcJycgKyAodGhpcy50ZXJtaW5hbHNfW3N5bWJvbF0gfHwgc3ltYm9sKSArICdcXCcnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5wYXJzZUVycm9yKGVyclN0ciwge1xuICAgICAgICAgICAgICAgICAgICB0ZXh0OiBsZXhlci5tYXRjaCxcbiAgICAgICAgICAgICAgICAgICAgdG9rZW46IHRoaXMudGVybWluYWxzX1tzeW1ib2xdIHx8IHN5bWJvbCxcbiAgICAgICAgICAgICAgICAgICAgbGluZTogbGV4ZXIueXlsaW5lbm8sXG4gICAgICAgICAgICAgICAgICAgIGxvYzogeXlsb2MsXG4gICAgICAgICAgICAgICAgICAgIGV4cGVjdGVkOiBleHBlY3RlZFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICBpZiAoYWN0aW9uWzBdIGluc3RhbmNlb2YgQXJyYXkgJiYgYWN0aW9uLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUGFyc2UgRXJyb3I6IG11bHRpcGxlIGFjdGlvbnMgcG9zc2libGUgYXQgc3RhdGU6ICcgKyBzdGF0ZSArICcsIHRva2VuOiAnICsgc3ltYm9sKTtcbiAgICAgICAgfVxuICAgICAgICBzd2l0Y2ggKGFjdGlvblswXSkge1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICBzdGFjay5wdXNoKHN5bWJvbCk7XG4gICAgICAgICAgICB2c3RhY2sucHVzaChsZXhlci55eXRleHQpO1xuICAgICAgICAgICAgbHN0YWNrLnB1c2gobGV4ZXIueXlsbG9jKTtcbiAgICAgICAgICAgIHN0YWNrLnB1c2goYWN0aW9uWzFdKTtcbiAgICAgICAgICAgIHN5bWJvbCA9IG51bGw7XG4gICAgICAgICAgICBpZiAoIXByZUVycm9yU3ltYm9sKSB7XG4gICAgICAgICAgICAgICAgeXlsZW5nID0gbGV4ZXIueXlsZW5nO1xuICAgICAgICAgICAgICAgIHl5dGV4dCA9IGxleGVyLnl5dGV4dDtcbiAgICAgICAgICAgICAgICB5eWxpbmVubyA9IGxleGVyLnl5bGluZW5vO1xuICAgICAgICAgICAgICAgIHl5bG9jID0gbGV4ZXIueXlsbG9jO1xuICAgICAgICAgICAgICAgIGlmIChyZWNvdmVyaW5nID4gMCkge1xuICAgICAgICAgICAgICAgICAgICByZWNvdmVyaW5nLS07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzeW1ib2wgPSBwcmVFcnJvclN5bWJvbDtcbiAgICAgICAgICAgICAgICBwcmVFcnJvclN5bWJvbCA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgbGVuID0gdGhpcy5wcm9kdWN0aW9uc19bYWN0aW9uWzFdXVsxXTtcbiAgICAgICAgICAgIHl5dmFsLiQgPSB2c3RhY2tbdnN0YWNrLmxlbmd0aCAtIGxlbl07XG4gICAgICAgICAgICB5eXZhbC5fJCA9IHtcbiAgICAgICAgICAgICAgICBmaXJzdF9saW5lOiBsc3RhY2tbbHN0YWNrLmxlbmd0aCAtIChsZW4gfHwgMSldLmZpcnN0X2xpbmUsXG4gICAgICAgICAgICAgICAgbGFzdF9saW5lOiBsc3RhY2tbbHN0YWNrLmxlbmd0aCAtIDFdLmxhc3RfbGluZSxcbiAgICAgICAgICAgICAgICBmaXJzdF9jb2x1bW46IGxzdGFja1tsc3RhY2subGVuZ3RoIC0gKGxlbiB8fCAxKV0uZmlyc3RfY29sdW1uLFxuICAgICAgICAgICAgICAgIGxhc3RfY29sdW1uOiBsc3RhY2tbbHN0YWNrLmxlbmd0aCAtIDFdLmxhc3RfY29sdW1uXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKHJhbmdlcykge1xuICAgICAgICAgICAgICAgIHl5dmFsLl8kLnJhbmdlID0gW1xuICAgICAgICAgICAgICAgICAgICBsc3RhY2tbbHN0YWNrLmxlbmd0aCAtIChsZW4gfHwgMSldLnJhbmdlWzBdLFxuICAgICAgICAgICAgICAgICAgICBsc3RhY2tbbHN0YWNrLmxlbmd0aCAtIDFdLnJhbmdlWzFdXG4gICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHIgPSB0aGlzLnBlcmZvcm1BY3Rpb24uYXBwbHkoeXl2YWwsIFtcbiAgICAgICAgICAgICAgICB5eXRleHQsXG4gICAgICAgICAgICAgICAgeXlsZW5nLFxuICAgICAgICAgICAgICAgIHl5bGluZW5vLFxuICAgICAgICAgICAgICAgIHNoYXJlZFN0YXRlLnl5LFxuICAgICAgICAgICAgICAgIGFjdGlvblsxXSxcbiAgICAgICAgICAgICAgICB2c3RhY2ssXG4gICAgICAgICAgICAgICAgbHN0YWNrXG4gICAgICAgICAgICBdLmNvbmNhdChhcmdzKSk7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHIgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobGVuKSB7XG4gICAgICAgICAgICAgICAgc3RhY2sgPSBzdGFjay5zbGljZSgwLCAtMSAqIGxlbiAqIDIpO1xuICAgICAgICAgICAgICAgIHZzdGFjayA9IHZzdGFjay5zbGljZSgwLCAtMSAqIGxlbik7XG4gICAgICAgICAgICAgICAgbHN0YWNrID0gbHN0YWNrLnNsaWNlKDAsIC0xICogbGVuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN0YWNrLnB1c2godGhpcy5wcm9kdWN0aW9uc19bYWN0aW9uWzFdXVswXSk7XG4gICAgICAgICAgICB2c3RhY2sucHVzaCh5eXZhbC4kKTtcbiAgICAgICAgICAgIGxzdGFjay5wdXNoKHl5dmFsLl8kKTtcbiAgICAgICAgICAgIG5ld1N0YXRlID0gdGFibGVbc3RhY2tbc3RhY2subGVuZ3RoIC0gMl1dW3N0YWNrW3N0YWNrLmxlbmd0aCAtIDFdXTtcbiAgICAgICAgICAgIHN0YWNrLnB1c2gobmV3U3RhdGUpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufX07XG5cblxudmFyIGV4dGVuZCA9IHJlcXVpcmUoJy4uL3V0aWwnKS5leHRlbmQ7XG5cbmZ1bmN0aW9uIGxhc3RJdGVtKGFycikgeyByZXR1cm4gYXJyW2Fyci5sZW5ndGggLSAxXTsgfVxuXG5mdW5jdGlvbiBvbmx5UHJvcGVydHkob2JqKSB7XG4gIHJldHVybiBvYmpbT2JqZWN0LmtleXMob2JqKVswXV07XG59XG5cbmZ1bmN0aW9uIG9jdGF2ZShzdHIpIHtcbiAgdmFyIGxlbiA9IHN0ci5sZW5ndGg7XG4gIHJldHVybiBzdHIuY2hhckF0KDApID09PSAnLCcgPyAtbGVuIDogbGVuO1xufVxuXG5mdW5jdGlvbiByZW1vdmVMYXN0RW1wdHlNZWFzdXJlKHNjb3JlKSB7XG4gIHZhciBwYXJ0cyA9IHNjb3JlLnBhcnRzO1xuICBpZiAoIXBhcnRzKSB7IHJldHVybjsgfVxuXG4gIHBhcnRzLmZvckVhY2goZnVuY3Rpb24gKHBhcnQpIHtcbiAgICB2YXIgbGFzdE1lYXN1cmUgPSBsYXN0SXRlbShwYXJ0Lm1lYXN1cmVzKTtcbiAgICBpZiAobGFzdE1lYXN1cmUuZGF0YS5sZW5ndGggPT09IDApIHtcbiAgICAgIHBhcnQubWVhc3VyZXMucG9wKCk7XG4gICAgfVxuICB9KTtcbn1cblxuLyogZ2VuZXJhdGVkIGJ5IGppc29uLWxleCAwLjMuNCAqL1xudmFyIGxleGVyID0gKGZ1bmN0aW9uKCl7XG52YXIgbGV4ZXIgPSAoe1xuXG5FT0Y6MSxcblxucGFyc2VFcnJvcjpmdW5jdGlvbiBwYXJzZUVycm9yKHN0ciwgaGFzaCkge1xuICAgICAgICBpZiAodGhpcy55eS5wYXJzZXIpIHtcbiAgICAgICAgICAgIHRoaXMueXkucGFyc2VyLnBhcnNlRXJyb3Ioc3RyLCBoYXNoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihzdHIpO1xuICAgICAgICB9XG4gICAgfSxcblxuLy8gcmVzZXRzIHRoZSBsZXhlciwgc2V0cyBuZXcgaW5wdXRcbnNldElucHV0OmZ1bmN0aW9uIChpbnB1dCwgeXkpIHtcbiAgICAgICAgdGhpcy55eSA9IHl5IHx8IHRoaXMueXkgfHwge307XG4gICAgICAgIHRoaXMuX2lucHV0ID0gaW5wdXQ7XG4gICAgICAgIHRoaXMuX21vcmUgPSB0aGlzLl9iYWNrdHJhY2sgPSB0aGlzLmRvbmUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy55eWxpbmVubyA9IHRoaXMueXlsZW5nID0gMDtcbiAgICAgICAgdGhpcy55eXRleHQgPSB0aGlzLm1hdGNoZWQgPSB0aGlzLm1hdGNoID0gJyc7XG4gICAgICAgIHRoaXMuY29uZGl0aW9uU3RhY2sgPSBbJ0lOSVRJQUwnXTtcbiAgICAgICAgdGhpcy55eWxsb2MgPSB7XG4gICAgICAgICAgICBmaXJzdF9saW5lOiAxLFxuICAgICAgICAgICAgZmlyc3RfY29sdW1uOiAwLFxuICAgICAgICAgICAgbGFzdF9saW5lOiAxLFxuICAgICAgICAgICAgbGFzdF9jb2x1bW46IDBcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5yYW5nZXMpIHtcbiAgICAgICAgICAgIHRoaXMueXlsbG9jLnJhbmdlID0gWzAsMF07XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5vZmZzZXQgPSAwO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4vLyBjb25zdW1lcyBhbmQgcmV0dXJucyBvbmUgY2hhciBmcm9tIHRoZSBpbnB1dFxuaW5wdXQ6ZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY2ggPSB0aGlzLl9pbnB1dFswXTtcbiAgICAgICAgdGhpcy55eXRleHQgKz0gY2g7XG4gICAgICAgIHRoaXMueXlsZW5nKys7XG4gICAgICAgIHRoaXMub2Zmc2V0Kys7XG4gICAgICAgIHRoaXMubWF0Y2ggKz0gY2g7XG4gICAgICAgIHRoaXMubWF0Y2hlZCArPSBjaDtcbiAgICAgICAgdmFyIGxpbmVzID0gY2gubWF0Y2goLyg/Olxcclxcbj98XFxuKS4qL2cpO1xuICAgICAgICBpZiAobGluZXMpIHtcbiAgICAgICAgICAgIHRoaXMueXlsaW5lbm8rKztcbiAgICAgICAgICAgIHRoaXMueXlsbG9jLmxhc3RfbGluZSsrO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy55eWxsb2MubGFzdF9jb2x1bW4rKztcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnJhbmdlcykge1xuICAgICAgICAgICAgdGhpcy55eWxsb2MucmFuZ2VbMV0rKztcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2lucHV0ID0gdGhpcy5faW5wdXQuc2xpY2UoMSk7XG4gICAgICAgIHJldHVybiBjaDtcbiAgICB9LFxuXG4vLyB1bnNoaWZ0cyBvbmUgY2hhciAob3IgYSBzdHJpbmcpIGludG8gdGhlIGlucHV0XG51bnB1dDpmdW5jdGlvbiAoY2gpIHtcbiAgICAgICAgdmFyIGxlbiA9IGNoLmxlbmd0aDtcbiAgICAgICAgdmFyIGxpbmVzID0gY2guc3BsaXQoLyg/Olxcclxcbj98XFxuKS9nKTtcblxuICAgICAgICB0aGlzLl9pbnB1dCA9IGNoICsgdGhpcy5faW5wdXQ7XG4gICAgICAgIHRoaXMueXl0ZXh0ID0gdGhpcy55eXRleHQuc3Vic3RyKDAsIHRoaXMueXl0ZXh0Lmxlbmd0aCAtIGxlbik7XG4gICAgICAgIC8vdGhpcy55eWxlbmcgLT0gbGVuO1xuICAgICAgICB0aGlzLm9mZnNldCAtPSBsZW47XG4gICAgICAgIHZhciBvbGRMaW5lcyA9IHRoaXMubWF0Y2guc3BsaXQoLyg/Olxcclxcbj98XFxuKS9nKTtcbiAgICAgICAgdGhpcy5tYXRjaCA9IHRoaXMubWF0Y2guc3Vic3RyKDAsIHRoaXMubWF0Y2gubGVuZ3RoIC0gMSk7XG4gICAgICAgIHRoaXMubWF0Y2hlZCA9IHRoaXMubWF0Y2hlZC5zdWJzdHIoMCwgdGhpcy5tYXRjaGVkLmxlbmd0aCAtIDEpO1xuXG4gICAgICAgIGlmIChsaW5lcy5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICB0aGlzLnl5bGluZW5vIC09IGxpbmVzLmxlbmd0aCAtIDE7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHIgPSB0aGlzLnl5bGxvYy5yYW5nZTtcblxuICAgICAgICB0aGlzLnl5bGxvYyA9IHtcbiAgICAgICAgICAgIGZpcnN0X2xpbmU6IHRoaXMueXlsbG9jLmZpcnN0X2xpbmUsXG4gICAgICAgICAgICBsYXN0X2xpbmU6IHRoaXMueXlsaW5lbm8gKyAxLFxuICAgICAgICAgICAgZmlyc3RfY29sdW1uOiB0aGlzLnl5bGxvYy5maXJzdF9jb2x1bW4sXG4gICAgICAgICAgICBsYXN0X2NvbHVtbjogbGluZXMgP1xuICAgICAgICAgICAgICAgIChsaW5lcy5sZW5ndGggPT09IG9sZExpbmVzLmxlbmd0aCA/IHRoaXMueXlsbG9jLmZpcnN0X2NvbHVtbiA6IDApXG4gICAgICAgICAgICAgICAgICsgb2xkTGluZXNbb2xkTGluZXMubGVuZ3RoIC0gbGluZXMubGVuZ3RoXS5sZW5ndGggLSBsaW5lc1swXS5sZW5ndGggOlxuICAgICAgICAgICAgICB0aGlzLnl5bGxvYy5maXJzdF9jb2x1bW4gLSBsZW5cbiAgICAgICAgfTtcblxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnJhbmdlcykge1xuICAgICAgICAgICAgdGhpcy55eWxsb2MucmFuZ2UgPSBbclswXSwgclswXSArIHRoaXMueXlsZW5nIC0gbGVuXTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnl5bGVuZyA9IHRoaXMueXl0ZXh0Lmxlbmd0aDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuLy8gV2hlbiBjYWxsZWQgZnJvbSBhY3Rpb24sIGNhY2hlcyBtYXRjaGVkIHRleHQgYW5kIGFwcGVuZHMgaXQgb24gbmV4dCBhY3Rpb25cbm1vcmU6ZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9tb3JlID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuLy8gV2hlbiBjYWxsZWQgZnJvbSBhY3Rpb24sIHNpZ25hbHMgdGhlIGxleGVyIHRoYXQgdGhpcyBydWxlIGZhaWxzIHRvIG1hdGNoIHRoZSBpbnB1dCwgc28gdGhlIG5leHQgbWF0Y2hpbmcgcnVsZSAocmVnZXgpIHNob3VsZCBiZSB0ZXN0ZWQgaW5zdGVhZC5cbnJlamVjdDpmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuYmFja3RyYWNrX2xleGVyKSB7XG4gICAgICAgICAgICB0aGlzLl9iYWNrdHJhY2sgPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VFcnJvcignTGV4aWNhbCBlcnJvciBvbiBsaW5lICcgKyAodGhpcy55eWxpbmVubyArIDEpICsgJy4gWW91IGNhbiBvbmx5IGludm9rZSByZWplY3QoKSBpbiB0aGUgbGV4ZXIgd2hlbiB0aGUgbGV4ZXIgaXMgb2YgdGhlIGJhY2t0cmFja2luZyBwZXJzdWFzaW9uIChvcHRpb25zLmJhY2t0cmFja19sZXhlciA9IHRydWUpLlxcbicgKyB0aGlzLnNob3dQb3NpdGlvbigpLCB7XG4gICAgICAgICAgICAgICAgdGV4dDogXCJcIixcbiAgICAgICAgICAgICAgICB0b2tlbjogbnVsbCxcbiAgICAgICAgICAgICAgICBsaW5lOiB0aGlzLnl5bGluZW5vXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbi8vIHJldGFpbiBmaXJzdCBuIGNoYXJhY3RlcnMgb2YgdGhlIG1hdGNoXG5sZXNzOmZ1bmN0aW9uIChuKSB7XG4gICAgICAgIHRoaXMudW5wdXQodGhpcy5tYXRjaC5zbGljZShuKSk7XG4gICAgfSxcblxuLy8gZGlzcGxheXMgYWxyZWFkeSBtYXRjaGVkIGlucHV0LCBpLmUuIGZvciBlcnJvciBtZXNzYWdlc1xucGFzdElucHV0OmZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHBhc3QgPSB0aGlzLm1hdGNoZWQuc3Vic3RyKDAsIHRoaXMubWF0Y2hlZC5sZW5ndGggLSB0aGlzLm1hdGNoLmxlbmd0aCk7XG4gICAgICAgIHJldHVybiAocGFzdC5sZW5ndGggPiAyMCA/ICcuLi4nOicnKSArIHBhc3Quc3Vic3RyKC0yMCkucmVwbGFjZSgvXFxuL2csIFwiXCIpO1xuICAgIH0sXG5cbi8vIGRpc3BsYXlzIHVwY29taW5nIGlucHV0LCBpLmUuIGZvciBlcnJvciBtZXNzYWdlc1xudXBjb21pbmdJbnB1dDpmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBuZXh0ID0gdGhpcy5tYXRjaDtcbiAgICAgICAgaWYgKG5leHQubGVuZ3RoIDwgMjApIHtcbiAgICAgICAgICAgIG5leHQgKz0gdGhpcy5faW5wdXQuc3Vic3RyKDAsIDIwLW5leHQubGVuZ3RoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKG5leHQuc3Vic3RyKDAsMjApICsgKG5leHQubGVuZ3RoID4gMjAgPyAnLi4uJyA6ICcnKSkucmVwbGFjZSgvXFxuL2csIFwiXCIpO1xuICAgIH0sXG5cbi8vIGRpc3BsYXlzIHRoZSBjaGFyYWN0ZXIgcG9zaXRpb24gd2hlcmUgdGhlIGxleGluZyBlcnJvciBvY2N1cnJlZCwgaS5lLiBmb3IgZXJyb3IgbWVzc2FnZXNcbnNob3dQb3NpdGlvbjpmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBwcmUgPSB0aGlzLnBhc3RJbnB1dCgpO1xuICAgICAgICB2YXIgYyA9IG5ldyBBcnJheShwcmUubGVuZ3RoICsgMSkuam9pbihcIi1cIik7XG4gICAgICAgIHJldHVybiBwcmUgKyB0aGlzLnVwY29taW5nSW5wdXQoKSArIFwiXFxuXCIgKyBjICsgXCJeXCI7XG4gICAgfSxcblxuLy8gdGVzdCB0aGUgbGV4ZWQgdG9rZW46IHJldHVybiBGQUxTRSB3aGVuIG5vdCBhIG1hdGNoLCBvdGhlcndpc2UgcmV0dXJuIHRva2VuXG50ZXN0X21hdGNoOmZ1bmN0aW9uIChtYXRjaCwgaW5kZXhlZF9ydWxlKSB7XG4gICAgICAgIHZhciB0b2tlbixcbiAgICAgICAgICAgIGxpbmVzLFxuICAgICAgICAgICAgYmFja3VwO1xuXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuYmFja3RyYWNrX2xleGVyKSB7XG4gICAgICAgICAgICAvLyBzYXZlIGNvbnRleHRcbiAgICAgICAgICAgIGJhY2t1cCA9IHtcbiAgICAgICAgICAgICAgICB5eWxpbmVubzogdGhpcy55eWxpbmVubyxcbiAgICAgICAgICAgICAgICB5eWxsb2M6IHtcbiAgICAgICAgICAgICAgICAgICAgZmlyc3RfbGluZTogdGhpcy55eWxsb2MuZmlyc3RfbGluZSxcbiAgICAgICAgICAgICAgICAgICAgbGFzdF9saW5lOiB0aGlzLmxhc3RfbGluZSxcbiAgICAgICAgICAgICAgICAgICAgZmlyc3RfY29sdW1uOiB0aGlzLnl5bGxvYy5maXJzdF9jb2x1bW4sXG4gICAgICAgICAgICAgICAgICAgIGxhc3RfY29sdW1uOiB0aGlzLnl5bGxvYy5sYXN0X2NvbHVtblxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgeXl0ZXh0OiB0aGlzLnl5dGV4dCxcbiAgICAgICAgICAgICAgICBtYXRjaDogdGhpcy5tYXRjaCxcbiAgICAgICAgICAgICAgICBtYXRjaGVzOiB0aGlzLm1hdGNoZXMsXG4gICAgICAgICAgICAgICAgbWF0Y2hlZDogdGhpcy5tYXRjaGVkLFxuICAgICAgICAgICAgICAgIHl5bGVuZzogdGhpcy55eWxlbmcsXG4gICAgICAgICAgICAgICAgb2Zmc2V0OiB0aGlzLm9mZnNldCxcbiAgICAgICAgICAgICAgICBfbW9yZTogdGhpcy5fbW9yZSxcbiAgICAgICAgICAgICAgICBfaW5wdXQ6IHRoaXMuX2lucHV0LFxuICAgICAgICAgICAgICAgIHl5OiB0aGlzLnl5LFxuICAgICAgICAgICAgICAgIGNvbmRpdGlvblN0YWNrOiB0aGlzLmNvbmRpdGlvblN0YWNrLnNsaWNlKDApLFxuICAgICAgICAgICAgICAgIGRvbmU6IHRoaXMuZG9uZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMucmFuZ2VzKSB7XG4gICAgICAgICAgICAgICAgYmFja3VwLnl5bGxvYy5yYW5nZSA9IHRoaXMueXlsbG9jLnJhbmdlLnNsaWNlKDApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgbGluZXMgPSBtYXRjaFswXS5tYXRjaCgvKD86XFxyXFxuP3xcXG4pLiovZyk7XG4gICAgICAgIGlmIChsaW5lcykge1xuICAgICAgICAgICAgdGhpcy55eWxpbmVubyArPSBsaW5lcy5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy55eWxsb2MgPSB7XG4gICAgICAgICAgICBmaXJzdF9saW5lOiB0aGlzLnl5bGxvYy5sYXN0X2xpbmUsXG4gICAgICAgICAgICBsYXN0X2xpbmU6IHRoaXMueXlsaW5lbm8gKyAxLFxuICAgICAgICAgICAgZmlyc3RfY29sdW1uOiB0aGlzLnl5bGxvYy5sYXN0X2NvbHVtbixcbiAgICAgICAgICAgIGxhc3RfY29sdW1uOiBsaW5lcyA/XG4gICAgICAgICAgICAgICAgICAgICAgICAgbGluZXNbbGluZXMubGVuZ3RoIC0gMV0ubGVuZ3RoIC0gbGluZXNbbGluZXMubGVuZ3RoIC0gMV0ubWF0Y2goL1xccj9cXG4/LylbMF0ubGVuZ3RoIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnl5bGxvYy5sYXN0X2NvbHVtbiArIG1hdGNoWzBdLmxlbmd0aFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLnl5dGV4dCArPSBtYXRjaFswXTtcbiAgICAgICAgdGhpcy5tYXRjaCArPSBtYXRjaFswXTtcbiAgICAgICAgdGhpcy5tYXRjaGVzID0gbWF0Y2g7XG4gICAgICAgIHRoaXMueXlsZW5nID0gdGhpcy55eXRleHQubGVuZ3RoO1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnJhbmdlcykge1xuICAgICAgICAgICAgdGhpcy55eWxsb2MucmFuZ2UgPSBbdGhpcy5vZmZzZXQsIHRoaXMub2Zmc2V0ICs9IHRoaXMueXlsZW5nXTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9tb3JlID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2JhY2t0cmFjayA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9pbnB1dCA9IHRoaXMuX2lucHV0LnNsaWNlKG1hdGNoWzBdLmxlbmd0aCk7XG4gICAgICAgIHRoaXMubWF0Y2hlZCArPSBtYXRjaFswXTtcbiAgICAgICAgdG9rZW4gPSB0aGlzLnBlcmZvcm1BY3Rpb24uY2FsbCh0aGlzLCB0aGlzLnl5LCB0aGlzLCBpbmRleGVkX3J1bGUsIHRoaXMuY29uZGl0aW9uU3RhY2tbdGhpcy5jb25kaXRpb25TdGFjay5sZW5ndGggLSAxXSk7XG4gICAgICAgIGlmICh0aGlzLmRvbmUgJiYgdGhpcy5faW5wdXQpIHtcbiAgICAgICAgICAgIHRoaXMuZG9uZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0b2tlbikge1xuICAgICAgICAgICAgcmV0dXJuIHRva2VuO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuX2JhY2t0cmFjaykge1xuICAgICAgICAgICAgLy8gcmVjb3ZlciBjb250ZXh0XG4gICAgICAgICAgICBmb3IgKHZhciBrIGluIGJhY2t1cCkge1xuICAgICAgICAgICAgICAgIHRoaXNba10gPSBiYWNrdXBba107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7IC8vIHJ1bGUgYWN0aW9uIGNhbGxlZCByZWplY3QoKSBpbXBseWluZyB0aGUgbmV4dCBydWxlIHNob3VsZCBiZSB0ZXN0ZWQgaW5zdGVhZC5cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSxcblxuLy8gcmV0dXJuIG5leHQgbWF0Y2ggaW4gaW5wdXRcbm5leHQ6ZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5kb25lKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5FT0Y7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLl9pbnB1dCkge1xuICAgICAgICAgICAgdGhpcy5kb25lID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB0b2tlbixcbiAgICAgICAgICAgIG1hdGNoLFxuICAgICAgICAgICAgdGVtcE1hdGNoLFxuICAgICAgICAgICAgaW5kZXg7XG4gICAgICAgIGlmICghdGhpcy5fbW9yZSkge1xuICAgICAgICAgICAgdGhpcy55eXRleHQgPSAnJztcbiAgICAgICAgICAgIHRoaXMubWF0Y2ggPSAnJztcbiAgICAgICAgfVxuICAgICAgICB2YXIgcnVsZXMgPSB0aGlzLl9jdXJyZW50UnVsZXMoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBydWxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdGVtcE1hdGNoID0gdGhpcy5faW5wdXQubWF0Y2godGhpcy5ydWxlc1tydWxlc1tpXV0pO1xuICAgICAgICAgICAgaWYgKHRlbXBNYXRjaCAmJiAoIW1hdGNoIHx8IHRlbXBNYXRjaFswXS5sZW5ndGggPiBtYXRjaFswXS5sZW5ndGgpKSB7XG4gICAgICAgICAgICAgICAgbWF0Y2ggPSB0ZW1wTWF0Y2g7XG4gICAgICAgICAgICAgICAgaW5kZXggPSBpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuYmFja3RyYWNrX2xleGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHRva2VuID0gdGhpcy50ZXN0X21hdGNoKHRlbXBNYXRjaCwgcnVsZXNbaV0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAodG9rZW4gIT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdG9rZW47XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5fYmFja3RyYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXRjaCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7IC8vIHJ1bGUgYWN0aW9uIGNhbGxlZCByZWplY3QoKSBpbXBseWluZyBhIHJ1bGUgTUlTbWF0Y2guXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBlbHNlOiB0aGlzIGlzIGEgbGV4ZXIgcnVsZSB3aGljaCBjb25zdW1lcyBpbnB1dCB3aXRob3V0IHByb2R1Y2luZyBhIHRva2VuIChlLmcuIHdoaXRlc3BhY2UpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCF0aGlzLm9wdGlvbnMuZmxleCkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICB0b2tlbiA9IHRoaXMudGVzdF9tYXRjaChtYXRjaCwgcnVsZXNbaW5kZXhdKTtcbiAgICAgICAgICAgIGlmICh0b2tlbiAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdG9rZW47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBlbHNlOiB0aGlzIGlzIGEgbGV4ZXIgcnVsZSB3aGljaCBjb25zdW1lcyBpbnB1dCB3aXRob3V0IHByb2R1Y2luZyBhIHRva2VuIChlLmcuIHdoaXRlc3BhY2UpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX2lucHV0ID09PSBcIlwiKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5FT0Y7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUVycm9yKCdMZXhpY2FsIGVycm9yIG9uIGxpbmUgJyArICh0aGlzLnl5bGluZW5vICsgMSkgKyAnLiBVbnJlY29nbml6ZWQgdGV4dC5cXG4nICsgdGhpcy5zaG93UG9zaXRpb24oKSwge1xuICAgICAgICAgICAgICAgIHRleHQ6IFwiXCIsXG4gICAgICAgICAgICAgICAgdG9rZW46IG51bGwsXG4gICAgICAgICAgICAgICAgbGluZTogdGhpcy55eWxpbmVub1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4vLyByZXR1cm4gbmV4dCBtYXRjaCB0aGF0IGhhcyBhIHRva2VuXG5sZXg6ZnVuY3Rpb24gbGV4KCkge1xuICAgICAgICB2YXIgciA9IHRoaXMubmV4dCgpO1xuICAgICAgICBpZiAocikge1xuICAgICAgICAgICAgcmV0dXJuIHI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5sZXgoKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbi8vIGFjdGl2YXRlcyBhIG5ldyBsZXhlciBjb25kaXRpb24gc3RhdGUgKHB1c2hlcyB0aGUgbmV3IGxleGVyIGNvbmRpdGlvbiBzdGF0ZSBvbnRvIHRoZSBjb25kaXRpb24gc3RhY2spXG5iZWdpbjpmdW5jdGlvbiBiZWdpbihjb25kaXRpb24pIHtcbiAgICAgICAgdGhpcy5jb25kaXRpb25TdGFjay5wdXNoKGNvbmRpdGlvbik7XG4gICAgfSxcblxuLy8gcG9wIHRoZSBwcmV2aW91c2x5IGFjdGl2ZSBsZXhlciBjb25kaXRpb24gc3RhdGUgb2ZmIHRoZSBjb25kaXRpb24gc3RhY2tcbnBvcFN0YXRlOmZ1bmN0aW9uIHBvcFN0YXRlKCkge1xuICAgICAgICB2YXIgbiA9IHRoaXMuY29uZGl0aW9uU3RhY2subGVuZ3RoIC0gMTtcbiAgICAgICAgaWYgKG4gPiAwKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb25kaXRpb25TdGFjay5wb3AoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbmRpdGlvblN0YWNrWzBdO1xuICAgICAgICB9XG4gICAgfSxcblxuLy8gcHJvZHVjZSB0aGUgbGV4ZXIgcnVsZSBzZXQgd2hpY2ggaXMgYWN0aXZlIGZvciB0aGUgY3VycmVudGx5IGFjdGl2ZSBsZXhlciBjb25kaXRpb24gc3RhdGVcbl9jdXJyZW50UnVsZXM6ZnVuY3Rpb24gX2N1cnJlbnRSdWxlcygpIHtcbiAgICAgICAgaWYgKHRoaXMuY29uZGl0aW9uU3RhY2subGVuZ3RoICYmIHRoaXMuY29uZGl0aW9uU3RhY2tbdGhpcy5jb25kaXRpb25TdGFjay5sZW5ndGggLSAxXSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29uZGl0aW9uc1t0aGlzLmNvbmRpdGlvblN0YWNrW3RoaXMuY29uZGl0aW9uU3RhY2subGVuZ3RoIC0gMV1dLnJ1bGVzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29uZGl0aW9uc1tcIklOSVRJQUxcIl0ucnVsZXM7XG4gICAgICAgIH1cbiAgICB9LFxuXG4vLyByZXR1cm4gdGhlIGN1cnJlbnRseSBhY3RpdmUgbGV4ZXIgY29uZGl0aW9uIHN0YXRlOyB3aGVuIGFuIGluZGV4IGFyZ3VtZW50IGlzIHByb3ZpZGVkIGl0IHByb2R1Y2VzIHRoZSBOLXRoIHByZXZpb3VzIGNvbmRpdGlvbiBzdGF0ZSwgaWYgYXZhaWxhYmxlXG50b3BTdGF0ZTpmdW5jdGlvbiB0b3BTdGF0ZShuKSB7XG4gICAgICAgIG4gPSB0aGlzLmNvbmRpdGlvblN0YWNrLmxlbmd0aCAtIDEgLSBNYXRoLmFicyhuIHx8IDApO1xuICAgICAgICBpZiAobiA+PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb25kaXRpb25TdGFja1tuXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBcIklOSVRJQUxcIjtcbiAgICAgICAgfVxuICAgIH0sXG5cbi8vIGFsaWFzIGZvciBiZWdpbihjb25kaXRpb24pXG5wdXNoU3RhdGU6ZnVuY3Rpb24gcHVzaFN0YXRlKGNvbmRpdGlvbikge1xuICAgICAgICB0aGlzLmJlZ2luKGNvbmRpdGlvbik7XG4gICAgfSxcblxuLy8gcmV0dXJuIHRoZSBudW1iZXIgb2Ygc3RhdGVzIGN1cnJlbnRseSBvbiB0aGUgc3RhY2tcbnN0YXRlU3RhY2tTaXplOmZ1bmN0aW9uIHN0YXRlU3RhY2tTaXplKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb25kaXRpb25TdGFjay5sZW5ndGg7XG4gICAgfSxcbm9wdGlvbnM6IHt9LFxucGVyZm9ybUFjdGlvbjogZnVuY3Rpb24gYW5vbnltb3VzKHl5LHl5XywkYXZvaWRpbmdfbmFtZV9jb2xsaXNpb25zLFlZX1NUQVJUKSB7XG52YXIgWVlTVEFURT1ZWV9TVEFSVDtcbnN3aXRjaCgkYXZvaWRpbmdfbmFtZV9jb2xsaXNpb25zKSB7XG5jYXNlIDA6cmV0dXJuIDlcbmJyZWFrO1xuY2FzZSAxOnJldHVybiA5XG5icmVhaztcbmNhc2UgMjpyZXR1cm4gOVxuYnJlYWs7XG5jYXNlIDM6IHRoaXMuYmVnaW4oJ3RpdGxlJyk7IFxuYnJlYWs7XG5jYXNlIDQ6IHl5Xy55eXRleHQgPSB5eV8ueXl0ZXh0LnN1YnN0cigwLCB5eV8ueXlsZW5nIC0gMikudHJpbSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gMTQ7IFxuYnJlYWs7XG5jYXNlIDU6IHRoaXMuYmVnaW4oJ0lOSVRJQUwnKTsgXG5icmVhaztcbmNhc2UgNjogdGhpcy5iZWdpbignSU5JVElBTCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICB5eV8ueXl0ZXh0ID0geXlfLnl5dGV4dC50cmltKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAxNTsgXG5icmVhaztcbmNhc2UgNzogdGhpcy5iZWdpbigndGltZScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICB5eV8ueXl0ZXh0ID0geXlfLnl5dGV4dC5zdWJzdHIoMCwgeXlfLnl5bGVuZyAtIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gNTg7IFxuYnJlYWs7XG5jYXNlIDg6IHRoaXMuYmVnaW4oJ0lOSVRJQUwnKTsgcmV0dXJuIDU5OyBcbmJyZWFrO1xuY2FzZSA5OnJldHVybiA0MVxuYnJlYWs7XG5jYXNlIDEwOnJldHVybiAzOVxuYnJlYWs7XG5jYXNlIDExOnJldHVybiA0MFxuYnJlYWs7XG5jYXNlIDEyOnJldHVybiA0M1xuYnJlYWs7XG5jYXNlIDEzOnJldHVybiA0N1xuYnJlYWs7XG5jYXNlIDE0OnJldHVybiA0NlxuYnJlYWs7XG5jYXNlIDE1OnJldHVybiAyOFxuYnJlYWs7XG5jYXNlIDE2OnJldHVybiA0NFxuYnJlYWs7XG5jYXNlIDE3OnJldHVybiA0NVxuYnJlYWs7XG5jYXNlIDE4OnJldHVybiAnLidcbmJyZWFrO1xuY2FzZSAxOTpyZXR1cm4gMjlcbmJyZWFrO1xuY2FzZSAyMDpyZXR1cm4gNDhcbmJyZWFrO1xuY2FzZSAyMTpyZXR1cm4gNTBcbmJyZWFrO1xuY2FzZSAyMjpyZXR1cm4gMzRcbmJyZWFrO1xuY2FzZSAyMzpyZXR1cm4gMzVcbmJyZWFrO1xuY2FzZSAyNDpyZXR1cm4gJy8nXG5icmVhaztcbmNhc2UgMjU6cmV0dXJuICdcXFxcJ1xuYnJlYWs7XG5jYXNlIDI2OnJldHVybiAyM1xuYnJlYWs7XG5jYXNlIDI3OnJldHVybiAyMlxuYnJlYWs7XG5jYXNlIDI4OnJldHVybiAnW3wnXG5icmVhaztcbmNhc2UgMjk6cmV0dXJuIDI0XG5icmVhaztcbmNhc2UgMzA6cmV0dXJuIDI2XG5icmVhaztcbmNhc2UgMzE6cmV0dXJuIDI1XG5icmVhaztcbmNhc2UgMzI6cmV0dXJuIDIxXG5icmVhaztcbmNhc2UgMzM6cmV0dXJuIDUxXG5icmVhaztcbmNhc2UgMzQ6cmV0dXJuIDUzXG5icmVhaztcbmNhc2UgMzU6cmV0dXJuIDU1XG5icmVhaztcbmNhc2UgMzY6cmV0dXJuIDEwXG5icmVhaztcbmNhc2UgMzc6cmV0dXJuIDlcbmJyZWFrO1xuY2FzZSAzODpyZXR1cm4gNVxuYnJlYWs7XG5jYXNlIDM5OnJldHVybiAnSU5WQUxJRCdcbmJyZWFrO1xufVxufSxcbnJ1bGVzOiBbL14oPzpcXC9cXC9bXlxcbl0qKS8sL14oPzpcXC9cXCooW1xcc1xcU10qPylcXCpcXC8pLywvXig/OlxcL1xcKltcXHNcXFNdKikvLC9eKD86PDwpLywvXig/Oi4qPj4pLywvXig/OihbIFxcdF0pKihbXFxuXFxyXSkpLywvXig/Oi4qKS8sL14oPzooKFsxLTldXFxkezAsMn0pXFwvKSkvLC9eKD86KFsxLTldXFxkezAsMn0pW15cXGRdKS8sL14oPzooI3sxLDJ9fG58YnsxLDJ9KSkvLC9eKD86WzEtN10pLywvXig/OiwrfCcrKS8sL14oPzpcXC4rKS8sL14oPzooICotICopezN9KS8sL14oPzooICotICopKS8sL14oPzogKn4pLywvXig/OltfXSkvLC9eKD86PSkvLC9eKD86XFwuKS8sL14oPzpbMF0pLywvXig/OjwpLywvXig/Oj4pLywvXig/OlxcKCkvLC9eKD86XFwpKS8sL14oPzpcXC8pLywvXig/OlxcXFwpLywvXig/OlxcfFxcXSkvLC9eKD86XFx8XFx8KS8sL14oPzpcXFtcXHwpLywvXig/OlxcfDopLywvXig/OjpcXHw6KS8sL14oPzo6XFx8KS8sL14oPzpcXHwpLywvXig/OlxceykvLC9eKD86XFx9KS8sL14oPzo6KS8sL14oPzooW1xcblxccl0pKS8sL14oPzooWyBcXHRdKSkvLC9eKD86JCkvLC9eKD86LikvXSxcbmNvbmRpdGlvbnM6IHtcInRpbWVcIjp7XCJydWxlc1wiOls4XSxcImluY2x1c2l2ZVwiOmZhbHNlfSxcInRpdGxlXCI6e1wicnVsZXNcIjpbNCw1LDZdLFwiaW5jbHVzaXZlXCI6ZmFsc2V9LFwiSU5JVElBTFwiOntcInJ1bGVzXCI6WzAsMSwyLDMsNyw5LDEwLDExLDEyLDEzLDE0LDE1LDE2LDE3LDE4LDE5LDIwLDIxLDIyLDIzLDI0LDI1LDI2LDI3LDI4LDI5LDMwLDMxLDMyLDMzLDM0LDM1LDM2LDM3LDM4LDM5XSxcImluY2x1c2l2ZVwiOnRydWV9fVxufSk7XG5yZXR1cm4gbGV4ZXI7XG59KSgpO1xucGFyc2VyLmxleGVyID0gbGV4ZXI7XG5mdW5jdGlvbiBQYXJzZXIgKCkge1xuICB0aGlzLnl5ID0ge307XG59XG5QYXJzZXIucHJvdG90eXBlID0gcGFyc2VyO3BhcnNlci5QYXJzZXIgPSBQYXJzZXI7XG5yZXR1cm4gbmV3IFBhcnNlcjtcbn0pKCk7XG5tb2R1bGUuZXhwb3J0cyA9IHBhcnNlcjtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc3JjL3BhcnNlci9wYXJzZXIuamlzb25cbiAqKiBtb2R1bGUgaWQgPSAxXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XHJcblxyXG4vKipcclxuICogVXRpbGl0eSBmdW5jdGlvbnNcclxuICogQG5hbWVzcGFjZVxyXG4gKi9cclxudmFyIHV0aWwgPSB7fTtcclxuXHJcbnZhciBJU19PQkpFQ1QgPSB7ICdmdW50aW9uJzogdHJ1ZSwgJ29iamVjdCc6IHRydWUgfTtcclxuZnVuY3Rpb24gaXNPYmplY3Qob2JqKSB7XHJcbiAgcmV0dXJuIElTX09CSkVDVFt0eXBlb2Ygb2JqXSAmJiAhIW9iajtcclxufVxyXG5cclxuLyoqXHJcbiAqIEZvciBlYWNoIG9iamVjdCBrZXkgYW5kIHZhbHVlLlxyXG4gKiBAZnVuY3Rpb24gdXRpbC5vYmpFYWNoXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmogLSBUaGUgb2JqZWN0IHRvIGJlIGl0ZXJhdGVkLlxyXG4gKiBAcGFyYW0ge3V0aWx+b2JqRWFjaENhbGxiYWNrfSBjYWxsYmFjayAtIFRoZSBjYWxsYmFjayBmb3IgZWFjaCBpdGVyYXRpb24uXHJcbiAqL1xyXG52YXIgb2JqRWFjaCA9XHJcbnV0aWwub2JqRWFjaCA9IGZ1bmN0aW9uIChvYmosIGNhbGxiYWNrKSB7XHJcbiAgaWYgKGlzT2JqZWN0KG9iaikpIHtcclxuICAgIE9iamVjdC5rZXlzKG9iaikuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XHJcbiAgICAgIGNhbGxiYWNrKG9ialtrZXldLCBrZXkpO1xyXG4gICAgfSk7XHJcbiAgfVxyXG59O1xyXG5cclxuLyoqXHJcbiAqIENhbGxiYWNrIHRoYXQgd2lsbCBiZSBjYWxsZWQgZm9yIGVhY2ggaXRlcmF0aW9uIGluIHtAbGluayB1dGlsLm9iakVhY2h9LlxyXG4gKiBAY2FsbGJhY2sgdXRpbH5vYmpFYWNoQ2FsbGJhY2tcclxuICogQHBhcmFtIHsqfSB2YWx1ZSAtIFZhbHVlIG9mIHRoZSBjdXJyZW50IHByb3BlcnR5LlxyXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IC0gS2V5IG9mIHRoZSBjdXJyZW50IHByb3BlcnR5LlxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBVdGlsaXR5IG1ldGhvZCwgZXh0ZW5kIGBvYmpgIHdpdGggYGV4dGAuXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqIC0gdGFyZ2V0IG9iamVjdCB0byBiZSBleHRlbmRlZC5cclxuICogQHBhcmFtIHtPYmplY3R9IGV4dCAtIHRoZSBleHRlbnNpb24gb2JqZWN0LlxyXG4gKiBAcmV0dXJuIHtPYmplY3R9IFRoZSB0YXJnZXQgb2JqZWN0LlxyXG4gKi9cclxudXRpbC5leHRlbmQgPSBmdW5jdGlvbihvYmosIGV4dCkge1xyXG4gIG9iakVhY2goZXh0LCBmdW5jdGlvbiAodmFsLCBrZXkpIHsgb2JqW2tleV0gPSB2YWw7IH0pO1xyXG4gIHJldHVybiBvYmo7XHJcbn07XHJcblxyXG4vKipcclxuICogVXRpbGl0eSBtZXRob2QsIGNoZWNraW5nIGlmIGBhYCBhbmQgYGJgIGlzIGNsb3NlICplbm9uZ2gqLlxyXG4gKiBVc2VmdWwgdG8gc2ltdWxhdGUgdGhlIGZsb2F0aW5nIG51bWJlciBlcXVhbGl0eSBjaGVjay5cclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBhIC0gYSBudW1iZXIuXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBiIC0gYW5vdGhlciBudW1iZXIuXHJcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFdldGhlciBgYWAgYW5kIGBiYCBpcyBjbG9zZS5cclxuICovXHJcbnV0aWwubmVhciA9IGZ1bmN0aW9uIChhLCBiKSB7XHJcbiAgcmV0dXJuIE1hdGguYWJzKGEgLSBiKSA8IDAuMDAwMDE7XHJcbn07XHJcblxyXG5cclxuZnVuY3Rpb24gaXNBY2Nlc3NvclByb3BlcnR5KHZhbHVlKSB7XHJcbiAgcmV0dXJuIGlzT2JqZWN0KHZhbHVlKSAmJlxyXG4gICAgICAgICh0eXBlb2YgdmFsdWUuZ2V0ID09PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiB2YWx1ZS5zZXQgPT09ICdmdW5jdGlvbicpO1xyXG59XHJcblxyXG4vKipcclxuICogRGVmaW5lIEVTNSBnZXR0ZXIvc2V0dGVyIHByb3BlcnRpZXNcclxuICogQHBhcmFtIHtPYmplY3R9IG9iaiAtIFRoZSBvYmplY3QgdG8gYmUgZGVmaW5lZC5cclxuICogQHBhcmFtIHtPYmplY3R9IHByb3BzIC0gRVM1IGdldHRlci9zZXR0ZXIgcHJvcGVydGllcy5cclxuICogRm9yIGV4YW1wbGU6XHJcbiAqIGBgYFxyXG4gKiB7XHJcbiAqICAgbmFtZToge1xyXG4gKiAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7Li4ufSxcclxuICogICAgIHNldDogZnVuY3Rpb24gKCkgey4uLn1cclxuICogICB9LFxyXG4gKiAgIGFnZToge1xyXG4gKiAgICAgIGdldDouLi5cclxuICogICB9XHJcbiAqIH1cclxuICogYGBgXHJcbiAqL1xyXG51dGlsLmRlZmluZVByb3BlcnRpZXMgPSBmdW5jdGlvbiAob2JqLCBwcm9wcykge1xyXG4gIG9iakVhY2gocHJvcHMsIGZ1bmN0aW9uICh2YWx1ZSwgcHJvcCkge1xyXG4gICAgdmFyIGRlc2NyaXB0b3I7XHJcbiAgICBpZiAoaXNBY2Nlc3NvclByb3BlcnR5KHZhbHVlKSkge1xyXG4gICAgICBkZXNjcmlwdG9yID0gdmFsdWU7XHJcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICBkZXNjcmlwdG9yID0geyB2YWx1ZTogdmFsdWUgfTtcclxuICAgIH0gZWxzZSBpZiAoaXNPYmplY3QodmFsdWUpICYmIHZhbHVlLmNvbnN0YW50KSB7XHJcbiAgICAgIGRlc2NyaXB0b3IgPSB7IHZhbHVlOiB2YWx1ZS5jb25zdGFudCB9O1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgZGVzY3JpcHRvciA9IHtcclxuICAgICAgICB2YWx1ZTogdmFsdWUsXHJcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZVxyXG4gICAgICB9O1xyXG4gICAgfVxyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwgcHJvcCwgZGVzY3JpcHRvcik7XHJcbiAgfSk7XHJcbn07XHJcblxyXG51dGlsLnRvSlNPTldpdGhEZWZhdWx0ID0gdHJ1ZTtcclxuXHJcbnV0aWwubWFrZVRvSlNPTiA9IGZ1bmN0aW9uICh2YWx1ZXMsIGVsTmFtZSkge1xyXG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XHJcbiAgICBpZiAodGhpcy5pc0VtcHR5KSB7IHJldHVybjsgfVxyXG5cclxuICAgIHZhclxyXG4gICAgICB0aGF0ID0gdGhpcyxcclxuICAgICAgcmVzdWx0ID0ge307XHJcblxyXG4gICAgb2JqRWFjaCh2YWx1ZXMsIGZ1bmN0aW9uIChkZWZhdWx0VmFsdWUsIHByb3ApIHtcclxuICAgICAgaWYgKHV0aWwudG9KU09OV2l0aERlZmF1bHQgfHwgdGhhdFtwcm9wXSAhPT0gZGVmYXVsdFZhbHVlKSB7XHJcbiAgICAgICAgcmVzdWx0W3Byb3BdID0gdGhhdFtwcm9wXTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICBpZiAoIWVsTmFtZSkgeyByZXR1cm4gcmVzdWx0OyB9XHJcblxyXG4gICAgdmFyIHJlcyA9IHt9O1xyXG4gICAgcmVzW2VsTmFtZV0gPSByZXN1bHQ7XHJcbiAgICByZXR1cm4gcmVzO1xyXG4gIH07XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHV0aWw7XHJcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zcmMvdXRpbC5qc1xuICoqIG1vZHVsZSBpZCA9IDJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciB1dGlsID0gcmVxdWlyZSgnLi4vdXRpbCcpO1xyXG52YXIgU2NvcmVIZWFkID0gcmVxdWlyZSgnLi9TY29yZUhlYWQnKTtcclxudmFyIFBhcnR3aXNlUGFydHMgPSByZXF1aXJlKCcuL1BhcnR3aXNlUGFydHMnKTtcclxudmFyIFRpbWV3aXNlTWVhc3VyZXMgPSByZXF1aXJlKCcuL1RpbWV3aXNlTWVhc3VyZXMnKTtcclxuXHJcbi8qKlxyXG4gKiBAY2xhc3NcclxuICogQHBhcmFtIHtPYmplY3R9IHNjb3JlIC0gcGxhaW4gc2NvcmUgb2JqZWN0LlxyXG4gKiBAbWl4ZXMgUGxheWVyTWl4aW5cclxuICovXHJcbmZ1bmN0aW9uIFNjb3JlKHNjb3JlKSB7XHJcbiAgdXRpbC5leHRlbmQodGhpcywgc2NvcmUpO1xyXG59XHJcblxyXG51dGlsLmRlZmluZVByb3BlcnRpZXMoU2NvcmUucHJvdG90eXBlLFxyXG4vKiogQGxlbmRzIFNjb3JlIyAqL1xyXG57XHJcbiAgLyoqXHJcbiAgICogSGVhZCBvZiB0aGUgc2NvcmUuXHJcbiAgICogQHR5cGUge1Njb3JlSGVhZH1cclxuICAgKi9cclxuICBoZWFkOiB7XHJcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgcmV0dXJuIHRoaXMuX2hlYWQgfHwgKHRoaXMuX2hlYWQgPSBuZXcgU2NvcmVIZWFkKCkpO1xyXG4gICAgfSxcclxuICAgIHNldDogZnVuY3Rpb24gKGhlYWQpIHtcclxuICAgICAgdGhpcy5faGVhZCA9IG5ldyBTY29yZUhlYWQoaGVhZCk7XHJcbiAgICB9XHJcbiAgfSxcclxuXHJcbiAgLyoqXHJcbiAgICogUGFydHdpc2UgcGFydHMuXHJcbiAgICogLSAoR2V0dGVyKVxyXG4gICAqIC0gKFNldHRlcilcclxuICAgKiBAdHlwZSB7UGFydHdpc2VQYXJ0c31cclxuICAgKi9cclxuICBwYXJ0czoge1xyXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLl9wYXJ0cyB8fFxyXG4gICAgICAgICAgICAodGhpcy5fcGFydHMgPSBuZXcgUGFydHdpc2VQYXJ0cyh0aGlzKSk7XHJcbiAgICB9LFxyXG4gICAgc2V0OiBmdW5jdGlvbiAocGFydHMpIHtcclxuICAgICAgdGhpcy5wYXJ0cy5yZW1vdmVBbGwoKTtcclxuICAgICAgdGhpcy5wYXJ0cy5hZGRQYXJ0cyhwYXJ0cyk7XHJcbiAgICAgIHRoaXMubWVhc3VyZXMuZnJvbVBhcnR3aXNlKCk7XHJcbiAgICB9XHJcbiAgfSxcclxuXHJcbiAgLyoqXHJcbiAgICogVGltZXdpc2UgbWVhc3VyZXMsIGdlbmVyYXRlZCBieSB0aGUgaW5pdGlhbGl6ZSBmdW5jdGlvbi5cclxuICAgKiBAdHlwZSB7VGltZXdpc2VNZWFzdXJlc31cclxuICAgKiBAcmVhZG9ubHlcclxuICAgKi9cclxuICBtZWFzdXJlczoge1xyXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLl9tZWFzdXJlcyB8fFxyXG4gICAgICAgICAgICAodGhpcy5fbWVhc3VyZXMgPSBuZXcgVGltZXdpc2VNZWFzdXJlcyh0aGlzKSk7XHJcbiAgICB9XHJcbiAgfSxcclxuXHJcbiAgLyoqXHJcbiAgICogQSBjZWxsIGlzIGlkZW50aWNhbGx5IGEgbWVhc3VyZSBpbiBhIHBhcnQgb3IgYSBwYXJ0IGluIGEgbWVhc3VyZS5cclxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufVxyXG4gICAqL1xyXG4gIHdhbGtDZWxsczogZnVuY3Rpb24gKGNhbGxiYWNrKSB7XHJcbiAgICB0aGlzLnBhcnRzLmZvckVhY2goZnVuY3Rpb24gKHBhcnQsIHApIHtcclxuICAgICAgcGFydC5tZWFzdXJlcy5mb3JFYWNoKGZ1bmN0aW9uIChjZWxsLCBtKSB7XHJcbiAgICAgICAgY2FsbGJhY2soY2VsbCwgbSwgcCk7XHJcbiAgICAgIH0pO1xyXG4gICAgfSk7XHJcbiAgfSxcclxuXHJcbiAgLyoqXHJcbiAgICogV2FsayBlYWNoIG11c2ljIGRhdGEuXHJcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcclxuICAgKi9cclxuICB3YWxrTXVzaWNEYXRhOiBmdW5jdGlvbiAoY2FsbGJhY2spIHtcclxuICAgIHRoaXMud2Fsa0NlbGxzKGZ1bmN0aW9uIChjZWxsLCBtLCBwKSB7XHJcbiAgICAgIGNlbGwuZGF0YS5mb3JFYWNoKGZ1bmN0aW9uIChkYXRhLCBkKSB7XHJcbiAgICAgICAgY2FsbGJhY2soZGF0YSwgZCwgbSwgcCk7XHJcbiAgICAgIH0pO1xyXG4gICAgfSk7XHJcbiAgfSxcclxuXHJcbiAgLyoqXHJcbiAgICogQ29udmVydCBzY29yZSB0byBzdHJpbmcuXHJcbiAgICogQHJldHVybiB7c3RyaW5nfSBNdXNqZSBzb3VyY2UgY29kZS5cclxuICAgKi9cclxuICB0b1N0cmluZzogZnVuY3Rpb24gKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuaGVhZCArIHRoaXMucGFydHMubWFwKGZ1bmN0aW9uIChwYXJ0KSB7XHJcbiAgICAgIHJldHVybiBwYXJ0LnRvU3RyaW5nKCk7XHJcbiAgICB9KS5qb2luKCdcXG5cXG4nKTtcclxuICB9LFxyXG5cclxuICAvKipcclxuICAgKiBDdXN0b20gdG9KU09OIG1ldGhvZC5cclxuICAgKiBAbWV0aG9kXHJcbiAgICogQHJldHVybiB7T2JqZWN0fVxyXG4gICAqL1xyXG4gIHRvSlNPTjogdXRpbC5tYWtlVG9KU09OKHtcclxuICAgIGhlYWQ6IHVuZGVmaW5lZCxcclxuICAgIHBhcnRzOiB1bmRlZmluZWRcclxuICB9KVxyXG59KTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gU2NvcmU7XHJcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zcmMvbW9kZWwvU2NvcmUuanNcbiAqKiBtb2R1bGUgaWQgPSAzXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlsID0gcmVxdWlyZSgnLi4vdXRpbCcpO1xuXG4vKipcbiAqIENvbnN0cnVjdCBoZWFkIG9mIHRoZSBzY29yZS5cbiAqIEBjbGFzc1xuICogQHBhcmFtIHtPYmplY3R9IGhlYWRcbiAqL1xuZnVuY3Rpb24gU2NvcmVIZWFkKGhlYWQpIHtcbiAgdXRpbC5leHRlbmQodGhpcywgaGVhZCk7XG59XG5cbnV0aWwuZGVmaW5lUHJvcGVydGllcyhTY29yZUhlYWQucHJvdG90eXBlLFxuLyoqIEBsZW5kcyBTY29yZUhlYWQjICovXG57XG4gIC8qKlxuICAgKiBUaXRsZSBvZiB0aGUgc2NvcmUuXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqIEBkZWZhdWx0ICcnXG4gICAqL1xuICB0aXRsZTogJycsXG5cbiAgLyoqXG4gICAqIFN1YnRpdGxlIG9mIHRoZSBzY29yZS5cbiAgICogQHR5cGUge3N0cmluZ31cbiAgICogQGRlZmF1bHQgJydcbiAgICovXG4gIHN1YnRpdGxlOiAnJyxcblxuICAvKipcbiAgICogU3Vic3VidGl0bGUgb2YgdGhlIHNjb3JlLlxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKiBAZGVmYXVsdCAnJ1xuICAgKi9cbiAgc3Vic3VidGl0bGU6ICcnLFxuXG4gIC8qKlxuICAgKiBDb21wb3NlciBvZiB0aGUgc2NvcmUuXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICBjb21wb3NlcjogdW5kZWZpbmVkLFxuXG4gIC8qKlxuICAgKiBBcnJhbmdlciBvZiB0aGUgc2NvcmUuXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICBhcnJhbmdlcjogdW5kZWZpbmVkLFxuXG4gIC8qKlxuICAgKiBMeXJpY2lzdCBvZiB0aGUgc2NvcmUuXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICBseXJpY2lzdDogdW5kZWZpbmVkLFxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiB0aGUgc2NvcmUgaGVhZCBpcyBlbXB0eS5cbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqIEByZWFkb25seVxuICAgKi9cbiAgaXNFbXB0eToge1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuICF0aGlzLnRpdGxlICYmICF0aGlzLnN1YnRpdGxlICYmICF0aGlzLnN1YnN1YnRpdGxlICYmXG4gICAgICAgICAgICAgIXRoaXMuY29tcG9zZXIgJiYgIXRoaXMuYXJyYW5nZXIgJiYgIXRoaXMubHlyaWNpc3Q7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBDb252ZXJ0IHNjb3JlIGhlYWQgdG8gc3RyaW5nLlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBjb252ZXJ0ZWQgbXVzamUgaGVhZCBzb3VyY2UgY29kZS5cbiAgICovXG4gIHRvU3RyaW5nOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuICcnICsgKHRoaXMudGl0bGUgPyAoJzw8JyArIHRoaXMudGl0bGUgKyAnPj4nKSA6ICcnKSArXG4gICAgICAgICAgICAodGhpcy5jb21wb3NlciB8fCAnJykgK1xuICAgICAgICAgICAgJ1xcbic7XG4gIH0sXG5cbiAgdG9KU09OOiB1dGlsLm1ha2VUb0pTT04oe1xuICAgIHRpdGxlOiB1bmRlZmluZWQsXG4gICAgc3VidGl0bGU6IHVuZGVmaW5lZCxcbiAgICBzdWJzdWJ0aXRsZTogdW5kZWZpbmVkLFxuICAgIGNvbXBvc2VyOiB1bmRlZmluZWQsXG4gICAgbHlyaWNpc3Q6IHVuZGVmaW5lZFxuICB9KVxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gU2NvcmVIZWFkO1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NyYy9tb2RlbC9TY29yZUhlYWQuanNcbiAqKiBtb2R1bGUgaWQgPSA0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XHJcblxyXG52YXIgdXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwnKTtcclxudmFyIFBhcnR3aXNlUGFydCA9IHJlcXVpcmUoJy4vUGFydHdpc2VQYXJ0Jyk7XHJcblxyXG4vKipcclxuICogQ29uc3RydWN0IHBhcnR3aXNlIHNjb3JlIHBhcnRzLlxyXG4gKiBAY2xhc3NcclxuICogQGNsYXNzZGVzYyBQYXJ0d2lzZSBzY29yZSBwYXJ0cy5cclxuICogQHBhcmFtIHNjb3JlIHtTY29yZX1cclxuICogQGF1Z21lbnRzIHtBcnJheX1cclxuICovXHJcbmZ1bmN0aW9uIFBhcnR3aXNlUGFydHMoc2NvcmUpIHtcclxuICB2YXIgcGFydHMgPSBbXTtcclxuICBwYXJ0cy5fc2NvcmUgPSBzY29yZTtcclxuICB1dGlsLmRlZmluZVByb3BlcnRpZXMocGFydHMsIHByb3BlcnRpZXMpO1xyXG4gIHJldHVybiBwYXJ0cztcclxufVxyXG5cclxuLyoqIEBsZW5kcyBQYXJ0d2lzZVBhcnRzIyAqL1xyXG52YXIgcHJvcGVydGllcyA9IHtcclxuXHJcbiAgLyoqXHJcbiAgICogUmVmZXJlbmNlIHRvIHRoZSBwYXJlbnQgc2NvcmUuXHJcbiAgICogQHR5cGUge1Njb3JlfVxyXG4gICAqIEByZWFkb25seVxyXG4gICAqL1xyXG4gIHNjb3JlOiB7XHJcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgcmV0dXJuIHRoaXMuX3Njb3JlO1xyXG4gICAgfVxyXG4gIH0sXHJcblxyXG4gIC8qKlxyXG4gICAqIEFkZCBwYXJ0cy5cclxuICAgKiBAcGFyYW0ge09iamVjdH1cclxuICAgKi9cclxuICBhZGRQYXJ0czogZnVuY3Rpb24gKHBhcnRzKSB7XHJcbiAgICB2YXIgdGhhdCA9IHRoaXM7XHJcbiAgICBwYXJ0cy5mb3JFYWNoKGZ1bmN0aW9uIChwYXJ0KSB7XHJcbiAgICAgIHRoYXQuYXBwZW5kKHBhcnQpO1xyXG4gICAgfSk7XHJcbiAgfSxcclxuXHJcbiAgLyoqXHJcbiAgICogQXBwZW5kIGEgcGFydHdpc2UgcGFydC5cclxuICAgKiBAcGFyYW0ge09iamVjdH0gcGFydCAtIFBsYWluIHBhcnR3aXNlIHBhcnQgb2JqZWN0LlxyXG4gICAqIEBvdmVycmlkZVxyXG4gICAqL1xyXG4gIGFwcGVuZDogZnVuY3Rpb24gKHBhcnQpIHtcclxuICAgIHZhciBpbmRleCA9IHRoaXMubGVuZ3RoO1xyXG4gICAgdmFyIG11c2plUGFydCA9IG5ldyBQYXJ0d2lzZVBhcnQoaW5kZXgsIHRoaXMpO1xyXG4gICAgdGhpcy5wdXNoKG11c2plUGFydCk7XHJcbiAgICBtdXNqZVBhcnQubWVhc3VyZXMgPSBwYXJ0Lm1lYXN1cmVzO1xyXG4gIH0sXHJcblxyXG4gIC8qKlxyXG4gICAqIFJlbW92ZSBhbGwgcGFydHMuXHJcbiAgICovXHJcbiAgcmVtb3ZlQWxsOiBmdW5jdGlvbiAoKSB7XHJcbiAgICB0aGlzLmxlbmd0aCA9IDA7XHJcbiAgfVxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBQYXJ0d2lzZVBhcnRzO1xyXG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc3JjL21vZGVsL1BhcnR3aXNlUGFydHMuanNcbiAqKiBtb2R1bGUgaWQgPSA1XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlsID0gcmVxdWlyZSgnLi4vdXRpbCcpO1xudmFyIENlbGwgPSByZXF1aXJlKCcuL0NlbGwnKTtcblxuLyoqXG4gKiBAY2xhc3NcbiAqIEBwYXJhbSBwYXJ0IHtPYmplY3R9XG4gKiBAcGFyYW0gaW5kZXgge251bWJlcn0gLSBJbmRleCBvZiB0aGlzIHBhcnQgaW4gdGhlIHBhcnRzLlxuICogQHBhcmFtIHBhcnRzIHtQYXJ0d2lzZVBhcnRzfVxuICovXG5mdW5jdGlvbiBQYXJ0d2lzZVBhcnQoaW5kZXgsIHBhcnRzKSB7XG4gIHRoaXMuX2luZGV4ID0gaW5kZXg7XG4gIHRoaXMuX3BhcnRzID0gcGFydHM7XG59XG5cbnV0aWwuZGVmaW5lUHJvcGVydGllcyhQYXJ0d2lzZVBhcnQucHJvdG90eXBlLFxuLyoqIEBsZW5kcyBQYXJ0d2lzZVBhcnQjICovXG57XG4gIC8vIGhlYWQ6IHsgJHJlZjogJyMvb2JqZWN0cy9QYXJ0SGVhZCcgfSxcblxuICAvKipcbiAgICogUmVmZXJlbmNlIHRvIHRoZSBwYXJlbnQgcGFydHMgaW5zdGFuY2UuXG4gICAqIEB0eXBlIHtQYXJ0d2lzZVBhcnRzfVxuICAgKiBAcmVhZG9ubHlcbiAgICovXG4gIHBhcnRzOiB7XG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcGFydHM7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBNZWFzdXJlIGluIGEgcGFydHdpc2UgcGFydCBpcyBjZWxscy5cbiAgICogQHR5cGUge0FycmF5LjxDZWxsPn1cbiAgICovXG4gIG1lYXN1cmVzOiB7XG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fbWVhc3VyZXMgfHwgKHRoaXMuX21lYXN1cmVzID0gW10pO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiAobWVhc3VyZXMpIHtcbiAgICAgIHZhclxuICAgICAgICBwID0gdGhpcy5faW5kZXgsXG4gICAgICAgIHNjb3JlID0gdGhpcy5wYXJ0cy5zY29yZSxcbiAgICAgICAgbWVhID0gdGhpcy5fbWVhc3VyZXMgPSBbXTtcblxuICAgICAgbWVhc3VyZXMuZm9yRWFjaChmdW5jdGlvbiAoY2VsbCwgbSkge1xuICAgICAgICBtZWEucHVzaChuZXcgQ2VsbChjZWxsLCBtLCBwLCBzY29yZSkpO1xuICAgICAgfSk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBDb252ZXJ0IGEgcGFydHdpc2UgcGFydCB0byBzdGluZy5cbiAgICogQHJldHVybiB7c3RyaW5nfSBNdXNqZSBwYXJ0d2lzZSBwYXJ0IHNvdXJjZSBjb2RlLlxuICAgKi9cbiAgdG9TdHJpbmc6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5tZWFzdXJlcy5tYXAoZnVuY3Rpb24gKGNlbGwpIHtcbiAgICAgIHJldHVybiBjZWxsO1xuICAgIH0pLmpvaW4oJyAnKTtcbiAgfSxcblxuICAvKipcbiAgICogQ3VzdG9tIHRvSlNPTiBtZXRob2QuXG4gICAqIEByZXR1cm4ge09iamVjdH1cbiAgICovXG4gIHRvSlNPTjogdXRpbC5tYWtlVG9KU09OKHtcbiAgICBtZWFzdXJlczogdW5kZWZpbmVkXG4gIH0pXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBQYXJ0d2lzZVBhcnQ7XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc3JjL21vZGVsL1BhcnR3aXNlUGFydC5qc1xuICoqIG1vZHVsZSBpZCA9IDZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsJyk7XG52YXIgbmVhciA9IHV0aWwubmVhcjtcbnZhciBCZWFtID0gcmVxdWlyZSgnLi9CZWFtJyk7XG52YXIgQ2xhc3NlcyA9IHtcbiAgdGltZTogIHJlcXVpcmUoJy4vVGltZScpLFxuICBiYXI6ICAgcmVxdWlyZSgnLi9CYXInKSxcbiAgbm90ZTogIHJlcXVpcmUoJy4vTm90ZScpLFxuICByZXN0OiAgcmVxdWlyZSgnLi9SZXN0JyksXG4gIGNob3JkOiByZXF1aXJlKCcuL0Nob3JkJyksXG4gIHZvaWNlOiByZXF1aXJlKCcuL1ZvaWNlJylcbn07XG5cbi8qKlxuICogQ29uc3RydWN0IGEgY2VsbC5cbiAqIENlbGwgaXMgZWl0aGVyIGEgbWVhc3VyZSBpbiBhIHBhcnR3aXNlIHBhcnQsIG9yXG4gKiBhIHBhcnQgaW4gYSB0aW1ld2lzZSBtZWFzdXJlLlxuICogQGNsYXNzXG4gKiBAcGFyYW0gY2VsbCB7T2JqZWN0fVxuICogQHBhcmFtIG1JbmRleCB7bnVtYmVyfSAtIE1lYXN1cmUgaW5kZXggb2YgdGhpcyBjZWxsLlxuICogQHBhcmFtIHBJbmRleCB7bnVtYmVyfSAtIFBhcnQgaW5kZXggb2YgdGhpcyBjZWxsLlxuICogQG1peGVzIENlbGxMYXlvdXRcbiAqL1xuZnVuY3Rpb24gQ2VsbChjZWxsLCBtSW5kZXgsIHBJbmRleCwgc2NvcmUpIHtcbiAgdGhpcy5fbUluZGV4ID0gbUluZGV4O1xuICB0aGlzLl9wSW5kZXggPSBwSW5kZXg7XG4gIHRoaXMuX3Njb3JlID0gc2NvcmU7XG4gIHV0aWwuZXh0ZW5kKHRoaXMsIGNlbGwpO1xuICBtYWtlQmVhbXModGhpcywgMSk7XG59XG5cbnV0aWwuZGVmaW5lUHJvcGVydGllcyhDZWxsLnByb3RvdHlwZSxcbi8qKiBAbGVuZHMgbXVzamUuQ2VsbCMgKi9cbntcbiAgLyoqXG4gICAqIFJlZmVyZW5jZSB0byB0aGUgcm9vdCBzY29yZSBpbnN0YW5jZS5cbiAgICogQHR5cGUge1Njb3JlfVxuICAgKiBAcmVhZG9ubHlcbiAgICovXG4gIHNjb3JlOiB7XG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fc2NvcmU7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBNdXNpYyBkYXRhXG4gICAqIEB0eXBlIHtBcnJheS48TXVzaWNEYXRhTWl4aW4+fVxuICAgKi9cbiAgZGF0YToge1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2RhdGEgfHwgKHRoaXMuX2RhdGEgPSBbXSk7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgICB0aGF0Lmxlbmd0aCA9IDA7XG4gICAgICBkYXRhLmZvckVhY2goZnVuY3Rpb24gKGRhdHVtKSB7XG4gICAgICAgIHRoYXQuYXBwZW5kKGRhdHVtKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogUmVmZXJlbmNlIHRvIHRoZSBwYXJlbnQgbWVhc3VyZXMuXG4gICAqIEB0eXBlIHtUaW1ld2lzZU1lYXN1cmVzfVxuICAgKiBAcmVhZG9ubHlcbiAgICovXG4gIG1lYXN1cmVzOiB7XG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5zY29yZS5tZWFzdXJlcztcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlZmVyZW5jZSB0byB0aGUgcGFyZW50IG1lYXN1cmUuXG4gICAqIEB0eXBlIHtUaW1ld2lzZU1lYXN1cmV9XG4gICAqIEByZWFkb25seVxuICAgKi9cbiAgbWVhc3VyZToge1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMubWVhc3VyZXNbdGhpcy5fbUluZGV4XTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlZmVyZW5jZSB0byB0aGUgcGFyZW50IHBhcnRzLlxuICAgKiBAdHlwZSB7UGFydHdpc2VQYXJ0c31cbiAgICogQHJlYWRvbmx5XG4gICAqL1xuICBwYXJ0czoge1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuc2NvcmUucGFydHM7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBSZWZlcmVuY2UgdG8gdGhlIHBhcmVudCBwYXJ0LlxuICAgKiBAdHlwZSB7UGFydHdpc2VQYXJ0fVxuICAgKiBAcmVhZG9ubHlcbiAgICovXG4gIHBhcnQ6IHtcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLnBhcnRzW3RoaXMuX3BJbmRleF07XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBQcmV2aW91cyBjZWxsIGluIHRoZSBwYXJ0LlxuICAgKiBAdHlwZSB7Q2VsbHx1bmRlZmluZWR9XG4gICAqIEByZWFkb25seVxuICAgKi9cbiAgcHJldjoge1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMucGFydC5tZWFzdXJlc1t0aGlzLl9tSW5kZXggLSAxXTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIE5leHQgY2VsbCBpbiB0aGUgcGFydC5cbiAgICogQHR5cGUge0NlbGx8dW5kZWZpbmVkfVxuICAgKiBAcmVhZG9ubHlcbiAgICovXG4gIG5leHQ6IHtcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLnBhcnQubWVhc3VyZXNbdGhpcy5fbUluZGV4ICsgMV07XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBUaGUgZmlyc3QgbXVzaWMgZGF0YSBpbiB0aGUgY2VsbC5cbiAgICogQHR5cGUge011c2ljRGF0YU1peGlufHVuZGVmaW5lZH1cbiAgICogQHJlYWRvbmx5XG4gICAqL1xuICBmaXJzdERhdGE6IHtcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLmRhdGFbMF07XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBUaGUgbGFzdCBtdXNpYyBkYXRhIGluIHRoZSBjZWxsLlxuICAgKiBAdHlwZSB7TXVzaWNEYXRhTWl4aW58dW5kZWZpbmVkfVxuICAgKiBAcmVhZG9ubHlcbiAgICovXG4gIGxhc3REYXRhOiB7XG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5kYXRhW3RoaXMuZGF0YS5sZW5ndGggLSAxXTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIFRoZSBsZWZ0IGJhciBvZiB0aGlzIGNlbGwuXG4gICAqIEB0eXBlIHtCYXJ8dW5kZWZpbmVkfVxuICAgKiBAcmVhZG9ubHlcbiAgICovXG4gIGJhckxlZnQ6IHtcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBmaXJzdERhdGEgPSB0aGlzLmZpcnN0RGF0YTtcblxuICAgICAgaWYgKGZpcnN0RGF0YSAmJiBmaXJzdERhdGEuJHR5cGUgPT09ICdiYXInKSB7XG4gICAgICAgIHJldHVybiBmaXJzdERhdGE7XG4gICAgICB9XG5cbiAgICAgIC8vIFRha2UgZnJvbSB0aGUgcHJldmlvdXMgbWVhc3VyZS5cbiAgICAgIHZhciBwcmV2Q2VsbCA9IHRoaXMucHJldjtcbiAgICAgIGlmIChwcmV2Q2VsbCkge1xuICAgICAgICByZXR1cm4gcHJldkNlbGwuYmFyUmlnaHQ7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBUaGUgcmlnaHQgYmFyIG9mIHRoaXMgY2VsbC5cbiAgICogQHR5cGUge0Jhcnx1bmRlZmluZWR9XG4gICAqIEByZWFkb25seVxuICAgKi9cbiAgYmFyUmlnaHQ6IHtcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBsYXN0RGF0YSA9IHRoaXMubGFzdERhdGE7XG4gICAgICBpZiAobGFzdERhdGEgJiYgbGFzdERhdGEuJHR5cGUgPT09ICdiYXInKSB7XG4gICAgICAgIHJldHVybiBsYXN0RGF0YTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEFwcGVuZCBhIG11c2ljIGRhdGEgdG8gdGhlIGNlbGwuXG4gICAqIEBwYXJhbSAge09iamVjdH0gbXVzaWNEYXRhIC0gTXVzaWMgZGF0YVxuICAgKi9cbiAgYXBwZW5kOiBmdW5jdGlvbiAobXVzaWNEYXRhKSB7XG4gICAgdmFyIHR5cGUgPSBPYmplY3Qua2V5cyhtdXNpY0RhdGEpWzBdOyAvLyBtdXNpY0RhdGEgaGFzIG9ubHkgb25lIGtleVxuICAgIHZhciBpbnN0YW5jZSA9IG5ldyBDbGFzc2VzW3R5cGVdKG11c2ljRGF0YVt0eXBlXSk7XG4gICAgaW5zdGFuY2UuX2NlbGwgPSB0aGlzO1xuICAgIGluc3RhbmNlLl9pbmRleCA9IHRoaXMuZGF0YS5sZW5ndGg7XG4gICAgdGhpcy5kYXRhLnB1c2goaW5zdGFuY2UpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBDb252ZXJ0IGNlbGwgdG8gc3RyaW5nLlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9IENvbnZlcnRlZCBjZWxsIGluIG11c2plIHNvdXJjZSBjb2RlLlxuICAgKi9cbiAgdG9TdHJpbmc6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5kYXRhLm1hcChmdW5jdGlvbiAobXVzaWNEYXRhKSB7XG4gICAgICByZXR1cm4gbXVzaWNEYXRhLnRvU3RyaW5nKCk7XG4gICAgfSkuam9pbignICcpO1xuICB9LFxuXG4gIHRvSlNPTjogdXRpbC5tYWtlVG9KU09OKHtcbiAgICBkYXRhOiB1bmRlZmluZWRcbiAgfSlcbn0pO1xuXG5cbi8qKlxuICogTWFrZSBiZWFtcyBhdXRvbWF0aWNhbGx5IGluIGdyb3VwIGJ5IHRoZSBncm91cER1ci5cbiAqIEBwYXJhbSB7bnVtYmVyfSBncm91cER1ciAtIER1cmF0aW9uIG9mIGEgYmVhbSBncm91cCBpbiBxdWFydGVyLlxuICovXG5mdW5jdGlvbiBtYWtlQmVhbXModGhhdCwgZ3JvdXBEdXIpIHtcblxuICBnZXRCZWFtR3JvdXBzKHRoYXQsIGdyb3VwRHVyKS5mb3JFYWNoKGZ1bmN0aW9uIChncm91cCkge1xuICAgIHZhciBiZWFtTGV2ZWwgPSB7fTsgICAvLyBpdCBzdGFydHMgZnJvbSAwLCB3aGlsZSB1bmRlcmJhciBzdGFydHMgZnJvbSAxXG5cbiAgICBmdW5jdGlvbiBuZXh0SGFzU2FtZUJlYW1sZXZlbChpbmRleCwgbGV2ZWwpIHtcbiAgICAgIHZhciBuZXh0ID0gZ3JvdXBbaW5kZXggKyAxXTtcbiAgICAgIHJldHVybiBuZXh0ICYmIG5leHQuZHVyYXRpb24udW5kZXJiYXIgPiBsZXZlbDtcbiAgICB9XG5cbiAgICBncm91cC5mb3JFYWNoKGZ1bmN0aW9uKGRhdGEsIGkpIHtcbiAgICAgIHZhciB1bmRlcmJhciA9IGRhdGEuZHVyYXRpb24udW5kZXJiYXI7XG4gICAgICB2YXIgbGV2ZWw7XG5cbiAgICAgIGZvciAobGV2ZWwgPSAwOyBsZXZlbCA8IHVuZGVyYmFyOyBsZXZlbCsrKSB7XG4gICAgICAgIGlmIChuZXh0SGFzU2FtZUJlYW1sZXZlbChpLCBsZXZlbCkpIHtcblxuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIEJlYW1zIG9mIHRoZSBub3RlLlxuICAgICAgICAgICAqIC0gUHJvZHVjZWQgYnkgdGhlIHtAbGluayBDZWxsI21ha2VCZWFtc30gbWV0aG9kLlxuICAgICAgICAgICAqIC0gVGhlIGFib3ZlIG1ldGhvZCBpcyBjYWxsIGluIHtAbGluayBTY29yZSNwcmVwYXJlQ2VsbHN9LlxuICAgICAgICAgICAqIEBtZW1iZXJvZiBOb3RlI1xuICAgICAgICAgICAqIEBhbGlhcyBiZWFtc1xuICAgICAgICAgICAqIEB0eXBlIHtBcnJheS48QmVhbT59XG4gICAgICAgICAgICovXG4gICAgICAgICAgZGF0YS5iZWFtcyA9IGRhdGEuYmVhbXMgfHwgW107XG5cbiAgICAgICAgICBpZiAoYmVhbUxldmVsW2xldmVsXSkge1xuICAgICAgICAgICAgZGF0YS5iZWFtc1tsZXZlbF0gPSBuZXcgQmVhbSgnY29udGludWUnLCBsZXZlbCwgZGF0YSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGJlYW1MZXZlbFtsZXZlbF0gPSB0cnVlO1xuICAgICAgICAgICAgZGF0YS5iZWFtc1tsZXZlbF0gPSBuZXcgQmVhbSgnYmVnaW4nLCBsZXZlbCwgZGF0YSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChiZWFtTGV2ZWxbbGV2ZWxdKSB7XG4gICAgICAgICAgICBkYXRhLmJlYW1zID0gZGF0YS5iZWFtcyB8fCBbXTtcbiAgICAgICAgICAgIGRhdGEuYmVhbXNbbGV2ZWxdID0gbmV3IEJlYW0oJ2VuZCcsIGxldmVsLCBkYXRhKTtcbiAgICAgICAgICAgIGRlbGV0ZSBiZWFtTGV2ZWxbbGV2ZWxdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gZ2V0QmVhbUdyb3Vwcyh0aGF0LCBncm91cER1cikge1xuICB2YXIgY291bnRlciA9IDAsIGdyb3VwID0gW10sIGdyb3VwcyA9IFtdO1xuXG4gIGZ1bmN0aW9uIGluR3JvdXAoKSB7XG4gICAgcmV0dXJuIGNvdW50ZXIgPCBncm91cER1ciAmJiAhbmVhcihjb3VudGVyLCBncm91cER1cik7XG4gIH1cbiAgZnVuY3Rpb24gcHV0R3JvdXAoKSB7XG4gICAgaWYgKGdyb3VwLmxlbmd0aCA+IDEpIHsgZ3JvdXBzLnB1c2goZ3JvdXApOyB9XG4gICAgZ3JvdXAgPSBbXTtcbiAgfVxuXG4gIHRoYXQuZGF0YS5mb3JFYWNoKGZ1bmN0aW9uIChtdXNpY0RhdGEpIHtcbiAgICBpZiAobXVzaWNEYXRhLiR0eXBlICE9PSAnbm90ZScgJiYgbXVzaWNEYXRhLiR0eXBlICE9PSAncmVzdCcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIGR1cmF0aW9uID0gbXVzaWNEYXRhLmR1cmF0aW9uO1xuICAgIHZhciBkdXIgPSBkdXJhdGlvbi5xdWFydGVyO1xuXG4gICAgY291bnRlciArPSBkdXI7XG5cbiAgICBpZiAoaW5Hcm91cCgpKSB7XG4gICAgICBpZiAoZHVyYXRpb24udW5kZXJiYXIpIHsgZ3JvdXAucHVzaChtdXNpY0RhdGEpOyB9XG4gICAgfSBlbHNlIGlmIChuZWFyKGNvdW50ZXIsIGdyb3VwRHVyKSkge1xuICAgICAgZ3JvdXAucHVzaChtdXNpY0RhdGEpO1xuICAgICAgcHV0R3JvdXAoKTtcbiAgICAgIGNvdW50ZXIgPSAwO1xuICAgIH0gZWxzZSB7XG4gICAgICBwdXRHcm91cCgpO1xuICAgICAgY291bnRlciAlPSBncm91cER1cjtcbiAgICB9XG4gIH0pO1xuXG4gIHB1dEdyb3VwKCk7XG5cbiAgcmV0dXJuIGdyb3Vwcztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBDZWxsO1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NyYy9tb2RlbC9DZWxsLmpzXG4gKiogbW9kdWxlIGlkID0gN1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwnKTtcblxuLyoqXG4gKiBBIFtiZWFtXVt3aWtpXSBpcyBhIGhvcml6b250YWwgb3IgZGlhZ29uYWwgbGluZSB1c2VkIHRvIGNvbm5lY3QgbXVsdGlwbGUgY29uc2VjdXRpdmUgbm90ZXMgKGFuZCBvY2Nhc2lvbmFsbHkgcmVzdHMpIGluIG9yZGVyIHRvIGluZGljYXRlIHJoeXRobWljIGdyb3VwaW5nLiBPbmx5IGVpZ2h0aCBub3RlcyAocXVhdmVycykgb3Igc2hvcnRlciBjYW4gYmUgYmVhbWVkLlxuICpcbiAqIFt3aWtpXTogaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQmVhbV8obXVzaWMpXG4gKlxuICogQmVhbSBpcyBjcmVhdGVkIGJ5IHtAbGluayBDZWxsI21ha2VCZWFtc30gYW5kXG4gKiBhdHRhY2hlZCB0byB7QGxpbmsgRHVyYWJsZX0gaW4ge0BsaW5rIER1cmFibGUjYmVhbXN9W2xldmVsXVxuICogQGNsYXNzXG4gKiBAcGFyYW0ge3N0cmluZ30gdmFsdWUgLSBCZWFtIHZhbHVlOiBgJ2JlZ2luJ2AsIGAnY29udGludWUnYCBvciBgJ2VuZCdgLlxuICogQHBhcmFtIHtudW1iZXJ9IGxldmVsIC0gQmVhbSBsZXZlbCBzdGFydGluZyBmcm9tIDAgdG8gdXAuXG4gKiBAcGFyYW0ge0R1cmFibGV9IHBhcmVudCAtIFRoZSBwYXJlbnQgZHVyYWJsZSBtdXNpYyBkYXRhLlxuICovXG5mdW5jdGlvbiBCZWFtKHZhbHVlLCBsZXZlbCwgcGFyZW50KSB7XG4gIHRoaXMuX3ZhbHVlID0gdmFsdWU7XG4gIHRoaXMuX2xldmVsID0gbGV2ZWw7XG4gIHRoaXMuX3BhcmVudCA9IHBhcmVudDtcbn1cblxudXRpbC5kZWZpbmVQcm9wZXJ0aWVzKEJlYW0ucHJvdG90eXBlLFxuLyoqIEBsZW5kcyBCZWFtIyAqL1xue1xuICAvKipcbiAgICogUGFyZW50XG4gICAqIEB0eXBlIHtOb3RlfFJlc3R8Q2hvcmR9XG4gICAqIEByZWFkb25seVxuICAgKi9cbiAgcGFyZW50OiB7XG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcGFyZW50O1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQmVhbSB2YWx1ZTogYCdiZWdpbidgLCBgJ2NvbnRpbnVlJ2Agb3IgYCdlbmQnYC5cbiAgICogQHR5cGUge3N0cmluZ31cbiAgICogQHJlYWRvbmx5XG4gICAqL1xuICB2YWx1ZToge1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3ZhbHVlO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQmVhbSBsZXZlbCBzdGFydGluZyBmcm9tIDAgdG8gdXAuXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqIEByZWFkb25seVxuICAgKi9cbiAgbGV2ZWw6IHtcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9sZXZlbDtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIFRoZSBlbmQgcGFyZW50IG11c2ljIGRhdGEgb2YgdGhlIGJlYW0gZ3JvdXAuXG4gICAqIEB0eXBlIHtNdXNpY0RhdGFNaXhpbn1cbiAgICovXG4gIGVuZER1cmFibGU6IHtcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBuZXh0RGF0YSA9IHRoaXMucGFyZW50Lm5leHQ7XG4gICAgICB3aGlsZSAobmV4dERhdGEgJiYgbmV4dERhdGEuYmVhbXNbdGhpcy5sZXZlbF0udmFsdWUgIT09ICdlbmQnKSB7XG4gICAgICAgIG5leHREYXRhID0gbmV4dERhdGEubmV4dDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXh0RGF0YTtcbiAgICB9XG4gIH1cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEJlYW07XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc3JjL21vZGVsL0JlYW0uanNcbiAqKiBtb2R1bGUgaWQgPSA4XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XHJcblxyXG52YXIgdXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwnKTtcclxudmFyIE11c2ljRGF0YU1peGluID0gcmVxdWlyZSgnLi9NdXNpY0RhdGFNaXhpbicpO1xyXG5cclxuLyoqXHJcbiAqIFRpbWUgc2lnbmF0dXJlLlxyXG4gKiBAY2xhc3NcclxuICogQHBhcmFtIHRpbWUge09iamVjdH1cclxuICogQG1peGVzIE11c2ljRGF0YU1peGluXHJcbiAqIEBtaXhlcyBNdXNpY0RhdGFMYXlvdXRNaXhpblxyXG4gKi9cclxuZnVuY3Rpb24gVGltZSh0aW1lKSB7XHJcbiAgdXRpbC5leHRlbmQodGhpcywgdGltZSk7XHJcbn1cclxuXHJcbnV0aWwuZGVmaW5lUHJvcGVydGllcyhUaW1lLnByb3RvdHlwZSxcclxuLyoqIEBsZW5kcyBUaW1lIyAqL1xyXG57XHJcbiAgLyoqXHJcbiAgICogVHlwZSBvZiB0aW1lLlxyXG4gICAqIEBjb25zdGFudFxyXG4gICAqIEBkZWZhdWx0IHRpbWVcclxuICAgKi9cclxuICAkdHlwZTogeyBjb25zdGFudDogJ3RpbWUnIH0sXHJcblxyXG4gIC8qKlxyXG4gICAqIEhvdyBtYW55IGJlYXRzIHBlciBtZWFzdXJlLlxyXG4gICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICogQGRlZmF1bHRcclxuICAgKi9cclxuICBiZWF0czogNCxcclxuXHJcbiAgLyoqXHJcbiAgICogQmVhdCB0eXBlXHJcbiAgICogQHR5cGUge251bWJlcn1cclxuICAgKiBAZGVmYXVsdFxyXG4gICAqL1xyXG4gIGJlYXRUeXBlOiA0LFxyXG5cclxuICAvKipcclxuICAgKiBDb252ZXJ0IHRvIG11c2plIHNvdXJjZSBjb2RlLlxyXG4gICAqIEByZXR1cm4ge3N0cmluZ30gTXVzamUgc291cmNlIGNvZGUuXHJcbiAgICovXHJcbiAgdG9TdHJpbmc6IGZ1bmN0aW9uICgpIHtcclxuICAgIHJldHVybiB0aGlzLmJlYXRzICsgJy8nICsgdGhpcy5iZWF0VHlwZTtcclxuICB9LFxyXG5cclxuICB0b0pTT046IHV0aWwubWFrZVRvSlNPTih7XHJcbiAgICBiZWF0czogNCxcclxuICAgIGJlYXRUeXBlOiA0XHJcbiAgfSwgJ3RpbWUnKVxyXG59KTtcclxuXHJcbnV0aWwuZGVmaW5lUHJvcGVydGllcyhUaW1lLnByb3RvdHlwZSwgTXVzaWNEYXRhTWl4aW4pO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBUaW1lO1xyXG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc3JjL21vZGVsL1RpbWUuanNcbiAqKiBtb2R1bGUgaWQgPSA5XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogTXVzaWMgZGF0YSBtaXhpblxuICogQG1peGluXG4gKi9cbnZhciBNdXNpY0RhdGFNaXhpbiA9IHtcblxuICAvKipcbiAgICogUmVmZXJlbmNlIHRvIHRoZSBwYXJlbnQgY2VsbC5cbiAgICogQHR5cGUge0NlbGx9XG4gICAqL1xuICBjZWxsOiB7XG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fY2VsbDtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIFRoZSBhc2NlbmRhbnQgc3lzdGVtIG9mIHRoZSBtdXNpYyBkYXRhLlxuICAgKiBAdHlwZSB7U3lzdGVtTGF5b3V0fVxuICAgKiBAcmVhZG9ubHlcbiAgICovXG4gIHN5c3RlbToge1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuY2VsbC5tZWFzdXJlLnN5c3RlbTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIFByZXZpb3VzIG11c2ljIGRhdGEuXG4gICAqIEB0eXBlIHtNdXNpY0RhdGFNaXhpbnx1bmRlZmluZWR9XG4gICAqIEByZWFkb25seVxuICAgKi9cbiAgcHJldjoge1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuY2VsbC5kYXRhW3RoaXMuX2luZGV4IC0gMV07XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBOZXh0IG11c2ljIGRhdGEuXG4gICAqIEB0eXBlIHtNdXNpY0RhdGFNaXhpbnx1bmRlZmluZWR9XG4gICAqIEByZWFkb25seVxuICAgKi9cbiAgbmV4dDoge1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuY2VsbC5kYXRhW3RoaXMuX2luZGV4ICsgMV07XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBQcmV2aW91cyBtdXNpYyBkYXRhIGluIHBhcnQsIGFjcm9zcyBtZWFzdXJlLlxuICAgKiBAdHlwZSB7TXVzaWNEYXRhTWl4aW58dW5kZWZpbmVkfVxuICAgKiBAcmVhZG9ubHlcbiAgICovXG4gIHByZXZJblBhcnQ6IHtcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBwcmV2ID0gdGhpcy5wcmV2LCBjZWxsID0gdGhpcy5jZWxsO1xuICAgICAgd2hpbGUgKCFwcmV2ICYmIGNlbGwucHJldikge1xuICAgICAgICBpZiAoIXByZXYpIHtcbiAgICAgICAgICBjZWxsID0gY2VsbC5wcmV2O1xuICAgICAgICAgIHByZXYgPSBjZWxsLmxhc3REYXRhO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcHJldjtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIE5leHQgbXVzaWMgZGF0YSBpbiBwYXJ0LCBhY3Jvc3MgbWVhc3VyZS5cbiAgICogQHR5cGUge011c2ljRGF0YU1peGlufHVuZGVmaW5lZH1cbiAgICogQHJlYWRvbmx5XG4gICAqL1xuICBuZXh0SW5QYXJ0OiB7XG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgbmV4dCA9IHRoaXMubmV4dCwgY2VsbCA9IHRoaXMuY2VsbDtcbiAgICAgIHdoaWxlICghbmV4dCAmJiBjZWxsLm5leHQpIHtcbiAgICAgICAgaWYgKCFuZXh0KSB7XG4gICAgICAgICAgY2VsbCA9IGNlbGwubmV4dDtcbiAgICAgICAgICBuZXh0ID0gY2VsbC5maXJzdERhdGE7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXh0O1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogUHJldmlvdXMgbXVzaWMgZGF0YSB3aGljaCBoYXMgYSBkdXJhdGlvbi5cbiAgICogQHR5cGUge011c2ljRGF0YU1peGlufHVuZGVmaW5lZH1cbiAgICogQHJlYWRvbmx5XG4gICAqL1xuICBwcmV2RHVyYWJsZToge1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHByZXYgPSB0aGlzLnByZXY7XG4gICAgICB3aGlsZSAocHJldiAmJiAhcHJldi5kdXJhdGlvbikge1xuICAgICAgICBwcmV2ID0gcHJldi5wcmV2O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHByZXY7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBOZXh0IG11c2ljIGRhdGEgd2hpY2ggaGFzIGEgZHVyYXRpb24uXG4gICAqIEB0eXBlIHtNdXNpY0RhdGFNaXhpbnx1bmRlZmluZWR9XG4gICAqIEByZWFkb25seVxuICAgKi9cbiAgbmV4dER1cmFibGU6IHtcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBuZXh0ID0gdGhpcy5uZXh0O1xuICAgICAgd2hpbGUgKG5leHQgJiYgIW5leHQuZHVyYXRpb24pIHtcbiAgICAgICAgbmV4dCA9IG5leHQubmV4dDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXh0O1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogUHJldmlvdXMgbXVzaWMgZGF0YSB3aGljaCBoYXMgYSBkdXJhdGlvbiBpbiBwYXJ0LCBhY3Jvc3MgbWVhc3VyZS5cbiAgICogQHR5cGUge011c2ljRGF0YU1peGlufHVuZGVmaW5lZH1cbiAgICogQHJlYWRvbmx5XG4gICAqL1xuICBwcmV2RHVyYWJsZUluUGFydDoge1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHByZXYgPSB0aGlzLnByZXZJblBhcnQ7XG4gICAgICB3aGlsZSAocHJldiAmJiAhcHJldi5kdXJhdGlvbikge1xuICAgICAgICBwcmV2ID0gcHJldi5wcmV2SW5QYXJ0O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHByZXY7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBOZXh0IG11c2ljIGRhdGEgd2hpY2ggaGFzIGEgZHVyYXRpb24gaW4gcGFydCwgYWNyb3NzIG1lYXN1cmUuXG4gICAqIEB0eXBlIHtNdXNpY0RhdGFNaXhpbnx1bmRlZmluZWR9XG4gICAqIEByZWFkb25seVxuICAgKi9cbiAgbmV4dER1cmFibGVJblBhcnQ6IHtcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBuZXh0ID0gdGhpcy5uZXh0SW5QYXJ0O1xuICAgICAgd2hpbGUgKG5leHQgJiYgIW5leHQuZHVyYXRpb24pIHtcbiAgICAgICAgbmV4dCA9IG5leHQubmV4dEluUGFydDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXh0O1xuICAgIH1cbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBNdXNpY0RhdGFNaXhpbjtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zcmMvbW9kZWwvTXVzaWNEYXRhTWl4aW4uanNcbiAqKiBtb2R1bGUgaWQgPSAxMFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsJyk7XHJcbnZhciBNdXNpY0RhdGFNaXhpbiA9IHJlcXVpcmUoJy4vTXVzaWNEYXRhTWl4aW4nKTtcclxuXHJcbnZhciBCQVJfVE9fU1RSSU5HID0ge1xyXG4gIHNpbmdsZTogJ3wnLCBkb3VibGU6ICd8fCcsIGVuZDogJ3xdJyxcclxuICAncmVwZWF0LWJlZ2luJzogJ3w6JywgJ3JlcGVhdC1lbmQnOiAnOnwnLCAncmVwZWF0LWJvdGgnOiAnOnw6J1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEBjbGFzc1xyXG4gKiBAcGFyYW0ge3N0cmluZ30gYmFyIC0gVGhlIGJhciB2YWx1ZSwgd2hpY2ggY2FuIGJlIGVpdGhlciBvZlxyXG4gKiAtICdzaW5nbGUnIC0gYHxgXHJcbiAqIC0gJ2RvdWJsZScgLSBgfHxgXHJcbiAqIC0gJ2VuZCcgLSBgfF1gXHJcbiAqIC0gJ3JlcGVhdC1iZWdpbicgLSBgfDpgXHJcbiAqIC0gJ3JlcGVhdC1lbmQnIC0gYDp8YFxyXG4gKiAtICdyZXBlYXQtYm90aCcgLSBgOnw6YFxyXG4gKiBAbWl4ZXMgTXVzaWNEYXRhTWl4aW5cclxuICogQG1peGVzIE11c2ljRGF0YUxheW91dE1peGluXHJcbiAqL1xyXG5mdW5jdGlvbiBCYXIoYmFyKSB7XHJcbiAgdGhpcy5fdmFsdWUgPSBiYXI7XHJcbn1cclxuXHJcbnV0aWwuZGVmaW5lUHJvcGVydGllcyhCYXIucHJvdG90eXBlLFxyXG4vKiogQGxlbmRzIEJhciMgKi9cclxue1xyXG4gIC8qKlxyXG4gICAqIFR5cGUgb2YgYmFyLlxyXG4gICAqIEBjb25zdGFudFxyXG4gICAqIEByZWFkb25seVxyXG4gICAqIEBkZWZhdWx0IGJhclxyXG4gICAqL1xyXG4gICR0eXBlOiB7IGNvbnN0YW50OiAnYmFyJyB9LFxyXG5cclxuICAvKipcclxuICAgKiBWYWx1ZSBvZiB0aGUgYmFyLCB3aGljaCBpcyB0aGUgc2FtZSBhcyB0aGUgYmFyIHBhcmFtZXRlciBpbiB0aGUgY29uc3RydWN0b3IuXHJcbiAgICogQHR5cGUge3N0cmluZ31cclxuICAgKiBAZGVmYXVsdCBzaW5nbGVcclxuICAgKiBAcmVhZG9ubHlcclxuICAgKi9cclxuICB2YWx1ZToge1xyXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLl92YWx1ZSB8fCAodGhpcy5fdmFsdWUgPSAnc2luZ2xlJyk7XHJcbiAgICB9XHJcbiAgfSxcclxuXHJcbiAgLyoqXHJcbiAgICogQ29udmVydCBiYXIgdG8gc3RyaW5nLlxyXG4gICAqIEByZXR1cm4ge3N0cmluZ30gQ29udmVydGVkIHN0cmluZyBvZiB0aGUgYmFybGluZSBpbiBtdXNqZSBzb3VyY2UgY29kZS5cclxuICAgKi9cclxuICB0b1N0cmluZzogZnVuY3Rpb24gKCkge1xyXG4gICAgcmV0dXJuIEJBUl9UT19TVFJJTkdbdGhpcy52YWx1ZV07XHJcbiAgfSxcclxuXHJcbiAgLyoqXHJcbiAgICogW3RvSlNPTiBkZXNjcmlwdGlvbl1cclxuICAgKiBAcmV0dXJuIHtPYmplY3R9IHsgYmFyOiB2YWx1ZSB9XHJcbiAgICovXHJcbiAgdG9KU09OOiBmdW5jdGlvbiAoKSB7XHJcbiAgICByZXR1cm4geyBiYXI6IHRoaXMudmFsdWUgfTtcclxuICB9XHJcbn0pO1xyXG5cclxudXRpbC5kZWZpbmVQcm9wZXJ0aWVzKEJhci5wcm90b3R5cGUsIE11c2ljRGF0YU1peGluKTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQmFyO1xyXG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc3JjL21vZGVsL0Jhci5qc1xuICoqIG1vZHVsZSBpZCA9IDExXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XHJcblxyXG52YXIgdXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwnKTtcclxudmFyIE11c2ljRGF0YU1peGluID0gcmVxdWlyZSgnLi9NdXNpY0RhdGFNaXhpbicpO1xyXG52YXIgUGl0Y2ggPSByZXF1aXJlKCcuL1BpdGNoJyk7XHJcbnZhciBEdXJhdGlvbiA9IHJlcXVpcmUoJy4vRHVyYXRpb24nKTtcclxudmFyIFRpZSA9IHJlcXVpcmUoJy4vVGllJyk7XHJcbnZhciBTbHVyID0gcmVxdWlyZSgnLi9TbHVyJyk7XHJcblxyXG4vKipcclxuICogQGNsYXNzXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBub3RlXHJcbiAqIEBtaXhlcyBNdXNpY0RhdGFNaXhpblxyXG4gKiBAbWl4ZXMgTXVzaWNEYXRhTGF5b3V0TWl4aW5cclxuICovXHJcbmZ1bmN0aW9uIE5vdGUobm90ZSkge1xyXG4gIHV0aWwuZXh0ZW5kKHRoaXMsIG5vdGUpO1xyXG59XHJcblxyXG51dGlsLmRlZmluZVByb3BlcnRpZXMoTm90ZS5wcm90b3R5cGUsXHJcbi8qKiBAbGVuZHMgTm90ZSMgKi9cclxue1xyXG4gIC8qKlxyXG4gICAqIFR5cGUgb2Ygbm90ZS5cclxuICAgKiBAY29uc3RhbnRcclxuICAgKiBAZGVmYXVsdCBub3RlXHJcbiAgICovXHJcbiAgJHR5cGU6IHsgY29uc3RhbnQ6ICdub3RlJyB9LFxyXG5cclxuICAvKipcclxuICAgKiBQaXRjaCBvZiB0aGUgbm90ZS5cclxuICAgKiBAdHlwZSB7bXVzamUuUGl0Y2h9XHJcbiAgICovXHJcbiAgcGl0Y2g6IHtcclxuICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICByZXR1cm4gdGhpcy5fcGl0Y2ggfHwgKHRoaXMuX3BpdGNoID0gbmV3IFBpdGNoKHRoaXMpKTtcclxuICAgIH0sXHJcbiAgICBzZXQ6IGZ1bmN0aW9uIChwaXRjaCkge1xyXG4gICAgICB0aGlzLl9waXRjaCA9IG5ldyBQaXRjaCh0aGlzLCBwaXRjaCk7XHJcbiAgICB9XHJcbiAgfSxcclxuXHJcbiAgLyoqXHJcbiAgICogRHVyYXRpb24gb2YgdGhlIG5vdGUuXHJcbiAgICogQHR5cGUge211c2plLkR1cmF0aW9ufVxyXG4gICAqL1xyXG4gIGR1cmF0aW9uOiB7XHJcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgcmV0dXJuIHRoaXMuX2R1cmF0aW9uIHx8ICh0aGlzLl9kdXJhdGlvbiA9IG5ldyBEdXJhdGlvbigpKTtcclxuICAgIH0sXHJcbiAgICBzZXQ6IGZ1bmN0aW9uIChkdXJhdGlvbikge1xyXG4gICAgICB0aGlzLl9kdXJhdGlvbiA9IG5ldyBEdXJhdGlvbihkdXJhdGlvbik7XHJcbiAgICB9XHJcbiAgfSxcclxuXHJcbiAgYmVhbXM6IHtcclxuICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICByZXR1cm4gdGhpcy5fYmVhbXMgfHwgKHRoaXMuX2JlYW1zID0gW10pO1xyXG4gICAgfSxcclxuICAgIHNldDogZnVuY3Rpb24gKGJlYW1zKSB7XHJcbiAgICAgIHRoaXMuX2JlYW1zID0gYmVhbXM7XHJcbiAgICB9XHJcbiAgfSxcclxuXHJcbiAgLyoqXHJcbiAgICogVGllXHJcbiAgICogQHR5cGUge211c2plLlRpZX1cclxuICAgKi9cclxuICB0aWU6IHtcclxuICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICByZXR1cm4gdGhpcy5fdGllIHx8ICh0aGlzLl90aWUgPSBuZXcgVGllKHRoaXMpKTtcclxuICAgIH0sXHJcbiAgICBzZXQ6IGZ1bmN0aW9uICh0aWUpIHtcclxuXHJcbiAgICAgIC8qKlxyXG4gICAgICAgKiBWYWx1ZSBvZiB0aGUgdGllLlxyXG4gICAgICAgKiBAbWVtYmVyb2YgVGllI1xyXG4gICAgICAgKiBAYWxpYXMgdmFsdWVcclxuICAgICAgICogQHR5cGUge2Jvb2xlYW59XHJcbiAgICAgICAqL1xyXG4gICAgICB0aGlzLnRpZS52YWx1ZSA9IHRpZTtcclxuICAgIH1cclxuICB9LFxyXG5cclxuICAvKipcclxuICAgKiBTbHVyXHJcbiAgICogQHR5cGUge1NsdXJ9XHJcbiAgICovXHJcbiAgc2x1cjoge1xyXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLl9zbHVyIHx8ICh0aGlzLl9zbHVyID0gbmV3IFNsdXIodGhpcykpO1xyXG4gICAgfSxcclxuICAgIHNldDogZnVuY3Rpb24gKHNsdXIpIHtcclxuICAgICAgdXRpbC5leHRlbmQodGhpcy5zbHVyLCBzbHVyKTtcclxuICAgIH1cclxuICB9LFxyXG5cclxuICAvKiogQG1ldGhvZCAqL1xyXG4gIHRvU3RyaW5nOiBmdW5jdGlvbiAoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5zbHVyLmJlZ2luICsgdGhpcy5waXRjaCArIHRoaXMuZHVyYXRpb24gK1xyXG4gICAgICAgICAgIHRoaXMuc2x1ci5lbmQgKyB0aGlzLnRpZS52YWx1ZTtcclxuICB9LFxyXG5cclxuICB0b0pTT046IHV0aWwubWFrZVRvSlNPTih7XHJcbiAgICBwaXRjaDogdW5kZWZpbmVkLFxyXG4gICAgZHVyYXRpb246IHVuZGVmaW5lZCxcclxuICAgIHRpZTogdW5kZWZpbmVkLFxyXG4gICAgc2x1cjogdW5kZWZpbmVkXHJcbiAgfSwgJ25vdGUnKVxyXG59KTtcclxuXHJcbnV0aWwuZGVmaW5lUHJvcGVydGllcyhOb3RlLnByb3RvdHlwZSwgTXVzaWNEYXRhTWl4aW4pO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBOb3RlO1xyXG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc3JjL21vZGVsL05vdGUuanNcbiAqKiBtb2R1bGUgaWQgPSAxMlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsJyk7XHJcblxyXG4vLyBDb25zdGFudHMgYW5kIGhlbHBlcnNcclxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuXHJcbnZhciBBNF9GUkVRVUVOQ1kgPSA0NDA7XHJcbnZhciBBNF9NSURJX05VTUJFUiA9IDY5O1xyXG52YXIgU1RFUF9UT19NSURJX05VTUJFUiA9IFt1bmRlZmluZWQsIDAsIDIsIDQsIDUsIDcsIDksIDExXTtcclxudmFyIEFDQ0lERU5UQUxfVE9fQUxURVIgPSB7ICcjJyA6IDEsICcjIyc6IDIsIG46IDAsIGIgOiAtMSwgYmI6IC0yIH07XHJcblxyXG5mdW5jdGlvbiBjaGFycyhjaCwgbnVtKSB7XHJcbiAgcmV0dXJuIG5ldyBBcnJheShudW0gKyAxKS5qb2luKGNoKTtcclxufVxyXG5cclxuZnVuY3Rpb24gb2N0YXZlU3RyaW5nKG9jdGF2ZSkge1xyXG4gIHJldHVybiBvY3RhdmUgPiAwID8gY2hhcnMoJ1xcJycsIG9jdGF2ZSkgOlxyXG4gICAgICAgICBvY3RhdmUgPCAwID8gY2hhcnMoJywnLCAtb2N0YXZlKSA6ICcnO1xyXG59XHJcblxyXG4vKipcclxuICogQGNsYXNzXHJcbiAqIEBwYXJhbSBwYXJlbnQge05vdGV8Q2hvcmR9XHJcbiAqIEBwYXJhbSBwaXRjaCB7T2JqZWN0fVxyXG4gKi9cclxuZnVuY3Rpb24gUGl0Y2gocGFyZW50LCBwaXRjaCkge1xyXG4gIHRoaXMuX3BhcmVudCA9IHBhcmVudDtcclxuICB1dGlsLmV4dGVuZCh0aGlzLCBwaXRjaCk7XHJcbn1cclxuXHJcbnV0aWwuZGVmaW5lUHJvcGVydGllcyhQaXRjaC5wcm90b3R5cGUsXHJcbi8qKiBAbGVuZHMgUGl0Y2gjICovXHJcbntcclxuICAvKipcclxuICAgKiBSZWZlcmVuY2UgdG8gdGhlIHBhcmVudCBwYXJlbnQuXHJcbiAgICogQHR5cGUge05vdGV8Q2hvcmR9XHJcbiAgICogQHJlYWRvbmx5XHJcbiAgICovXHJcbiAgcGFyZW50OiB7XHJcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgcmV0dXJuIHRoaXMuX3BhcmVudDtcclxuICAgIH1cclxuICB9LFxyXG5cclxuICAvKipcclxuICAgKiBTdGVwIGlzIGEgdmFsdWUgb2YgYDFgLCBgMmAsIGAzYCwgYDRgLCBgNWAsIGA2YCwgb3IgYDdgLlxyXG4gICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICogQGRlZmF1bHRcclxuICAgKi9cclxuICBzdGVwOiAxLFxyXG5cclxuICAvKipcclxuICAgKiBPY3RhdmUgaXMgYW4gaW50ZWdlciB2YWx1ZSBmcm9tIGAtNWAgdG8gYDVgIGluY2x1c2l2ZS5cclxuICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAqIEBkZWZhdWx0XHJcbiAgICovXHJcbiAgb2N0YXZlOiAwLFxyXG5cclxuICAvKipcclxuICAgKiBBY2NpZGVudGFsIGlzIGVpdGhlciBvZlxyXG4gICAqIC0gYCcjJ2AgLSBzaGFycFxyXG4gICAqIC0gYCcjIydgIC0gZG91YmxlIHNoYXJwXHJcbiAgICogLSBgJ2InYCAtIGZsYXRcclxuICAgKiAtIGAnYmInYCAtIGRvdWJsZSBmbGF0XHJcbiAgICogLSBgJ24nYCAtIG5hdHVyYWxcclxuICAgKiAtIGAnJ2AgLSAobm9uZSlcclxuICAgKiBAdHlwZSB7c3RyaW5nfVxyXG4gICAqL1xyXG4gIGFjY2lkZW50YWw6ICcnLFxyXG5cclxuICAvKipcclxuICAgKiBBbHRlciAoZnJvbSAtMiB0byAyIGluY2x1c2l2ZSkuXHJcbiAgICpcclxuICAgKiBJZiBubyBhY2NpZGVudGFsIGluIHRoaXMgcGl0Y2gsIGl0IG1pZ2h0IGJlIGFmZmVjdGVkIGJ5IGEgcHJldmlvdXMgbm90ZSBpbiB0aGUgc2FtZSBjZWxsICh0aGUgc2FtZSBwYXJ0IGFuZCB0aGUgc2FtZSBtZWFzdXJlKS5cclxuICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAqIEByZWFkb25seVxyXG4gICAqL1xyXG4gIGFsdGVyOiB7XHJcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgaWYgKHRoaXMuYWNjaWRlbnRhbCkge1xyXG4gICAgICAgIHJldHVybiBBQ0NJREVOVEFMX1RPX0FMVEVSW3RoaXMuYWNjaWRlbnRhbF07XHJcbiAgICAgIH1cclxuICAgICAgdmFyIGFsID0gdGhpcy5hbHRlckxpbms7XHJcbiAgICAgIHJldHVybiBhbCA/IGFsLmFsdGVyIDogMDtcclxuICAgIH1cclxuICB9LFxyXG5cclxuICAvKipcclxuICAgKiBQaXRjaCBsaW5rZWQgdGhhdCB3aWxsIGFmZmVjdCB0aGUgYWx0ZXIgaW4gdGhpcyBwaXRjaC5cclxuICAgKiBAdHlwZSB7UGl0Y2h8dW5kZWZpbmVkfVxyXG4gICAqIEByZWFkb25seVxyXG4gICAqL1xyXG4gIGFsdGVyTGluazoge1xyXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHZhciBwcmV2RGF0YSA9IHRoaXMucGFyZW50LnByZXY7XHJcblxyXG4gICAgICB3aGlsZShwcmV2RGF0YSkge1xyXG4gICAgICAgIGlmIChwcmV2RGF0YS4kdHlwZSA9PT0gJ25vdGUnICYmXHJcbiAgICAgICAgICAgIHByZXZEYXRhLnBpdGNoLnN0ZXAgPT09IHRoaXMuc3RlcCAmJiBwcmV2RGF0YS5waXRjaC5hY2NpZGVudGFsKSB7XHJcbiAgICAgICAgICByZXR1cm4gcHJldkRhdGEucGl0Y2g7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHByZXZEYXRhID0gcHJldkRhdGEucHJldjtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH0sXHJcblxyXG4gIC8qKlxyXG4gICAqIFRoZSBNSURJIG5vdGUgbnVtYmVyIG9mIHRoZSBwaXRjaFxyXG4gICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICovXHJcbiAgbWlkaU51bWJlcjoge1xyXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHJldHVybiAodGhpcy5vY3RhdmUgKyA1KSAqIDEyICtcclxuICAgICAgICBTVEVQX1RPX01JRElfTlVNQkVSW3RoaXMuc3RlcF0gKyB0aGlzLmFsdGVyO1xyXG4gICAgfVxyXG4gIH0sXHJcblxyXG4gIC8qKlxyXG4gICAqIEZyZXF1ZW5jeSBvZiB0aGUgcGl0Y2hcclxuICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAqIEByZWFkb25seVxyXG4gICAqL1xyXG4gIGZyZXF1ZW5jeToge1xyXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHJldHVybiBBNF9GUkVRVUVOQ1kgKiBNYXRoLnBvdygyLCAodGhpcy5taWRpTnVtYmVyIC0gQTRfTUlESV9OVU1CRVIpIC8gMTIpO1xyXG4gICAgfVxyXG4gIH0sXHJcblxyXG4gIC8qKlxyXG4gICAqIENvbnZlcnQgdG8gbXVzamUgc291cmNlIGNvZGUgc3RyaW5nLlxyXG4gICAqIEByZXR1cm4ge3N0cmluZ30gQ29udmVydGVkIG11c2plIHNvdXJjZSBjb2RlIHN0cmluZy5cclxuICAgKi9cclxuICB0b1N0cmluZzogZnVuY3Rpb24gKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuYWNjaWRlbnRhbCArIHRoaXMuc3RlcCArIG9jdGF2ZVN0cmluZyh0aGlzLm9jdGF2ZSk7XHJcbiAgfSxcclxuXHJcbiAgdG9KU09OOiB1dGlsLm1ha2VUb0pTT04oe1xyXG4gICAgc3RlcDogMSxcclxuICAgIG9jdGF2ZTogMCxcclxuICAgIGFjY2lkZW50YWw6ICcnXHJcbiAgfSlcclxufSk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFBpdGNoO1xyXG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc3JjL21vZGVsL1BpdGNoLmpzXG4gKiogbW9kdWxlIGlkID0gMTNcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciB1dGlsID0gcmVxdWlyZSgnLi4vdXRpbCcpO1xyXG52YXIgVFlQRV9UT19TVFJJTkcgPSB7XHJcbiAgMTogJyAtIC0gLSAnLCAyOiAnIC0gJywgNDogJycsIDg6ICdfJywgMTY6ICc9JywgMzI6ICc9XycsXHJcbiAgNjQ6ICc9PScsIDEyODogJz09XycsIDI1NjogJz09PScsIDUxMjogJz09PV8nLCAxMDI0OiAnPT09PSdcclxufTtcclxudmFyIFRZUEVfVE9fVU5ERVJCQVIgPSB7XHJcbiAgIDE6IDAsICAgMjogMCwgICA0OiAwLCAgIDg6IDEsICAgMTY6IDIsIDMyOiAzLFxyXG4gIDY0OiA0LCAxMjg6IDUsIDI1NjogNiwgNTEyOiA3LCAxMDI0OiA4XHJcbn07XHJcbnZhciBET1RfVE9fU1RSSU5HID0gWycnLCAnLicsICcuLiddO1xyXG5cclxuLyoqXHJcbiAqIEBjbGFzc1xyXG4gKiBAcGFyYW0gZHVyYXRpb24ge09iamVjdH1cclxuICovXHJcbmZ1bmN0aW9uIER1cmF0aW9uKGR1cmF0aW9uKSB7XHJcbiAgdXRpbC5leHRlbmQodGhpcywgZHVyYXRpb24pO1xyXG59XHJcblxyXG51dGlsLmRlZmluZVByb3BlcnRpZXMoRHVyYXRpb24ucHJvdG90eXBlLFxyXG4vKiogQGxlbmRzIER1cmF0aW9uIyAqL1xyXG57XHJcbiAgLyoqXHJcbiAgICogVHlwZSBvZiBkdXJhdGlvbi5cclxuICAgKiBAY29uc3RhbnRcclxuICAgKiBAZGVmYXVsdCBkdXJhdGlvblxyXG4gICAqL1xyXG4gICR0eXBlOiB7IGNvbnN0YW50OiAnZHVyYXRpb24nIH0sXHJcblxyXG4gIC8qKlxyXG4gICAqIEJlYXQgdHlwZVxyXG4gICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICogQGRlZmF1bHRcclxuICAgKi9cclxuICB0eXBlOiA0LFxyXG5cclxuICAvKipcclxuICAgKiBEb3Qgd2l0aCB2YWx1ZSBvZiAwLCAxLCBvciAyLlxyXG4gICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICogQGRlZmF1bHRcclxuICAgKi9cclxuICBkb3Q6IDAsXHJcblxyXG4gIC8qKlxyXG4gICAqIGAoR2V0dGVyKWAgRHVyYXRpb24gbWVhc3VyZWQgaW4gcXVhcnRlciBub3RlLlxyXG4gICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICovXHJcbiAgcXVhcnRlcjoge1xyXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHZhciBkID0gNCAvIHRoaXMudHlwZTtcclxuICAgICAgcmV0dXJuIHRoaXMuZG90ID09PSAwID8gZCA6XHJcbiAgICAgICAgICAgICB0aGlzLmRvdCA9PT0gMSA/IGQgKiAxLjUgOiBkICogMS43NTtcclxuICAgIH1cclxuICB9LFxyXG5cclxuICAvKipcclxuICAgKiBgKEdldHRlcilgIER1cmF0aW9uIGluIHNlY29uZFxyXG4gICAqIEFmZmVjdGVkIGJ5IHRoZSB0ZW1wby5cclxuICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAqIEByZWFkb25seVxyXG4gICAqL1xyXG4gIHNlY29uZDoge1xyXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLnF1YXJ0ZXIgKiA2MCAvIDgwOyAvLyAvIFRFTVBPO1xyXG4gICAgfVxyXG4gIH0sXHJcblxyXG4gIC8qKlxyXG4gICAqIGAoR2V0dGVyKWAgTnVtYmVyIG9mIHVuZGVyYmFycyBpbiB0aGUgYmVhbS5cclxuICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAqIEByZWFkb25seVxyXG4gICAqL1xyXG4gIHVuZGVyYmFyOiB7XHJcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgcmV0dXJuIFRZUEVfVE9fVU5ERVJCQVJbdGhpcy50eXBlXSB8fCAwO1xyXG4gICAgfVxyXG4gIH0sXHJcblxyXG4gIC8qKlxyXG4gICAqIEByZXR1cm4ge3N0cmluZ31cclxuICAgKi9cclxuICB0b1N0cmluZzogZnVuY3Rpb24gKCkge1xyXG4gICAgcmV0dXJuIFRZUEVfVE9fU1RSSU5HW3RoaXMudHlwZV0gKyBET1RfVE9fU1RSSU5HW3RoaXMuZG90XTtcclxuICB9LFxyXG5cclxuICAvKipcclxuICAgKiBbdG9KU09OIGRlc2NyaXB0aW9uXVxyXG4gICAqIEByZXR1cm4ge09iamVjdH1cclxuICAgKi9cclxuICB0b0pTT046IHV0aWwubWFrZVRvSlNPTih7XHJcbiAgICB0eXBlOiA0LFxyXG4gICAgZG90OiAwXHJcbiAgfSlcclxufSk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IER1cmF0aW9uO1xyXG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc3JjL21vZGVsL0R1cmF0aW9uLmpzXG4gKiogbW9kdWxlIGlkID0gMTRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsJyk7XG5cbi8qKlxuICogVGllIG9mIHRoZSBub3RlLlxuICogQGNsYXNzXG4gKiBAcGFyYW0gcGFyZW50IHtOb3RlfENob3JkfVxuICovXG5mdW5jdGlvbiBUaWUocGFyZW50KSB7XG4gIHRoaXMuX3BhcmVudCA9IHBhcmVudDtcbn1cblxudXRpbC5kZWZpbmVQcm9wZXJ0aWVzKFRpZS5wcm90b3R5cGUsXG4vKiogQGxlbmRzIG11c2plLlRpZSMgKi9cbntcbiAgLyoqXG4gICAqIFBhcmVudCBub3RlIG9yIGNob3JkLlxuICAgKiBAdHlwZSB7Tm90ZXxDaG9yZH1cbiAgICogQHJlYWRvbmx5XG4gICAqL1xuICBwYXJlbnQ6IHtcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9wYXJlbnQ7XG4gICAgfVxuICB9LFxuXG4gIHZhbHVlOiAnJyxcblxuICAvKipcbiAgICogQHJlYWRvbmx5XG4gICAqL1xuICBiZWdpbjoge1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMudmFsdWU7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBAcmVhZG9ubHlcbiAgICovXG4gIGVuZDoge1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMucHJldlBhcmVudDtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIFRoZSBwcmV2aW91cyBkdXJhYmxlIG11c2ljIGRhdGEgaW4gcGFydCwgaWYgaXQgaXMgYSB0aWUgYmVnaW4uXG4gICAqIEB0eXBlIHtEdXJhYmxlfHVuZGVmaW5lZH1cbiAgICogQHJlYWRvbmx5XG4gICAqL1xuICBwcmV2UGFyZW50OiB7XG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgcHJldiA9IHRoaXMucGFyZW50LnByZXZEdXJhYmxlSW5QYXJ0O1xuICAgICAgcmV0dXJuIHByZXYgJiYgcHJldi50aWUgJiYgcHJldi50aWUudmFsdWUgJiYgcHJldjtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIFRoZSBuZXh0IGR1cmFibGUgbXVzaWMgZGF0YSBpbiBwYXJ0LlxuICAgKiBAdHlwZSB7RHVyYWJsZXx1bmRlZmluZWR9XG4gICAqIEByZWFkb25seVxuICAgKi9cbiAgbmV4dFBhcmVudDoge1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMudmFsdWUgJiYgdGhpcy5wYXJlbnQubmV4dER1cmFibGVJblBhcnQ7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBJZiBwcmV2aW91cyBkdXJhYmxlIG11c2ljIGRhdGEgaW4gcGFydCBoYXMgZXJyb3IuXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKiBAcmVhZG9ubHlcbiAgICovXG4gIHByZXZIYXNFcnJvcjoge1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHByZXYgPSB0aGlzLnByZXZQYXJlbnQ7XG4gICAgICBpZiAoIXByZXYgfHwgIXByZXYucGl0Y2gpIHsgcmV0dXJuIHRydWU7IH1cbiAgICAgIHJldHVybiBwcmV2LnBpdGNoICYmIHByZXYucGl0Y2gubWlkaU51bWJlciAhPT0gdGhpcy5wYXJlbnQucGl0Y2gubWlkaU51bWJlcjtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIElmIG5leHQgZHVyYWJsZSBtdXNpYyBkYXRhIGluIHBhcnQgaGFzIGVycm9yLlxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICogQHJlYWRvbmx5XG4gICAqL1xuICBuZXh0SGFzRXJyb3I6IHtcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBuZXh0ID0gdGhpcy5uZXh0UGFyZW50O1xuICAgICAgaWYgKCFuZXh0IHx8ICFuZXh0LnBpdGNoKSB7IHJldHVybiB0cnVlOyB9XG4gICAgICByZXR1cm4gbmV4dC5waXRjaC5taWRpTnVtYmVyICE9PSB0aGlzLnBhcmVudC5waXRjaC5taWRpTnVtYmVyO1xuICAgIH1cbiAgfSxcblxuICB0b0pTT046IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy52YWx1ZTtcbiAgfVxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gVGllO1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NyYy9tb2RlbC9UaWUuanNcbiAqKiBtb2R1bGUgaWQgPSAxNVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwnKTtcblxuLyoqXG4gKiBTbHVyXG4gKiBAY2xhc3NcbiAqIEBwYXJhbSBwYXJlbnQge05vdGV8Q2hvcmR9XG4gKi9cbmZ1bmN0aW9uIFNsdXIocGFyZW50KSB7XG4gIHRoaXMuX3BhcmVudCA9IHBhcmVudDtcbn1cblxudXRpbC5kZWZpbmVQcm9wZXJ0aWVzKFNsdXIucHJvdG90eXBlLFxuLyoqIEBsZW5kcyBTbHVyIyAqL1xue1xuICAvKipcbiAgICogUGFyZW50IG11c2ljIGRhdGEuXG4gICAqIEB0eXBlIHtOb3RlfENob3JkfVxuICAgKiBAcmVhZG9ubHlcbiAgICovXG4gIHBhcmVudDoge1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3BhcmVudDtcbiAgICB9XG4gIH0sXG5cbiAgYmVnaW46ICcnLFxuXG4gIGVuZDogJycsXG5cbiAgLyoqXG4gICAqIFByZXZpb3VzIHNsdXJyZWQgcGFyZW50LlxuICAgKiBAdHlwZSB7Tm90ZXxDaG9yZH1cbiAgICogQHJlYWRvbmx5XG4gICAqL1xuICBwcmV2UGFyZW50OiB7XG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoIXRoaXMuZW5kKSB7IHJldHVybjsgfVxuXG4gICAgICB2YXIgcHJldiA9IHRoaXMucGFyZW50LnByZXZJblBhcnQ7XG4gICAgICB3aGlsZShwcmV2KSB7XG4gICAgICAgIGlmIChwcmV2LnNsdXIgJiYgIXByZXYuc2x1ci5pc0VtcHR5KSB7XG4gICAgICAgICAgcmV0dXJuIHByZXY7XG4gICAgICAgIH1cbiAgICAgICAgcHJldiA9IHByZXYucHJldkluUGFydDtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIE5leHQgU2x1cnJlZCBwYXJlbnQuXG4gICAqIEB0eXBlIHtOb3RlfENob3JkfVxuICAgKiBAcmVhZG9ubHlcbiAgICovXG4gIG5leHRQYXJlbnQ6IHtcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICghdGhpcy5iZWdpbikgeyByZXR1cm47IH1cblxuICAgICAgdmFyIG5leHQgPSB0aGlzLnBhcmVudC5uZXh0SW5QYXJ0O1xuICAgICAgd2hpbGUobmV4dCkge1xuICAgICAgICBpZiAobmV4dC5zbHVyICYmICFuZXh0LnNsdXIuaXNFbXB0eSkge1xuICAgICAgICAgIHJldHVybiBuZXh0O1xuICAgICAgICB9XG4gICAgICAgIG5leHQgPSBuZXh0Lm5leHRJblBhcnQ7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBAdG9kbyBOZXN0ZWQgdGllIGluIHNsdXIuXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKiBAcmVhZG9ubHlcbiAgICovXG4gIHByZXZDcm9zc1RpZToge1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuXG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBAdG9kbyBOZXN0ZWQgdGllIGluIHNsdXIuXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKiBAcmVhZG9ubHlcbiAgICovXG4gIG5leHRDcm9zc1RpZToge1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuXG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBJZiB0aGUgcHJldmlvdXMgc2x1ciBoYXMgZXJyb3IuXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKiBAcmVhZG9ubHlcbiAgICovXG4gIHByZXZIYXNFcnJvcjoge1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHByZXYgPSB0aGlzLnByZXZQYXJlbnQ7XG4gICAgICByZXR1cm4gIXByZXYgfHwgIXByZXYuc2x1ci5iZWdpbjtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIElmIHRoZSBuZXh0IHNsdXIgaGFzIGVycm9yLlxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICogQHJlYWRvbmx5XG4gICAqL1xuICBuZXh0SGFzRXJyb3I6IHtcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBuZXh0ID0gdGhpcy5uZXh0UGFyZW50O1xuICAgICAgcmV0dXJuICFuZXh0IHx8ICFuZXh0LnNsdXIuZW5kO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogSWYgdGhlIHNsdXIgaXMgZW1wdHkuXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKiBAcmVhZG9ubHlcbiAgICovXG4gIGlzRW1wdHk6IHtcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiAhKHRoaXMuYmVnaW4gfHwgdGhpcy5lbmQpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQ29udmVydCB0aGUgc2x1ciB0byBKU09OIG9iamVjdC5cbiAgICogQG1ldGhvZFxuICAgKiBAcmV0dXJuIHtPYmplY3R9IEpTT04gb2JqZWN0LlxuICAgKi9cbiAgdG9KU09OOiB1dGlsLm1ha2VUb0pTT04oe1xuICAgIGJlZ2luOiB1bmRlZmluZWQsXG4gICAgZW5kOiB1bmRlZmluZWRcbiAgfSlcbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNsdXI7XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc3JjL21vZGVsL1NsdXIuanNcbiAqKiBtb2R1bGUgaWQgPSAxNlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsJyk7XHJcbnZhciBNdXNpY0RhdGFNaXhpbiA9IHJlcXVpcmUoJy4vTXVzaWNEYXRhTWl4aW4nKTtcclxudmFyIER1cmF0aW9uID0gcmVxdWlyZSgnLi9EdXJhdGlvbicpO1xyXG5cclxuLyoqXHJcbiAqIEBjbGFzc1xyXG4gKiBAcGFyYW0ge3Jlc3R9IHJlc3RcclxuICogQG1peGVzIE11c2ljRGF0YU1peGluXHJcbiAqIEBtaXhlcyBNdXNpY0RhdGFMYXlvdXRNaXhpblxyXG4gKi9cclxuZnVuY3Rpb24gUmVzdChyZXN0KSB7XHJcbiAgdXRpbC5leHRlbmQodGhpcywgcmVzdCk7XHJcbn1cclxuXHJcbnV0aWwuZGVmaW5lUHJvcGVydGllcyhSZXN0LnByb3RvdHlwZSxcclxuLyoqIEBsZW5kcyBSZXN0IyAqL1xyXG57XHJcbiAgLyoqXHJcbiAgICogVHlwZSBvZiByZXN0LlxyXG4gICAqIEBjb25zdGFudFxyXG4gICAqIEBkZWZhdWx0IHJlc3RcclxuICAgKi9cclxuICAkdHlwZTogeyBjb25zdGFudDogJ3Jlc3QnIH0sXHJcblxyXG4gIC8qKlxyXG4gICAqIER1cmF0aW9uIG9mIHRoZSByZXN0LlxyXG4gICAqIEB0eXBlIHtEdXJhdGlvbn1cclxuICAgKi9cclxuICBkdXJhdGlvbjoge1xyXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLl9kdXJhdGlvbiB8fCAodGhpcy5fZHVyYXRpb24gPSBuZXcgRHVyYXRpb24oKSk7XHJcbiAgICB9LFxyXG4gICAgc2V0OiBmdW5jdGlvbiAoZHVyYXRpb24pIHtcclxuICAgICAgdGhpcy5fZHVyYXRpb24gPSBuZXcgRHVyYXRpb24oZHVyYXRpb24pO1xyXG4gICAgfVxyXG4gIH0sXHJcblxyXG4gIGJlYW1zOiB7XHJcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgcmV0dXJuIHRoaXMuX2JlYW1zIHx8ICh0aGlzLl9iZWFtcyA9IFtdKTtcclxuICAgIH0sXHJcbiAgICBzZXQ6IGZ1bmN0aW9uIChiZWFtcykge1xyXG4gICAgICB0aGlzLl9iZWFtcyA9IGJlYW1zO1xyXG4gICAgfVxyXG4gIH0sXHJcblxyXG4gIC8qKlxyXG4gICAqIENvbnZlcnQgdGhlIHJlc3QgdG8gbXVzamUgc291cmNlIGNvZGUgc3RyaW5nLlxyXG4gICAqIEByZXR1cm4ge3N0cmluZ30gQ29udmVydGVkIG11c2plIHNvdXJjZSBjb2RlLlxyXG4gICAqL1xyXG4gIHRvU3RyaW5nOiBmdW5jdGlvbiAoKSB7XHJcbiAgICByZXR1cm4gJzAnICsgdGhpcy5kdXJhdGlvbjtcclxuICB9LFxyXG5cclxuICB0b0pTT046IHV0aWwubWFrZVRvSlNPTih7XHJcbiAgICBkdXJhdGlvbjogdW5kZWZpbmVkLFxyXG4gIH0sICdyZXN0JylcclxufSk7XHJcblxyXG51dGlsLmRlZmluZVByb3BlcnRpZXMoUmVzdC5wcm90b3R5cGUsIE11c2ljRGF0YU1peGluKTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gUmVzdDtcclxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NyYy9tb2RlbC9SZXN0LmpzXG4gKiogbW9kdWxlIGlkID0gMTdcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciB1dGlsID0gcmVxdWlyZSgnLi4vdXRpbCcpO1xyXG52YXIgTXVzaWNEYXRhTWl4aW4gPSByZXF1aXJlKCcuL011c2ljRGF0YU1peGluJyk7XHJcbnZhciBQaXRjaCA9IHJlcXVpcmUoJy4vUGl0Y2gnKTtcclxudmFyIER1cmF0aW9uID0gcmVxdWlyZSgnLi9EdXJhdGlvbicpO1xyXG5cclxuLyoqXHJcbiAqIEBjbGFzc1xyXG4gKiBAcGFyYW0ge09iamVjdH0gY2hvcmRcclxuICogQG1peGVzIE11c2ljRGF0YU1peGluXHJcbiAqIEBtaXhlcyBNdXNpY0RhdGFMYXlvdXRNaXhpblxyXG4gKi9cclxuZnVuY3Rpb24gQ2hvcmQoY2hvcmQpIHtcclxuICB1dGlsLmV4dGVuZCh0aGlzLCBjaG9yZCk7XHJcbn1cclxuXHJcbnV0aWwuZGVmaW5lUHJvcGVydGllcyhDaG9yZC5wcm90b3R5cGUsXHJcbi8qKiBAbGVuZHMgQ2hvcmQjICovXHJcbntcclxuICAvKipcclxuICAgKiBUeXBlIG9mIGNob3JkLlxyXG4gICAqIEBjb25zdGFudFxyXG4gICAqIEBkZWZhdWx0IGNob3JkXHJcbiAgICovXHJcbiAgJHR5cGU6IHsgY29uc3RhbnQ6ICdjaG9yZCcgfSxcclxuXHJcbiAgLyoqXHJcbiAgICogUGl0Y2hlcyBpbiB0aGUgY2hvcmQuXHJcbiAgICogQHR5cGUge0FycmF5LjxQaXRjaD59XHJcbiAgICovXHJcbiAgcGl0Y2hlczoge1xyXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLl9waXRjaGVzIHx8ICh0aGlzLl9waXRjaGVzID0gW10pO1xyXG4gICAgfSxcclxuICAgIHNldDogZnVuY3Rpb24gKHBpdGNoZXMpIHtcclxuICAgICAgdGhpcy5fcGl0Y2hlcyA9IHBpdGNoZXMubWFwKGZ1bmN0aW9uIChwaXRjaCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgUGl0Y2gocGl0Y2gpO1xyXG4gICAgICB9KTtcclxuICAgIH1cclxuICB9LFxyXG5cclxuICAvKipcclxuICAgKiBEdXJhdGlvbiBvZiB0aGUgY2hvcmQuXHJcbiAgICogQHR5cGUge0R1cmF0aW9ufVxyXG4gICAqL1xyXG4gIGR1cmF0aW9uOiB7XHJcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgcmV0dXJuIHRoaXMuX2R1cmF0aW9uIHx8ICh0aGlzLl9kdXJhdGlvbiA9IG5ldyBEdXJhdGlvbigpKTtcclxuICAgIH0sXHJcbiAgICBzZXQ6IGZ1bmN0aW9uIChkdXJhdGlvbikge1xyXG4gICAgICB0aGlzLl9kdXJhdGlvbiA9IG5ldyBEdXJhdGlvbihkdXJhdGlvbik7XHJcbiAgICB9XHJcbiAgfSxcclxuXHJcbiAgLyoqXHJcbiAgICogQ29udmVydCBjaG9yZCB0byB0aGUgbXVzamUgc291cmNlIGNvZGUgc3RyaW5nLlxyXG4gICAqIEByZXR1cm4ge3N0cmluZ30gQ29udmVydGVkIG11c2plIHNvdXJjZSBjb2RlIG9mIHRoZSBjaG9yZC5cclxuICAgKi9cclxuICB0b1N0cmluZzogZnVuY3Rpb24gKCkge1xyXG4gICAgcmV0dXJuICc8JyArIHRoaXMucGl0Y2hlcy5tYXAoZnVuY3Rpb24gKHBpdGNoKSB7XHJcbiAgICAgIHJldHVybiBwaXRjaC50b1N0cmluZygpO1xyXG4gICAgfSkuam9pbignJykgKyAnPicgKyB0aGlzLmR1cmF0aW9uO1xyXG4gIH0sXHJcblxyXG4gIHRvSlNPTjogdXRpbC5tYWtlVG9KU09OKHtcclxuICAgIHBpdGNoZXM6IHVuZGVmaW5lZCxcclxuICAgIGR1cmF0aW9uOiB1bmRlZmluZWQsXHJcbiAgfSwgJ2Nob3JkJylcclxufSk7XHJcblxyXG51dGlsLmRlZmluZVByb3BlcnRpZXMoQ2hvcmQucHJvdG90eXBlLCBNdXNpY0RhdGFNaXhpbik7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IENob3JkO1xyXG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc3JjL21vZGVsL0Nob3JkLmpzXG4gKiogbW9kdWxlIGlkID0gMThcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsJyk7XG52YXIgTXVzaWNEYXRhTWl4aW4gPSByZXF1aXJlKCcuL011c2ljRGF0YU1peGluJyk7XG5cbi8qKlxuICogQGNsYXNzXG4gKiBAcGFyYW0ge09iamVjdH0gdm9pY2VcbiAqL1xuZnVuY3Rpb24gVm9pY2Uodm9pY2UpIHtcbiAgdXRpbC5leHRlbmQodGhpcywgdm9pY2UpO1xufVxuXG51dGlsLmRlZmluZVByb3BlcnRpZXMoVm9pY2UucHJvdG90eXBlLFxuLyoqIEBsZW5kcyBWb2ljZSMgKi9cbntcbiAgLyoqXG4gICAqIFR5cGUgb2Ygdm9pY2UuXG4gICAqIEBjb25zdGFudFxuICAgKiBAZGVmYXVsdCB2b2ljZVxuICAgKi9cbiAgJHR5cGU6IHsgY29uc3RhbnQ6ICd2b2ljZScgfSxcblxuICAvKipcbiAgICogQ29udmVydCB0aGUgdm9pY2UgdG8gbXVzamUgc291cmNlIGNvZGUgc3RyaW5nLlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9IENvbnZlcnRlZCBtdXNqZSBzb3VyY2UgY29kZSBzdHJpbmcuXG4gICAqL1xuICB0b1N0cmluZzogZnVuY3Rpb24gKCkge1xuXG4gIH1cbn0pO1xuXG51dGlsLmRlZmluZVByb3BlcnRpZXMoVm9pY2UucHJvdG90eXBlLCBNdXNpY0RhdGFNaXhpbik7XG5cbm1vZHVsZS5leHBvcnRzID0gVm9pY2U7XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc3JjL21vZGVsL1ZvaWNlLmpzXG4gKiogbW9kdWxlIGlkID0gMTlcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsJyk7XG52YXIgVGltZXdpc2VNZWFzdXJlID0gcmVxdWlyZSgnLi9UaW1ld2lzZU1lYXN1cmUnKTtcblxuLyoqXG4gKiBDb25zdHJ1Y3QgdGltZXdpc2Ugc2NvcmUgbWVhc3VyZXMuXG4gKiBAY2xhc3NcbiAqIEBjbGFzc2Rlc2MgVGltZXdpc2Ugc2NvcmUgbWVhc3VyZXMuXG4gKiBAcGFyYW0gc2NvcmUge1Njb3JlfVxuICogQGF1Z21lbnRzIHtBcnJheX1cbiAqL1xuZnVuY3Rpb24gVGltZXdpc2VNZWFzdXJlcyhzY29yZSkge1xuICB2YXIgbWVhc3VyZXMgPSBbXTtcbiAgbWVhc3VyZXMuX3Njb3JlID0gc2NvcmU7XG4gIHV0aWwuZGVmaW5lUHJvcGVydGllcyhtZWFzdXJlcywgcHJvcGVydGllcyk7XG4gIHJldHVybiBtZWFzdXJlcztcbn1cblxuLyoqIEBsZW5kcyBUaW1ld2lzZU1lYXN1cmVzIyAqL1xudmFyIHByb3BlcnRpZXMgPSB7XG5cbiAgLyoqXG4gICAqIFJlZmVyZW5jZSB0byB0aGUgcGFyZW50IHNjb3JlLlxuICAgKiBAdHlwZSB7U2NvcmV9XG4gICAqIEByZWFkb25seVxuICAgKi9cbiAgc2NvcmU6IHtcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9zY29yZTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIE1ha2UgdGltZXdpc2Ugc2NvcmUgbWVhc3VyZXMgZnJvbSB0aGUgcGFydHdpc2UgcGFydHMuXG4gICAqL1xuICBmcm9tUGFydHdpc2U6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdGhhdCA9IHRoaXM7XG5cbiAgICB0aGlzLnJlbW92ZUFsbCgpO1xuXG4gICAgdGhpcy5zY29yZS53YWxrQ2VsbHMoZnVuY3Rpb24gKGNlbGwsIG0pIHtcbiAgICAgIHRoYXRbbV0gPSB0aGF0W21dIHx8IG5ldyBUaW1ld2lzZU1lYXN1cmUobSwgdGhhdCk7XG4gICAgICB0aGF0W21dLnBhcnRzLnB1c2goY2VsbCk7XG4gICAgfSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlbW92ZSBhbGwgbWVhc3VyZXMuXG4gICAqL1xuICByZW1vdmVBbGw6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmxlbmd0aCA9IDA7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gVGltZXdpc2VNZWFzdXJlcztcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zcmMvbW9kZWwvVGltZXdpc2VNZWFzdXJlcy5qc1xuICoqIG1vZHVsZSBpZCA9IDIwXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlsID0gcmVxdWlyZSgnLi4vdXRpbCcpO1xuXG4vKipcbiAqIEBjbGFzc1xuICogQHBhcmFtIG1lYXN1cmUge09iamVjdH1cbiAqIEBtaXhlcyBUaW1ld2lzZU1lYXN1cmVMYXlvdXRNaXhpblxuICovXG5mdW5jdGlvbiBUaW1ld2lzZU1lYXN1cmUoaW5kZXgsIG1lYXN1cmVzKSB7XG4gIC8vIHRoaXMuX2luZGV4ID0gaW5kZXg7XG4gIHRoaXMuX21lYXN1cmVzID0gbWVhc3VyZXM7XG59XG5cbnV0aWwuZGVmaW5lUHJvcGVydGllcyhUaW1ld2lzZU1lYXN1cmUucHJvdG90eXBlLFxuLyoqIEBsZW5kcyBUaW1ld2lzZU1lYXN1cmUjICovXG57XG4gIC8qKlxuICAgKiBSZWZlcmVuY2UgdG8gdGhlIHBhcmVudCBtZWFzdXJlcyBpbnN0YW5jZS5cbiAgICogQG1lbWJlciB7VGltZXdpc2VNZWFzdXJlc31cbiAgICovXG4gIG1lYXN1cmVzOiB7XG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fbWVhc3VyZXM7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBQYXJ0cyBpbiB0aW1ld2lzZSBtZWFzdXJlLlxuICAgKiBAdHlwZSB7QXJyYXkuPENlbGw+fVxuICAgKi9cbiAgcGFydHM6IHtcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9wYXJ0cyB8fCAodGhpcy5fcGFydHMgPSBbXSk7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uIChwYXJ0cykge1xuICAgICAgdGhpcy5fcGFydHMgPSBwYXJ0cztcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIExlZnQgYmFyIG9mIHRoZSBtZWFzdXJlLlxuICAgKiBAdHlwZSB7QmFyfVxuICAgKiBAcmVhZG9ubHlcbiAgICovXG4gIGJhckxlZnQ6IHtcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLnBhcnRzWzBdLmJhckxlZnQ7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBSaWdodCBiYXIgb2YgdGhlIG1lYXN1cmUuXG4gICAqIEB0eXBlIHtCYXJ9XG4gICAqIEByZWFkb25seVxuICAgKi9cbiAgYmFyUmlnaHQ6IHtcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLnBhcnRzWzBdLmJhclJpZ2h0O1xuICAgIH1cbiAgfVxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gVGltZXdpc2VNZWFzdXJlO1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NyYy9tb2RlbC9UaW1ld2lzZU1lYXN1cmUuanNcbiAqKiBtb2R1bGUgaWQgPSAyMVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgU25hcCA9IHJlcXVpcmUoJ1NuYXAnKTtcbnZhciB1dGlsID0gcmVxdWlyZSgnLi4vLi4vdXRpbCcpO1xudmFyIExheW91dCA9IHJlcXVpcmUoJy4uL0xheW91dC9MYXlvdXQnKTtcbnZhciByZW5kZXJCYXIgPSByZXF1aXJlKCcuL3JlbmRlckJhcicpO1xudmFyIHJlbmRlckR1cmF0aW9uID0gcmVxdWlyZSgnLi9yZW5kZXJEdXJhdGlvbicpO1xudmFyIHJlbmRlckN1cnZlID0gcmVxdWlyZSgnLi9yZW5kZXJDdXJ2ZScpO1xuXG4vKipcbiAqIFtSZW5kZXJlciBkZXNjcmlwdGlvbl1cbiAqIEBjbGFzc1xuICogQHBhcmFtIHN2ZyB7c3RyaW5nfVxuICogQHBhcmFtIGxvIHtPYmplY3R9XG4gKi9cbmZ1bmN0aW9uIFJlbmRlcmVyKHN2ZywgbG8pIHtcbiAgdGhpcy5fbG8gPSB1dGlsLmV4dGVuZChMYXlvdXQub3B0aW9ucywgbG8pO1xuICB0aGlzLmxheW91dCA9IG5ldyBMYXlvdXQoc3ZnLCB0aGlzLl9sbyk7XG59XG5cbnV0aWwuZGVmaW5lUHJvcGVydGllcyhSZW5kZXJlci5wcm90b3R5cGUsXG4vKiogQGxlbmRzIFJlbmRlcmVyIyAqL1xue1xuICByZW5kZXI6IGZ1bmN0aW9uIChzY29yZSkge1xuICAgIHRoaXMuX3Njb3JlID0gc2NvcmU7XG4gICAgdGhpcy5sYXlvdXQuZmxvdyhzY29yZSk7XG4gICAgdGhpcy5yZW5kZXJIZWFkZXIoKTtcbiAgICB0aGlzLnJlbmRlckNvbnRlbnQoKTtcbiAgfSxcblxuICByZW5kZXJIZWFkZXI6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgbG8gPSB0aGlzLl9sbztcbiAgICB2YXIgaGVhZGVyID0gdGhpcy5sYXlvdXQuaGVhZGVyO1xuICAgIHZhciBlbCA9IGhlYWRlci5lbDtcbiAgICB2YXIgd2lkdGggPSBoZWFkZXIud2lkdGg7XG5cbiAgICBlbC50ZXh0KHdpZHRoIC8gMiwgbG8udGl0bGVGb250U2l6ZSwgdGhpcy5fc2NvcmUuaGVhZC50aXRsZSlcbiAgICAgIC5hdHRyKHtcbiAgICAgICAgZm9udFNpemU6IGxvLnRpdGxlRm9udFNpemUsXG4gICAgICAgIGZvbnRXZWlnaHQ6IGxvLnRpdGxlRm9udFdlaWdodCxcbiAgICAgICAgdGV4dEFuY2hvcjogJ21pZGRsZSdcbiAgICAgIH0pO1xuXG4gICAgZWwudGV4dCh3aWR0aCwgbG8udGl0bGVGb250U2l6ZSAqIDEuNSwgdGhpcy5fc2NvcmUuaGVhZC5jb21wb3NlcilcbiAgICAgIC5hdHRyKHtcbiAgICAgICAgZm9udFNpemU6IGxvLmNvbXBvc2VyRm9udFNpemUsXG4gICAgICAgIGZvbnRXZWlnaHQ6IGxvLmNvbXBvc2VyRm9udFdlaWdodCxcbiAgICAgICAgdGV4dEFuY2hvcjogJ2VuZCdcbiAgICAgIH0pO1xuXG4gICAgaGVhZGVyLmhlaWdodCA9IGVsLmdldEJCb3goKS5oZWlnaHQ7XG4gIH0sXG5cbiAgcmVuZGVyQ29udGVudDogZnVuY3Rpb24gKCkge1xuICAgIHZhciBsbyA9IHRoaXMuX2xvO1xuXG4gICAgdGhpcy5sYXlvdXQuY29udGVudC5zeXN0ZW1zLmZvckVhY2goZnVuY3Rpb24gKHN5c3RlbSkge1xuICAgICAgdmFyIG1lYXN1cmVzID0gc3lzdGVtLm1lYXN1cmVzO1xuICAgICAgbWVhc3VyZXMuZm9yRWFjaChmdW5jdGlvbiAobWVhc3VyZSkge1xuICAgICAgICByZW5kZXJCYXIobWVhc3VyZSwgbG8pO1xuICAgICAgICBtZWFzdXJlLnBhcnRzLmZvckVhY2goZnVuY3Rpb24gKGNlbGwpIHtcbiAgICAgICAgICByZW5kZXJDZWxsKGNlbGwsIGxvKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxufSk7XG5cbmZ1bmN0aW9uIHJlbmRlck5vdGUobm90ZSwgY2VsbCwgbG8pIHtcbiAgbm90ZS5lbCA9IGNlbGwuZWwuZygpLnRyYW5zZm9ybShTbmFwLm1hdHJpeCgpLnRyYW5zbGF0ZShub3RlLngsIG5vdGUueSkpO1xuICBub3RlLmVsLnVzZShub3RlLmRlZi5waXRjaERlZi5lbCk7XG4gIHJlbmRlckR1cmF0aW9uKG5vdGUsIGxvKTtcbn1cblxuZnVuY3Rpb24gcmVuZGVyQ2VsbChjZWxsLCBsbykge1xuICBjZWxsLmRhdGEuZm9yRWFjaChmdW5jdGlvbiAoZGF0YSkge1xuICAgIHN3aXRjaCAoZGF0YS4kdHlwZSkge1xuICAgIGNhc2UgJ3Jlc3QnOlxuICAgICAgcmVuZGVyTm90ZShkYXRhLCBjZWxsLCBsbyk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdub3RlJzpcbiAgICAgIHJlbmRlck5vdGUoZGF0YSwgY2VsbCwgbG8pO1xuICAgICAgcmVuZGVyQ3VydmUoJ3RpZScsIGRhdGEpO1xuICAgICAgcmVuZGVyQ3VydmUoJ3NsdXInLCBkYXRhKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3RpbWUnOlxuICAgICAgZGF0YS5lbCA9IGNlbGwuZWwudXNlKGRhdGEuZGVmLmVsKS5hdHRyKHtcbiAgICAgICAgeDogZGF0YS54LCB5OiBkYXRhLnlcbiAgICAgIH0pO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBSZW5kZXJlcjtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zcmMvcmVuZGVyZXIvUmVuZGVyZXIvUmVuZGVyZXIuanNcbiAqKiBtb2R1bGUgaWQgPSAyMlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFXzIzX187XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiBleHRlcm5hbCBcIlNuYXBcIlxuICoqIG1vZHVsZSBpZCA9IDIzXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlsID0gcmVxdWlyZSgnLi4vLi4vdXRpbCcpO1xudmFyIGxheW91dE9wdGlvbnMgPSByZXF1aXJlKCcuL2xheW91dE9wdGlvbnMnKTtcbnZhciBEZWZzID0gcmVxdWlyZSgnLi4vZGVmcy9EZWZzJyk7XG52YXIgU3ZnTGF5b3V0ID0gcmVxdWlyZSgnLi9TdmdMYXlvdXQnKTtcbnZhciBCb2R5TGF5b3V0ID0gcmVxdWlyZSgnLi9Cb2R5TGF5b3V0Jyk7XG52YXIgSGVhZGVyTGF5b3V0ID0gcmVxdWlyZSgnLi9IZWFkZXJMYXlvdXQnKTtcbnZhciBDb250ZW50TGF5b3V0ID0gcmVxdWlyZSgnLi9Db250ZW50TGF5b3V0Jyk7XG5cbnZhciBUaW1ld2lzZU1lYXN1cmUgPSByZXF1aXJlKCcuLi8uLi9tb2RlbC9UaW1ld2lzZU1lYXN1cmUnKTtcbnZhciBUaW1ld2lzZU1lYXN1cmVMYXlvdXRNaXhpbiA9IHJlcXVpcmUoJy4vVGltZXdpc2VNZWFzdXJlTGF5b3V0TWl4aW4nKTtcbnZhciBDZWxsID0gcmVxdWlyZSgnLi4vLi4vbW9kZWwvQ2VsbCcpO1xudmFyIENlbGxMYXlvdXRNaXhpbiA9IHJlcXVpcmUoJy4vQ2VsbExheW91dE1peGluJyk7XG52YXIgTXVzaWNEYXRhTGF5b3V0TWl4aW4gPSByZXF1aXJlKCcuL011c2ljRGF0YUxheW91dE1peGluJyk7XG5bXG4gIHJlcXVpcmUoJy4uLy4uL21vZGVsL1RpbWUnKSxcbiAgcmVxdWlyZSgnLi4vLi4vbW9kZWwvQmFyJyksXG4gIHJlcXVpcmUoJy4uLy4uL21vZGVsL05vdGUnKSxcbiAgcmVxdWlyZSgnLi4vLi4vbW9kZWwvUmVzdCcpLFxuICByZXF1aXJlKCcuLi8uLi9tb2RlbC9DaG9yZCcpLFxuICByZXF1aXJlKCcuLi8uLi9tb2RlbC9Wb2ljZScpXG5dLmZvckVhY2goZnVuY3Rpb24gKENsYXNzKSB7XG4gIHV0aWwuZGVmaW5lUHJvcGVydGllcyhDbGFzcy5wcm90b3R5cGUsIE11c2ljRGF0YUxheW91dE1peGluKTtcbn0pO1xudXRpbC5kZWZpbmVQcm9wZXJ0aWVzKFRpbWV3aXNlTWVhc3VyZS5wcm90b3R5cGUsIFRpbWV3aXNlTWVhc3VyZUxheW91dE1peGluKTtcbnV0aWwuZGVmaW5lUHJvcGVydGllcyhDZWxsLnByb3RvdHlwZSwgQ2VsbExheW91dE1peGluKTtcblxuLyoqXG4gKiBAY2xhc3NcbiAqIEBwYXJhbSBzdmcge3N0cmluZ31cbiAqIEBwYXJhbSBvcHRpb25zIHtPYmplY3R9IExheW91dCBvcHRpb25zXG4gKi9cbmZ1bmN0aW9uIExheW91dChzdmcsIG9wdGlvbnMpIHtcbiAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgdGhpcy5zdmcgPSBzdmc7XG5cbiAgdGhpcy5zdmcgPSBuZXcgU3ZnTGF5b3V0KHRoaXMpO1xuICB0aGlzLmJvZHkgPSBuZXcgQm9keUxheW91dCh0aGlzKTtcbiAgdGhpcy5oZWFkZXIgPSBuZXcgSGVhZGVyTGF5b3V0KHRoaXMpO1xuICB0aGlzLmNvbnRlbnQgPSBuZXcgQ29udGVudExheW91dCh0aGlzKTtcblxuICB0aGlzLmRlZnMgPSBuZXcgRGVmcyh0aGlzKTtcbn1cblxuTGF5b3V0Lm9wdGlvbnMgPSBsYXlvdXRPcHRpb25zO1xuXG51dGlsLmRlZmluZVByb3BlcnRpZXMoTGF5b3V0LnByb3RvdHlwZSxcbi8qKiBAbGVuZHMgTGF5b3V0IyAqL1xue1xuICAvKipcbiAgICogQHBhcmFtICB7U2NvcmV9IHNjb3JlXG4gICAqL1xuICBmbG93OiBmdW5jdGlvbiAoc2NvcmUpIHtcbiAgICBpbml0KHRoaXMsIHNjb3JlKTtcbiAgICB0aGlzLmNvbnRlbnQuZmxvdyhzY29yZS5tZWFzdXJlcyk7XG4gIH1cbn0pO1xuXG5mdW5jdGlvbiBpbml0KHRoYXQsIHNjb3JlKSB7XG4gIHZhciBtZWFzdXJlcyA9IHNjb3JlLm1lYXN1cmVzO1xuICBtZWFzdXJlcy5mb3JFYWNoKGZ1bmN0aW9uIChtZWFzdXJlLCBtKSB7XG4gICAgbWVhc3VyZSA9IG1lYXN1cmVzW21dO1xuICAgIG1lYXN1cmUubGF5b3V0ID0gdGhhdDtcbiAgICBtZWFzdXJlLnBhcnRzLmZvckVhY2goZnVuY3Rpb24gKGNlbGwpIHtcbiAgICAgIGNlbGwubGF5b3V0ID0gdGhhdDtcbiAgICAgIGNlbGwuZmxvdygpO1xuICAgIH0pO1xuICB9KTtcbn1cbm1vZHVsZS5leHBvcnRzID0gTGF5b3V0O1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NyYy9yZW5kZXJlci9MYXlvdXQvTGF5b3V0LmpzXG4gKiogbW9kdWxlIGlkID0gMjRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWwgPSByZXF1aXJlKCcuLi8uLi91dGlsJyk7XG5cbnZhciBsYXlvdXRPcHRpb25zID0ge1xuICBtb2RlOiAnYmxvY2snLCAvLyBpbmxpbmUgfCBibG9jayB8IHBhcGVyXG4gIC8vIHdpZHRoOiA2NTAsXG4gIC8vIGhlaWdodDogNjAwLFxuICBtYXJnaW5Ub3A6IDI1LFxuICBtYXJnaW5SaWdodDogMzAsXG4gIG1hcmdpbkJvdHRvbTogMjUsXG4gIG1hcmdpbkxlZnQ6IDMwLFxuICBtYXJnaW46IHtcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBbdGhpcy5tYXJnaW5Ub3AsIHRoaXMubWFyZ2luUmlnaHQsIHRoaXMubWFyZ2luQm90dG9tLCB0aGlzLm1hcmdpbkxlZnRdO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiAoYXJyKSB7XG4gICAgICBzd2l0Y2ggKGFyci5sZW5ndGgpIHtcbiAgICAgIGNhc2UgMTpcbiAgICAgICAgdGhpcy5tYXJnaW5Ub3AgPSB0aGlzLm1hcmdpblJpZ2h0ID0gdGhpcy5tYXJnaW5Cb3R0b20gPSB0aGlzLm1hcmdpbkxlZnQgPSBhcnJbMF07XG4gICAgICAgIHJldHVybjtcbiAgICAgIGNhc2UgMjpcbiAgICAgICAgdGhpcy5tYXJnaW5Ub3AgPSB0aGlzLm1hcmdpbkJvdHRvbSA9IGFyclswXTtcbiAgICAgICAgdGhpcy5tYXJnaW5SaWdodCA9IHRoaXMubWFyZ2luTGVmdCA9IGFyclsxXTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgY2FzZSA0OlxuICAgICAgICB0aGlzLm1hcmdpblRvcCA9IGFyclswXTtcbiAgICAgICAgdGhpcy5tYXJnaW5SaWdodCA9IGFyclsxXTtcbiAgICAgICAgdGhpcy5tYXJnaW5Cb3R0b20gPSBhcnJbMl07XG4gICAgICAgIHRoaXMubWFyZ2luTGVmdCA9IGFyclszXTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGlucHV0IGZvciBtYXJnaW4uJyk7XG4gICAgICB9XG4gICAgfVxuICB9LFxuICBmb250U2l6ZTogMjAsXG4gIGZvbnRGYW1pbHk6ICdIZWx2ZXRpY2EsIEFyaWFsLCBTYW5zIFNlcmlmJyxcblxuICB0aXRsZUZvbnRTaXplOiAnMTEwJScsXG4gIC8vIHRpdGxlRm9udEZhbWlseVxuICB0aXRsZUZvbnRXZWlnaHQ6ICdib2xkJyxcbiAgY29tcG9zZXJGb250U2l6ZTogJzkwJScsXG4gIC8vIGNvbXBvc2VyRm9udEZhbWlseTpcbiAgY29tcG9zZXJGb250V2VpZ2h0OiAnYm9sZCcsXG4gIC8vIGNvbXBvc2VyRm9udFN0eWxlLFxuICB0aW1lRm9udFNpemU6ICc5NSUnLFxuICB0aW1lRm9udFdlaWdodDogJ2JvbGQnLFxuXG4gIGhlYWRlclNlcDogJzEwMCUnLFxuICBzeXN0ZW1TZXA6ICcxODAlJyxcbiAgbXVzaWNEYXRhU2VwOiAnMjAlJyxcblxuICBwYXJ0SGVpZ2h0OiAnMTIwJScsXG4gIHBhcnRTZXA6ICc4MCUnLFxuXG4gIG1lYXN1cmVQYWRkaW5nTGVmdDogJzUwJScsXG4gIG1lYXN1cmVQYWRkaW5nUmlnaHQ6ICc1MCUnLFxuXG4gIGJhcmxpbmVIZWlnaHQ6ICcxMjAlJyxcbiAgdGhpbkJhcmxpbmVXaWR0aDogJzQlJyxcbiAgdGhpY2tCYXJsaW5lV2lkdGg6ICcxNiUnLFxuICBiYXJsaW5lU2VwOiAnMTglJyxcbiAgYmFybGluZURvdFJhZGl1czogJzcuNSUnLFxuICBiYXJsaW5lRG90U2VwOiAnMjIlJyxcblxuICBhY2NpZGVudGFsRm9udFNpemU6ICc5NSUnLFxuICBhY2NpZGVudGFsU2hpZnQ6ICcxMCUnLFxuXG4gIG9jdGF2ZVJhZGl1czogJzYuNiUnLFxuICBvY3RhdmVPZmZzZXQ6ICcwJScsXG4gIG9jdGF2ZVNlcDogJzIzJScsXG5cbiAgc3RlcEJhc2VsaW5lU2hpZnQ6ICcxMiUnLCAgLy8gZm9yIHN0ZXAgd2l0aG91dCBsb3dlciBvY3RhdmUgYW5kIHVuZGVybGluZVxuXG4gIHR5cGVTdHJva2VXaWR0aDogJzUlJyxcbiAgdHlwZWJhck9mZnNldDogJzMwJScsICAgLy8gMSAtIC0gLVxuICB0eXBlYmFyTGVuZ3RoOiAnNTUlJywgICAvLyBvZmYgbGVuIHNlcCBsZW4gc2VwIGxlbiAoZG90KSBleHRcbiAgdHlwZWJhclNlcDogJzQ1JScsICAgICAgLy8gMSAtXG4gIHR5cGViYXJFeHQ6ICcyMCUnLCAgICAgIC8vIG9mZiBsZW4gKGRvdCkgZXh0XG4gIHVuZGVyYmFyU2VwOiAnMTclJyxcblxuICBkb3RPZmZzZXQ6ICc2MCUnLCAgICAgICAvLyBmb3IgdHlwZSA9IDJcbiAgZG90UmFkaXVzOiAnNi42JScsICAgICAgLy8gMSAtIC4gLlxuICBkb3RTZXA6ICc2MCUnLCAgICAgICAgICAvLyBvZmYgbGVuIGRvdE9mZiAuIGRvdFNlcCAuIGV4dFxuICB0NERvdE9mZnNldDogJzMwJScsXG4gIHQ0RG90U2VwOiAnNTAlJyxcbiAgdDREb3RFeHQ6ICcyNSUnLFxuICB0NERvdEJhc2VsaW5lU2hpZnQ6ICcyMCUnXG59O1xuXG52YXIgZm9udFNpemUgPSBsYXlvdXRPcHRpb25zLmZvbnRTaXplO1xuXG51dGlsLm9iakVhY2gobGF5b3V0T3B0aW9ucywgZnVuY3Rpb24gKHZhbHVlLCBrZXkpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycpIHsgcmV0dXJuOyB9XG5cbiAgdmFyIHVuaXQgPSB2YWx1ZS5yZXBsYWNlKC9bXFxkXFwuXSsvLCAnJyk7XG4gIHZhbHVlID0gK3ZhbHVlLnJlcGxhY2UoL1teXFxkXFwuXSsvLCAnJyk7XG5cbiAgc3dpdGNoICh1bml0KSB7XG4gIGNhc2UgJyUnOlxuICAgIGxheW91dE9wdGlvbnNba2V5XSA9IGZvbnRTaXplICogdmFsdWUgLyAxMDA7XG4gICAgYnJlYWs7XG4gIGNhc2UgJyc6IC8vIGZhbGwgdGhyb3VnaFxuICBjYXNlICdweCc6XG4gICAgbGF5b3V0T3B0aW9uc1trZXldID0gdmFsdWU7XG4gICAgYnJlYWs7XG4gIGNhc2UgJ290aGVycyB0byBiZSBpbXBsZW1lbnRlZCc6XG4gICAgYnJlYWs7XG4gIH1cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGxheW91dE9wdGlvbnM7XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc3JjL3JlbmRlcmVyL0xheW91dC9sYXlvdXRPcHRpb25zLmpzXG4gKiogbW9kdWxlIGlkID0gMjVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWwgPSByZXF1aXJlKCcuLi8uLi91dGlsJyk7XG52YXIgQWNjaWRlbnRhbERlZiA9IHJlcXVpcmUoJy4vQWNjaWRlbnRhbERlZicpO1xudmFyIEJhckRlZiA9IHJlcXVpcmUoJy4vQmFyRGVmJyk7XG52YXIgRHVyYXRpb25EZWYgPSByZXF1aXJlKCcuL0R1cmF0aW9uRGVmJyk7XG52YXIgUGl0Y2hEZWYgPSByZXF1aXJlKCcuL1BpdGNoRGVmJyk7XG52YXIgVGltZURlZiA9IHJlcXVpcmUoJy4vVGltZURlZicpO1xuXG52YXIgZGVmSWRNaXhpbnMgPSByZXF1aXJlKCcuL2RlZklkTWl4aW5zJyk7XG52YXIgVGltZSA9IHJlcXVpcmUoJy4uLy4uL21vZGVsL1RpbWUnKTtcbnZhciBCYXIgPSByZXF1aXJlKCcuLi8uLi9tb2RlbC9CYXInKTtcbnZhciBOb3RlID0gcmVxdWlyZSgnLi4vLi4vbW9kZWwvTm90ZScpO1xudmFyIFJlc3QgPSByZXF1aXJlKCcuLi8uLi9tb2RlbC9SZXN0Jyk7XG52YXIgUGl0Y2ggPSByZXF1aXJlKCcuLi8uLi9tb2RlbC9QaXRjaCcpO1xudmFyIER1cmF0aW9uID0gcmVxdWlyZSgnLi4vLi4vbW9kZWwvRHVyYXRpb24nKTtcbnV0aWwuZGVmaW5lUHJvcGVydGllcyhUaW1lLnByb3RvdHlwZSwgZGVmSWRNaXhpbnMuVGltZSk7XG51dGlsLmRlZmluZVByb3BlcnRpZXMoQmFyLnByb3RvdHlwZSwgZGVmSWRNaXhpbnMuQmFyKTtcbnV0aWwuZGVmaW5lUHJvcGVydGllcyhOb3RlLnByb3RvdHlwZSwgZGVmSWRNaXhpbnMuTm90ZSk7XG51dGlsLmRlZmluZVByb3BlcnRpZXMoUmVzdC5wcm90b3R5cGUsIGRlZklkTWl4aW5zLlJlc3QpO1xudXRpbC5kZWZpbmVQcm9wZXJ0aWVzKFBpdGNoLnByb3RvdHlwZSwgZGVmSWRNaXhpbnMuUGl0Y2gpO1xudXRpbC5kZWZpbmVQcm9wZXJ0aWVzKER1cmF0aW9uLnByb3RvdHlwZSwgZGVmSWRNaXhpbnMuRHVyYXRpb24pO1xuXG5cbi8qKlxuICogQGNsYXNzXG4gKiBAcGFyYW0ge0xheW91dH0gbGF5b3V0XG4gKi9cbmZ1bmN0aW9uIERlZnMobGF5b3V0KSB7XG4gIHRoaXMuX2xheW91dCA9IGxheW91dDtcbn1cblxudXRpbC5kZWZpbmVQcm9wZXJ0aWVzKERlZnMucHJvdG90eXBlLFxuLyoqIEBsZW5kcyBEZWZzIyAqL1xue1xuICAvKipcbiAgICogR2V0IHRoZSBzdmcgZGVmIG9mIHRoZSBtdXNpYyBkYXRhLlxuICAgKiBAcGFyYW0gIG11c2ljRGF0YSB7TXVzaWNEYXRhTWl4aW59IG11c2ljIGRhdGFcbiAgICogQHJldHVybiB7RGVmfVxuICAgKi9cbiAgZ2V0OiBmdW5jdGlvbiAobXVzaWNEYXRhKSB7XG4gICAgdmFyIGlkID0gbXVzaWNEYXRhLmRlZklkO1xuICAgIHJldHVybiB0aGlzW2lkXSB8fCAodGhpc1tpZF0gPSBtYWtlRGVmKGlkLCBtdXNpY0RhdGEsIHRoaXMpKTtcbiAgfSxcblxuICBnZXRBY2NpZGVudGFsOiBmdW5jdGlvbiAoYWNjaWRlbnRhbCkge1xuICAgIHZhciBpZCA9ICdhJyArIGFjY2lkZW50YWwucmVwbGFjZSgvIy9nLCAncycpO1xuICAgIHJldHVybiB0aGlzW2lkXSB8fFxuICAgICAgICAgICh0aGlzW2lkXSA9IG5ldyBBY2NpZGVudGFsRGVmKGlkLCBhY2NpZGVudGFsLCB0aGlzLl9sYXlvdXQpKTtcbiAgfSxcblxuICBfZ2V0UGl0Y2g6IGZ1bmN0aW9uIChpZCwgcGl0Y2gsIHVuZGVyYmFyKSB7XG4gICAgcmV0dXJuIHRoaXNbaWRdIHx8XG4gICAgICAgICAgKHRoaXNbaWRdID0gbmV3IFBpdGNoRGVmKGlkLCBwaXRjaCwgdW5kZXJiYXIsIHRoaXMpKTtcbiAgfVxufSk7XG5cblxuZnVuY3Rpb24gbWFrZURlZihpZCwgbXVzaWNEYXRhLCBkZWZzKSB7XG4gIHN3aXRjaCAobXVzaWNEYXRhLiR0eXBlKSB7XG4gIGNhc2UgJ2Jhcic6XG4gICAgcmV0dXJuIG5ldyBCYXJEZWYoaWQsIG11c2ljRGF0YSwgZGVmcy5fbGF5b3V0KTtcbiAgY2FzZSAndGltZSc6XG4gICAgcmV0dXJuIG5ldyBUaW1lRGVmKGlkLCBtdXNpY0RhdGEsIGRlZnMuX2xheW91dCk7XG4gIGNhc2UgJ25vdGUnOlxuICAgIHJldHVybiBtYWtlTm90ZURlZihtdXNpY0RhdGEsIGRlZnMpO1xuICBjYXNlICdyZXN0JzpcbiAgICByZXR1cm4gbWFrZVJlc3REZWYobXVzaWNEYXRhLCBkZWZzKTtcbiAgY2FzZSAnZHVyYXRpb24nOlxuICAgIHJldHVybiBuZXcgRHVyYXRpb25EZWYoaWQsIG11c2ljRGF0YSwgZGVmcy5fbGF5b3V0KTtcbiAgZGVmYXVsdDpcbiAgICByZXR1cm4geyB3aWR0aDogMCwgaGVpZ2h0OiAwIH07XG4gIH1cbn1cblxuZnVuY3Rpb24gbWFrZU5vdGVEZWYobm90ZSwgZGVmcykge1xuICB2YXIgdW5kZXJiYXIgPSBub3RlLmR1cmF0aW9uLnVuZGVyYmFyO1xuICB2YXIgcGl0Y2hJZCA9IG5vdGUucGl0Y2guZGVmSWQgKyB1bmRlcmJhcjtcbiAgdmFyIHBpdGNoRGVmID0gZGVmcy5fZ2V0UGl0Y2gocGl0Y2hJZCwgbm90ZS5waXRjaCwgdW5kZXJiYXIpO1xuICB2YXIgZHVyYXRpb25EZWYgPSBkZWZzLmdldChub3RlLmR1cmF0aW9uKTtcbiAgcmV0dXJuIHtcbiAgICBwaXRjaERlZjogcGl0Y2hEZWYsXG4gICAgZHVyYXRpb25EZWY6IGR1cmF0aW9uRGVmLFxuICAgIGhlaWdodDogcGl0Y2hEZWYuaGVpZ2h0LFxuICAgIHdpZHRoOiBwaXRjaERlZi53aWR0aCArIGR1cmF0aW9uRGVmLndpZHRoICpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAodW5kZXJiYXIgPyBwaXRjaERlZi5zY2FsZS54IDogMSlcbiAgfTtcbn1cblxuZnVuY3Rpb24gbWFrZVJlc3REZWYocmVzdCwgZGVmcykge1xuICB2YXIgcmVzdE5vdGUgPSBuZXcgTm90ZSh7XG4gICAgcGl0Y2g6IHsgc3RlcDogMCB9LCBkdXJhdGlvbjogcmVzdC5kdXJhdGlvblxuICB9KTtcbiAgcmV0dXJuIG1ha2VOb3RlRGVmKHJlc3ROb3RlLCBkZWZzKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBEZWZzO1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NyYy9yZW5kZXJlci9kZWZzL0RlZnMuanNcbiAqKiBtb2R1bGUgaWQgPSAyNlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIFNuYXAgPSByZXF1aXJlKCdTbmFwJyk7XHJcbnZhciBzdmdQYXRocyA9IHJlcXVpcmUoJy4uL3N2Z1BhdGhzJyk7XHJcblxyXG4vKipcclxuICogU1ZHIGRlZmluaXRpb24gZm9yIGFjY2lkZW50YWwuXHJcbiAqIEBjbGFzc1xyXG4gKiBAcGFyYW0ge3N0cmluZ30gaWQgICAgICAgICBbZGVzY3JpcHRpb25dXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBhY2NpZGVudGFsIFtkZXNjcmlwdGlvbl1cclxuICogQHBhcmFtIHtMYXlvdXR9IGxheW91dCAgICAgW2Rlc2NyaXB0aW9uXVxyXG4gKi9cclxuZnVuY3Rpb24gQWNjaWRlbnRhbERlZihpZCwgYWNjaWRlbnRhbCwgbGF5b3V0KSB7XHJcbiAgdmFyIGxvID0gbGF5b3V0Lm9wdGlvbnM7XHJcbiAgdmFyIGVsID0gdGhpcy5lbCA9IGxheW91dC5zdmcuZWwuZygpLmF0dHIoJ2lkJywgaWQpO1xyXG4gIHZhciBhY2NLZXkgPSBhY2NpZGVudGFsLnJlcGxhY2UoL2JiLywgJ2InKTsgLy8gZG91YmxlIGZsYXQgdG8gYmUgc3ludGhlc2l6ZWRcclxuICB2YXIgcGF0aERhdGEgPSBzdmdQYXRoc1thY2NLZXldO1xyXG4gIHZhciByYXRpbyA9IHN2Z1BhdGhzLkFDQ0lERU5UQUxfUkFUSU9TW2FjY0tleV07XHJcbiAgdmFyIHNoaWZ0ID0gc3ZnUGF0aHMuQUNDSURFTlRBTF9TSElGVFNbYWNjS2V5XTtcclxuICB2YXIgcGF0aCA9IGVsLnBhdGgocGF0aERhdGEpO1xyXG4gIHZhciBiYiA9IGVsLmdldEJCb3goKTtcclxuXHJcbiAgcGF0aC50cmFuc2Zvcm0oU25hcC5tYXRyaXgoKVxyXG4gICAgLnRyYW5zbGF0ZSgwLjEgKiBsby5hY2NpZGVudGFsU2hpZnQsIC1sby5hY2NpZGVudGFsU2hpZnQpXHJcbiAgICAuc2NhbGUocmF0aW8gKiBsby5hY2NpZGVudGFsRm9udFNpemUpXHJcbiAgICAudHJhbnNsYXRlKC1iYi54LCBzaGlmdCAtIGJiLnkyKVxyXG4gICk7XHJcblxyXG4gIC8vIENvbWJpbmUgdHdvIGZsYXQgdG8gYmUgZG91YmxlIGZsYXQuXHJcbiAgaWYgKGFjY2lkZW50YWwgPT09ICdiYicpIHtcclxuICAgIGVsLnVzZShwYXRoKS5hdHRyKCd4JywgbG8uYWNjaWRlbnRhbEZvbnRTaXplICogMC4yNCk7XHJcbiAgICBlbC50cmFuc2Zvcm0oJ3NjYWxlKDAuOSwxKScpO1xyXG4gIH1cclxuXHJcbiAgYmIgPSBlbC5nZXRCQm94KCk7XHJcbiAgdGhpcy53aWR0aCA9IGJiLndpZHRoICogMS4yO1xyXG5cclxuICBlbC50b0RlZnMoKTtcclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBBY2NpZGVudGFsRGVmO1xyXG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc3JjL3JlbmRlcmVyL2RlZnMvQWNjaWRlbnRhbERlZi5qc1xuICoqIG1vZHVsZSBpZCA9IDI3XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbnZhciBzdmdQYXRocyA9IHtcblxuICAvLyBodHRwczovL3VwbG9hZC53aWtpbWVkaWEub3JnL3dpa2lwZWRpYS9jb21tb25zL2EvYTYvU2hhcnAuc3ZnXG4gICcjJzogJ002LjEwMiw3LjQ1N1YyLjc1M0w4LjEwMiwyLjIwMVY2Ljg4MUw2LjEwMiw3LjQ1N3pNMTAuMDQsNi4zMTlMOC42NjUsNi43MTNWMi4wMzNMMTAuMDQsMS42NDlWLTAuMjk1TDguNjY1LDAuMDg5Vi00LjY5Mjc3SDguMTAyVjAuMjM0TDYuMTAyLDAuODA5Vi0zLjg0MDc3SDUuNTcxVjAuOTg2TDQuMTk2LDEuMzcxVjMuMzE5TDUuNTcxLDIuOTM1VjcuNjA2TDQuMTk2LDcuOTg5VjkuOTI5TDUuNTcxLDkuNTQ1VjE0LjI5OUw2LjEwMiwxNC4yOTk3N1Y5LjM3NUw4LjEwMiw4LjgyNVYxMy40NTA3N0g4LjY2NVY4LjY1MUwxMC4wNCw4LjI2NlY2LjMxOXonLFxuXG4gIC8vIGh0dHBzOi8vdXBsb2FkLndpa2ltZWRpYS5vcmcvd2lraXBlZGlhL2NvbW1vbnMvMy8zYS9Eb3VibGVTaGFycC5zdmdcbiAgJyMjJzogJ001LjAwOSw4LjMwNzIxQzQuMjc0NDMsOC4xOTE5MiAzLjUyNzY5LDguMTkyMDkgMi43ODU4LDguMTkyOTRDMi43NzAwNyw3LjY1MDExIDIuODU2NzQsNy4wNzI5IDIuNjQxNSw2LjU2MzQzQzIuNDk4MjEsNi4yMjQyNiAyLjIyNTMyLDUuOTU2NjUgMS45ODI2OSw1LjY4MTU1QzEuNTk1NTIsNi4wMjc4IDEuMjc3NTEsNi40ODQ3NSAxLjI0NzA0LDcuMDE2MzhDMS4yMTcwNiw3LjQwNzY3IDEuMjM5MDIsNy44MDA4NSAxLjIzMjIsOC4xOTI5NEMwLjQ5MDQsOC4yMDQxNi0wLjI1OTE4LDguMTY4MjgtMC45OTEsOC4zMTRDLTAuODQ5ODgsNy41ODYzLTAuODgxOTUsNi44NDE3MS0wLjg2OTE3LDYuMTA0OEMtMC4zMDQzLDYuMDg5NTMgMC4zMDAyMyw2LjE3MTAxIDAuODI0ODQsNS45MjUyNkMxLjEzNDQxLDUuNzgwMjMgMS4zOTY1Myw1LjU1Mjk1IDEuNjU5MSw1LjMzNjc2QzEuMzE3Myw0Ljk0OTY1IDAuODczNDYsNC42MDg2MSAwLjMzNjY1LDQuNTc2NTFDLTAuMDY0MjcsNC41NDQ4NS0wLjQ2NzM0LDQuNTY3OTMtMC44NjkxNyw0LjU2MDk3Qy0wLjg5NDM0LDMuODI5NDktMC44MDg5NSwzLjA4ODU1LTAuOTYwNzksMi4zNjYzQy0wLjIzNzMzLDIuNDk2OTcgMC41MDA2NSwyLjQ2MzQzIDEuMjMyMiwyLjQ3Mjg0QzEuMjQzMDYsMi45OTM4MyAxLjE4NDgzLDMuNTMzODEgMS4zMzE5MSw0LjAzNTVDMS40NDQxNCw0LjQxODM4IDEuNzQ5NzgsNC43MTI5MyAyLjAwNTEsNS4wMTUyMUMyLjM2NTUzLDQuNzAxMTEgMi42OTA1Nyw0LjMwNzA2IDIuNzUwMTEsMy44MTQxMkMyLjgwNCwzLjM2NzkzIDIuNzYxMjMsMi45MTk3NyAyLjc4NTgsMi40NzI4NEMzLjUyMjYzLDIuNDUzNDggNC4yODIxNSwyLjU0NzEzIDQuOTk1MzUsMi4zMTRDNC44ODg5MSwzLjA1NzExIDQuODc4ODksMy44MTE1MiA0Ljg4NzE3LDQuNTYwOTdDNC4zNjEyNyw0LjU3NTgyIDMuODA5NTQsNC41MTc0NyAzLjMwOTU1LDQuNjk0NTdDMi45Mjk3NSw0LjgyOTEgMi42MzExNCw1LjEyMzQxIDIuMzI4NjksNS4zODMyNUMyLjY1NjYxLDUuNzE4NjcgMy4wNTE2LDYuMDI4MDIgMy41NDAzLDYuMDczNjhDMy45ODgzNCw2LjExNTU0IDQuNDM4MjksNi4wOTY1OCA0Ljg4NzE3LDYuMTA0OEM0Ljg5ODI4LDYuODM5NTggNC44NjE5Myw3LjU4MjUgNS4wMDksOC4zMDcyMXonLFxuXG4gIC8vIGh0dHBzOi8vdXBsb2FkLndpa2ltZWRpYS5vcmcvd2lraXBlZGlhL2NvbW1vbnMvYi9iYS9GbGF0LnN2Z1xuICBiOiAnTTguMTY2LDMuNjU3QzguMTY2LDQuMjMyIDcuOTUwNDI1LDQuNzgyNzMgNy4zNTksNS41MjE4OEM2LjczMjQzNSw2LjMwNDk0IDYuMjA1LDYuNzUzMTMgNS41MSw3LjI4MDEzVjMuODQ4QzUuNjY4LDMuNDQ5IDUuOTAxLDMuMTI2IDYuMjEsMi44NzhDNi41MTgsMi42MzEgNi44MywyLjUwNyA3LjE0NiwyLjUwN0M3LjY2OCwyLjUwNyA3Ljk5OSwyLjgwMyA4LjE0MiwzLjM5M0M4LjE1OCwzLjQ0MSA4LjE2NiwzLjUyOSA4LjE2NiwzLjY1N3pNOC4wOTEsMS4yNTdDNy42NiwxLjI1NyA3LjIyMiwxLjM3NiA2Ljc3NiwxLjYxNUM2LjMzLDEuODUzIDUuOTA4LDIuMTcyIDUuNTEsMi41NjlWLTQuNzAyNjdINC45NDcgVjcuNzUyMTNDNC45NDcsOC4xMDQxMyA1LjA0Myw4LjI4MDEzIDUuMjM1LDguMjgwMTNDNS4zNDYsOC4yODAxMyA1LjQ4MzkxMyw4LjE4NzEzIDUuNjksOC4wNjQxM0M2LjI3MzM0LDcuNzE1OTggNi42MzY5MzUsNy40ODMzMiA3LjAzMiw3LjIzNzg4QzcuNDgyNjE3LDYuOTU3OTIgNy45OSw2LjYzMSA4LjY2MSw1Ljk5MUM5LjEyNCw1LjUyNiA5LjQ1OSw1LjA1NyA5LjY2Nyw0LjU4NUM5Ljg3NCw0LjExMiA5Ljk3OCwzLjY0NCA5Ljk3OCwzLjE3OUM5Ljk3OCwyLjQ5MSA5Ljc5NSwyLjAwMiA5LjQyOSwxLjcxM0M5LjAxNSwxLjQwOSA4LjU2OCwxLjI1NyA4LjA5MSwxLjI1N3onLFxuXG4gIC8vIGh0dHBzOi8vdXBsb2FkLndpa2ltZWRpYS5vcmcvd2lraXBlZGlhL2NvbW1vbnMvZi9mNC9NdXNpYy1uYXR1cmFsLnN2Z1xuICBuOiAnTSAwLDE0LjExMlY0MS41MmgtMS4yNDhWMzEuMjQ4bC02LjY3MiwxLjcyOFY1LjIzMmgxLjJ2MTAuNzA0bDYuNzIsLTEuODI0em0tNi43Miw2LjQzMnY3LjUzNmw1LjQ3MiwtMS40NHYtNy41MzZsLTUuNDcyLDEuNDR6JyxcblxuICBBQ0NJREVOVEFMX1JBVElPUzogeyAnIyc6IDAuMDQzLCAnbic6IDAuMDIzLCAnIyMnOiAwLjA2MiwgYjogMC4wNTcgfSxcbiAgQUNDSURFTlRBTF9TSElGVFM6IHsgJyMnOiAxLCAnbic6IDIsICcjIyc6IC00LCBiOiAwIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gc3ZnUGF0aHM7XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc3JjL3JlbmRlcmVyL3N2Z1BhdGhzLmpzXG4gKiogbW9kdWxlIGlkID0gMjhcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBTVkcgZGVmaW5pdGlvbiBmb3IgYmFybGluZS5cbiAqIEBjbGFzc1xuICogQHBhcmFtIHtzdHJpbmd9IGlkICAgICBbZGVzY3JpcHRpb25dXG4gKiBAcGFyYW0ge0Jhcn0gYmFyICAgIFtkZXNjcmlwdGlvbl1cbiAqIEBwYXJhbSB7TGF5b3V0fSBsYXlvdXQgW2Rlc2NyaXB0aW9uXVxuICovXG5mdW5jdGlvbiBCYXJEZWYoaWQsIGJhciwgbGF5b3V0KSB7XG4gIHZhciBsbyA9IGxheW91dC5vcHRpb25zO1xuICB2YXIgeCA9IDA7XG4gIHZhciBsaW5lV2lkdGg7XG4gIHRoaXMuZWwgPSBsYXlvdXQuc3ZnLmVsLmcoKS5hdHRyKCdpZCcsIGlkKS50b0RlZnMoKTtcblxuICBzd2l0Y2ggKGJhci52YWx1ZSkge1xuICBjYXNlICdzaW5nbGUnOlxuICAgIGxpbmVXaWR0aCA9IGxvLnRoaW5CYXJsaW5lV2lkdGg7XG4gICAgYWRkQmFybGluZSh0aGlzLCB4LCBsaW5lV2lkdGgpO1xuICAgIHggKz0gbGluZVdpZHRoO1xuICAgIGJyZWFrO1xuICBjYXNlICdkb3VibGUnOlxuICAgIGxpbmVXaWR0aCA9IGxvLnRoaW5CYXJsaW5lV2lkdGg7XG4gICAgYWRkQmFybGluZSh0aGlzLCB4LCBsaW5lV2lkdGgpO1xuICAgIHggKz0gbGluZVdpZHRoICsgbG8uYmFybGluZVNlcDtcbiAgICBhZGRCYXJsaW5lKHRoaXMsIHgsIGxpbmVXaWR0aCk7XG4gICAgeCArPSBsaW5lV2lkdGg7XG4gICAgYnJlYWs7XG4gIGNhc2UgJ2VuZCc6XG4gICAgbGluZVdpZHRoID0gbG8udGhpbkJhcmxpbmVXaWR0aDtcbiAgICBhZGRCYXJsaW5lKHRoaXMsIHgsIGxpbmVXaWR0aCk7XG4gICAgeCArPSBsaW5lV2lkdGggKyBsby5iYXJsaW5lU2VwO1xuICAgIGxpbmVXaWR0aCA9IGxvLnRoaWNrQmFybGluZVdpZHRoO1xuICAgIGFkZEJhcmxpbmUodGhpcywgeCwgbGluZVdpZHRoKTtcbiAgICB4ICs9IGxpbmVXaWR0aDtcbiAgICBicmVhaztcbiAgY2FzZSAncmVwZWF0LWJlZ2luJzpcbiAgICBsaW5lV2lkdGggPSBsby50aGlja0JhcmxpbmVXaWR0aDtcbiAgICBhZGRCYXJsaW5lKHRoaXMsIHgsIGxpbmVXaWR0aCk7XG4gICAgeCArPSBsaW5lV2lkdGggKyBsby5iYXJsaW5lU2VwO1xuICAgIGxpbmVXaWR0aCA9IGxvLnRoaW5CYXJsaW5lV2lkdGg7XG4gICAgYWRkQmFybGluZSh0aGlzLCB4LCBsaW5lV2lkdGgpO1xuICAgIHggKz0gbGluZVdpZHRoICsgbG8uYmFybGluZURvdFNlcCArIGxvLmJhcmxpbmVEb3RSYWRpdXM7XG4gICAgYnJlYWs7XG4gIGNhc2UgJ3JlcGVhdC1lbmQnOlxuICAgIHggPSBsby5iYXJsaW5lRG90U2VwICsgbG8uYmFybGluZURvdFJhZGl1cztcbiAgICBsaW5lV2lkdGggPSBsby50aGluQmFybGluZVdpZHRoO1xuICAgIGFkZEJhcmxpbmUodGhpcywgeCwgbGluZVdpZHRoKTtcbiAgICB4ICs9IGxpbmVXaWR0aCArIGxvLmJhcmxpbmVTZXA7XG4gICAgbGluZVdpZHRoID0gbG8udGhpY2tCYXJsaW5lV2lkdGg7XG4gICAgYWRkQmFybGluZSh0aGlzLCB4LCBsaW5lV2lkdGgpO1xuICAgIHggKz0gbGluZVdpZHRoO1xuICAgIGJyZWFrO1xuICBjYXNlICdyZXBlYXQtYm90aCc6XG4gICAgeCA9IGxvLmJhcmxpbmVEb3RTZXAgKyBsby5iYXJsaW5lRG90UmFkaXVzO1xuICAgIGxpbmVXaWR0aCA9IGxvLnRoaW5CYXJsaW5lV2lkdGg7XG4gICAgYWRkQmFybGluZSh0aGlzLCB4LCBsaW5lV2lkdGgpO1xuICAgIHggKz0gbGluZVdpZHRoICsgbG8uYmFybGluZVNlcDtcbiAgICBsaW5lV2lkdGggPSBsby50aGlja0JhcmxpbmVXaWR0aDtcbiAgICBhZGRCYXJsaW5lKHRoaXMsIHgsIGxpbmVXaWR0aCk7XG4gICAgeCArPSBsaW5lV2lkdGggKyBsby5iYXJsaW5lU2VwO1xuICAgIGxpbmVXaWR0aCA9IGxvLnRoaW5CYXJsaW5lV2lkdGg7XG4gICAgYWRkQmFybGluZSh0aGlzLCB4LCBsaW5lV2lkdGgpO1xuICAgIHggKz0gbGluZVdpZHRoICsgbG8uYmFybGluZURvdFNlcCArIGxvLmJhcmxpbmVEb3RSYWRpdXM7XG4gICAgYnJlYWs7XG4gIH1cbiAgdGhpcy53aWR0aCA9IHg7XG59XG5cbmZ1bmN0aW9uIGFkZEJhcmxpbmUodGhhdCwgeCwgd2lkdGgpIHtcbiAgdGhhdC5lbC5yZWN0KHgsIDAsIHdpZHRoLCAxKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBCYXJEZWY7XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc3JjL3JlbmRlcmVyL2RlZnMvQmFyRGVmLmpzXG4gKiogbW9kdWxlIGlkID0gMjlcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBTVkcgZGVmaW5pdGlvbiBmb3IgZHVyYXRpb24uXG4gKiBAY2xhc3NcbiAqIEBwYXJhbSB7c3RyaW5nfSBpZCAgICAgICBbZGVzY3JpcHRpb25dXG4gKiBAcGFyYW0ge0R1cmF0aW9ufSBkdXJhdGlvbiBbZGVzY3JpcHRpb25dXG4gKiBAcGFyYW0ge0xheW91dH0gbGF5b3V0ICAgW2Rlc2NyaXB0aW9uXVxuICovXG5mdW5jdGlvbiBEdXJhdGlvbkRlZihpZCwgZHVyYXRpb24sIGxheW91dCkge1xuICB0aGlzLl9pZCA9IGlkO1xuICB0aGlzLl9sYXlvdXQgPSBsYXlvdXQ7XG5cbiAgLy8gb25seSBtYWtlIGRlZiBlbCBmb3I6XG4gIC8vIGlkID0gZDEwLCBkMTEsIGQxMiwgZDIwLCBkMjEsIGQyMCwgZDQxLCBkNDBcbiAgc3dpdGNoIChkdXJhdGlvbi50eXBlKSB7XG4gIGNhc2UgMTogICAvLyB3aG9sZSBub3RlXG4gICAgbWFrZUVsKHRoaXMpO1xuICAgIG1ha2VUeXBlMSh0aGlzLCBpZCwgZHVyYXRpb24uZG90KTtcbiAgICBicmVhaztcbiAgY2FzZSAyOiAgIC8vIGhhbGYgbm90ZVxuICAgIG1ha2VFbCh0aGlzKTtcbiAgICBtYWtlVHlwZTIodGhpcywgaWQsIGR1cmF0aW9uLmRvdCk7XG4gICAgYnJlYWs7XG4gIGRlZmF1bHQ6ICAvLyBvdGhlciBub3RlIHR5cGVzIHR5cGUgcXVhcnRlciBub3RlIGRlZlxuICAgIGlmIChkdXJhdGlvbi5kb3QgPT09IDApIHtcbiAgICAgIHRoaXMud2lkdGggPSAwIDtcbiAgICB9IGVsc2Uge1xuICAgICAgbWFrZUVsKHRoaXMpO1xuICAgICAgbWFrZVR5cGU0KHRoaXMsIGlkLCBkdXJhdGlvbi5kb3QpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBtYWtlVHlwZTEodGhhdCwgaWQsIGRvdCkge1xuICB2YXIgbG8gPSB0aGF0Ll9sYXlvdXQub3B0aW9ucztcbiAgdmFyIHggPSBsby50eXBlYmFyT2Zmc2V0O1xuXG4gIGFkZExpbmUodGhhdCwgeCk7XG4gIHggKz0gbG8udHlwZWJhckxlbmd0aCArIGxvLnR5cGViYXJTZXA7XG4gIGFkZExpbmUodGhhdCwgeCk7XG4gIHggKz0gbG8udHlwZWJhckxlbmd0aCArIGxvLnR5cGViYXJTZXA7XG4gIGFkZExpbmUodGhhdCwgeCk7XG4gIHggKz0gbG8udHlwZWJhckxlbmd0aDtcblxuICB0aGF0LndpZHRoID0gYWRkRG90KHRoYXQsIHgsIGRvdCwgMSk7XG59XG5cbmZ1bmN0aW9uIG1ha2VUeXBlMih0aGF0LCBpZCwgZG90KSB7XG4gIHZhciBsbyA9IHRoYXQuX2xheW91dC5vcHRpb25zO1xuICB2YXIgeCA9IGxvLnR5cGViYXJPZmZzZXQ7XG5cbiAgYWRkTGluZSh0aGF0LCBsby50eXBlYmFyT2Zmc2V0KTtcbiAgeCArPSBsby50eXBlYmFyTGVuZ3RoO1xuICB0aGF0LndpZHRoID0gYWRkRG90KHRoYXQsIHgsIGRvdCwgMik7XG59XG5cbmZ1bmN0aW9uIG1ha2VUeXBlNCh0aGF0LCBpZCwgZG90KSB7XG4gIHZhciBsbyA9IHRoYXQuX2xheW91dC5vcHRpb25zO1xuICB2YXIgeCA9IGxvLnQ0RG90T2Zmc2V0O1xuICB0aGF0LmVsLmNpcmNsZSh4LCAtbG8udDREb3RCYXNlbGluZVNoaWZ0LCBsby5kb3RSYWRpdXMpO1xuXG4gIGlmIChkb3QgPiAxKSB7XG4gICAgeCArPSBsby50NERvdFNlcDtcbiAgICB0aGF0LmVsLmNpcmNsZSh4LCAtbG8udDREb3RCYXNlbGluZVNoaWZ0LCBsby5kb3RSYWRpdXMpO1xuICB9XG4gIHRoYXQud2lkdGggPSB4ICsgbG8udDREb3RFeHQ7XG59XG5cbmZ1bmN0aW9uIG1ha2VFbCh0aGF0KSB7XG4gIHRoYXQuZWwgPSB0aGF0Ll9sYXlvdXQuc3ZnLmVsLmcoKVxuICAgICAgICAgICAgICAuYXR0cignaWQnLCB0aGF0Ll9pZClcbiAgICAgICAgICAgICAgLnRvRGVmcygpO1xufVxuXG5mdW5jdGlvbiBhZGRMaW5lKHRoYXQsIHgpIHtcbiAgdmFyIGxvID0gdGhhdC5fbGF5b3V0Lm9wdGlvbnM7XG4gIHRoYXQuZWwucmVjdCh4LCAtbG8udHlwZVN0cm9rZVdpZHRoLFxuICAgICAgICAgICAgICAgbG8udHlwZWJhckxlbmd0aCwgbG8udHlwZVN0cm9rZVdpZHRoKTtcbn1cblxuLy8gQWRkIGRvdCBmb3IgdHlwZSAxICh3aG9sZSkgb3IgdHlwZSAyIChoYWxmKSBub3RlLlxuZnVuY3Rpb24gYWRkRG90KHRoYXQsIHgsIGRvdCwgdHlwZSkge1xuICB2YXIgbG8gPSB0aGF0Ll9sYXlvdXQub3B0aW9ucztcblxuICBpZiAoZG90ID4gMCkge1xuICAgIHggKz0gbG8uZG90T2Zmc2V0ICogKHR5cGUgPT09IDEgPyAxLjIgOiAxKTtcbiAgICB0aGF0LmVsLmNpcmNsZSh4LCAwLCBsby5kb3RSYWRpdXMpO1xuICB9XG4gIGlmIChkb3QgPiAxKSB7XG4gICAgeCArPSBsby5kb3RTZXAgKiAodHlwZSA9PT0gMSA/IDEuMiA6IDEpO1xuICAgIHRoYXQuZWwuY2lyY2xlKHgsIDAsIGxvLmRvdFJhZGl1cyk7XG4gIH1cbiAgcmV0dXJuIHggKyBsby50eXBlYmFyRXh0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IER1cmF0aW9uRGVmO1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NyYy9yZW5kZXJlci9kZWZzL0R1cmF0aW9uRGVmLmpzXG4gKiogbW9kdWxlIGlkID0gMzBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcblxudmFyIFNuYXAgPSByZXF1aXJlKCdTbmFwJyk7XG52YXIgdXRpbCA9IHJlcXVpcmUoJy4uLy4uL3V0aWwnKTtcblxuLyoqXG4gKiBTVkcgZGVmaW5pdGlvbiBmb3IgcGl0Y2guXG4gKiBUaGUgYFBpdGNoRGVmYCBpcyBkZWZpbmVkIGJ5IHByb3BlcnRpZXM6IGEgcyBvIHVcbiAqIGFjY2lkZW50YWwgc3RlcCBvY3RhdmUgdW5kZXJiYXJcbiAqIEBjbGFzc1xuICogQHBhcmFtIGlkIHtzdHJpbmd9ICAgICBbZGVzY3JpcHRpb25dXG4gKiBAcGFyYW0gcGl0Y2gge1BpdGNofSAgIFtkZXNjcmlwdGlvbl1cbiAqIEBwYXJhbSBsYXlvdXQge0xheW91dH0gW2Rlc2NyaXB0aW9uXVxuICovXG5mdW5jdGlvbiBQaXRjaERlZihpZCwgcGl0Y2gsIHVuZGVyYmFyLCBkZWZzKSB7XG4gIHZhciBsYXlvdXQgPSB0aGlzLl9sYXlvdXQgPSBkZWZzLl9sYXlvdXQ7XG4gIHZhciBhY2NpZGVudGFsID0gcGl0Y2guYWNjaWRlbnRhbDtcbiAgdmFyIG9jdGF2ZSA9IHBpdGNoLm9jdGF2ZTtcbiAgdmFyIHNjYWxlID0gZ2V0U2NhbGUoYWNjaWRlbnRhbCwgb2N0YXZlLCB1bmRlcmJhcik7XG4gIHZhciBlbCA9IHRoaXMuZWwgPSBsYXlvdXQuc3ZnLmVsLmcoKVxuICAgIC5hdHRyKHtcbiAgICAgIGlkOiBpZCxcbiAgICAgIHN0cm9rZTogJ2JsYWNrJyxcbiAgICAgIHN0cm9rZVdpZHRoOiAyIC0gKHNjYWxlLnggKyBzY2FsZS55KVxuICAgIH0pO1xuICB2YXIgbWF0cml4LCBzYmJveCwgcGJib3g7XG5cbiAgdGhpcy5fZGVmcyA9IGRlZnM7XG4gIGFkZEFjY2lkZW50YWwodGhpcywgYWNjaWRlbnRhbCk7XG4gIGFkZFN0ZXAodGhpcywgcGl0Y2guc3RlcCk7XG4gIGFkZE9jdGF2ZSh0aGlzLCBvY3RhdmUpO1xuXG4gIG1hdHJpeCA9IGdldE1hdHJpeCh0aGlzLCBzY2FsZSwgb2N0YXZlLCB1bmRlcmJhcik7XG4gIGVsLnRyYW5zZm9ybShtYXRyaXgpO1xuXG4gIHNiYm94ID0gdGhpcy5fc2Jib3g7XG4gIHNiYm94ID0gZ2V0QkJveEFmdGVyVHJhbnNmb3JtKHRoaXMuZWwsIHNiYm94LCBtYXRyaXgpO1xuXG4gIHBiYm94ID0gZWwuZ2V0QkJveCgpO1xuICBlbC50b0RlZnMoKTtcblxuICB1dGlsLmV4dGVuZCh0aGlzLCB7XG4gICAgc2NhbGU6IHNjYWxlLFxuICAgIG1hdHJpeDogbWF0cml4LFxuICAgIHdpZHRoOiBwYmJveC53aWR0aCxcbiAgICBoZWlnaHQ6IC1wYmJveC55LFxuICAgIHN0ZXBDeDogc2Jib3guY3gsXG4gICAgc3RlcFk6IHNiYm94LnksXG4gICAgc3RlcEN5OiBzYmJveC5jeSxcbiAgICBzdGVwWTI6IHNiYm94LnkyLFxuICAgIHN0ZXBUb3A6IG9jdGF2ZSA+IDAgPyBwYmJveC55IDogc2Jib3gueSArIGxheW91dC5vcHRpb25zLmZvbnRTaXplICogMC4yXG4gIH0pO1xufVxuXG5mdW5jdGlvbiBhZGRBY2NpZGVudGFsKHRoYXQsIGFjY2lkZW50YWwpIHtcbiAgaWYgKCFhY2NpZGVudGFsKSB7XG4gICAgdGhhdC5fYWNjaWRlbnRhbFgyID0gMDtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIGFjY0RlZiA9IHRoYXQuX2RlZnMuZ2V0QWNjaWRlbnRhbChhY2NpZGVudGFsKTtcbiAgdGhhdC5lbC51c2UoYWNjRGVmLmVsKS5hdHRyKCd5JywgLXRoYXQuX2xheW91dC5vcHRpb25zLmFjY2lkZW50YWxTaGlmdCk7XG4gIHRoYXQuX2FjY2lkZW50YWxYMiA9IGFjY0RlZi53aWR0aDtcbn1cblxuZnVuY3Rpb24gYWRkU3RlcCh0aGF0LCBzdGVwKSB7XG4gIHRoYXQuX3NiYm94ID0gdGhhdC5lbFxuICAgIC50ZXh0KHRoYXQuX2FjY2lkZW50YWxYMiwgMCwgJycgKyBzdGVwKVxuICAgIC5hdHRyKCdmb250LXNpemUnLCB0aGF0Ll9sYXlvdXQub3B0aW9ucy5mb250U2l6ZSlcbiAgICAuZ2V0QkJveCgpO1xufVxuXG5mdW5jdGlvbiBhZGRPY3RhdmUodGhhdCwgb2N0YXZlKSB7XG4gIGlmICghb2N0YXZlKSB7IHJldHVybjsgfVxuXG4gIHZhciBsbyA9IHRoYXQuX2xheW91dC5vcHRpb25zO1xuICB2YXIgb2N0YXZlUmFkaXVzID0gbG8ub2N0YXZlUmFkaXVzO1xuICB2YXIgb2N0YXZlT2Zmc2V0ID0gbG8ub2N0YXZlT2Zmc2V0O1xuICB2YXIgb2N0YXZlU2VwID0gbG8ub2N0YXZlU2VwO1xuICB2YXIgb2N0YXZlRWwgPSB0aGF0LmVsLmcoKTtcbiAgdmFyIGk7XG5cbiAgaWYgKG9jdGF2ZSA+IDApIHtcbiAgICBmb3IgKGkgPSAwOyBpIDwgb2N0YXZlOyBpKyspIHtcbiAgICAgIG9jdGF2ZUVsLmNpcmNsZSh0aGF0Ll9zYmJveC5jeCwgdGhhdC5fc2Jib3gueSArIG9jdGF2ZU9mZnNldCAtIG9jdGF2ZVNlcCAqIGksIG9jdGF2ZVJhZGl1cyk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGZvciAoaSA9IDA7IGkgPiBvY3RhdmU7IGktLSkge1xuICAgICAgb2N0YXZlRWwuY2lyY2xlKFxuICAgICAgICB0aGF0Ll9zYmJveC5jeCxcbiAgICAgICAgdGhhdC5fc2Jib3gueTIgLSBvY3RhdmVPZmZzZXQgLSBvY3RhdmVTZXAgKiBpLCBvY3RhdmVSYWRpdXNcbiAgICAgICk7XG4gICAgfVxuICB9XG4gIHRoYXQuZWwuYWRkKG9jdGF2ZUVsKTtcbn1cblxuLy8gVHJhbnNmb3JtIHRoZSBwaXRjaCB0byBiZSBpbiBhIGdvb2QgYmFzZWxpbmUgcG9zaXRpb24gYW5kXG4vLyBzY2FsZSBpdCB0byBiZSBtb3JlIHNxdWFyZS5cbmZ1bmN0aW9uIGdldE1hdHJpeCh0aGF0LCBzY2FsZSwgb2N0YXZlLCB1bmRlcmJhcikge1xuICB2YXIgbG8gPSB0aGF0Ll9sYXlvdXQub3B0aW9ucztcbiAgdmFyIHBiYm94ID0gdGhhdC5lbC5nZXRCQm94KCk7XG4gIHZhciBkeSA9IChvY3RhdmUgPj0gMCAmJiB1bmRlcmJhciA9PT0gMCA/IC1sby5zdGVwQmFzZWxpbmVTaGlmdCA6IDApIC1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgdW5kZXJiYXIgKiBsby51bmRlcmJhclNlcDtcbiAgcmV0dXJuIFNuYXAubWF0cml4KClcbiAgICAudHJhbnNsYXRlKC1wYmJveC54LCBkeSlcbiAgICAuc2NhbGUoc2NhbGUueCwgc2NhbGUueSlcbiAgICAudHJhbnNsYXRlKDAsIHV0aWwubmVhcihwYmJveC55MiwgdGhhdC5fc2Jib3gueTIpID8gMCA6IC1wYmJveC55Mik7XG59XG5cbmZ1bmN0aW9uIGdldEJCb3hBZnRlclRyYW5zZm9ybShjb250YWluZXIsIGJib3gsIG1hdHJpeCkge1xuICB2YXIgcmVjdCA9IGNvbnRhaW5lci5yZWN0KGJib3gueCwgYmJveC55LCBiYm94LndpZHRoLCBiYm94LmhlaWdodCk7XG4gIHZhciBnID0gY29udGFpbmVyLmcocmVjdCk7XG4gIHJlY3QudHJhbnNmb3JtKG1hdHJpeCk7XG4gIGJib3ggPSBnLmdldEJCb3goKTtcbiAgZy5yZW1vdmUoKTtcbiAgcmV0dXJuIGJib3g7XG59XG5cbmZ1bmN0aW9uIGdldFNjYWxlKGhhc0FjY2lkZW50YWwsIG9jdGF2ZSwgdW5kZXJiYXIpIHtcbiAgdmFyIGFic09jdGF2ZSA9IE1hdGguYWJzKG9jdGF2ZSk7XG4gIHJldHVybiB7XG4gICAgeDogTWF0aC5wb3coMC45NywgYWJzT2N0YXZlICsgdW5kZXJiYXIgKyAoaGFzQWNjaWRlbnRhbCA/IDIgOiAwKSksXG4gICAgeTogTWF0aC5wb3coMC45NSwgYWJzT2N0YXZlICsgdW5kZXJiYXIgKyAoaGFzQWNjaWRlbnRhbCA/IDEgOiAwKSlcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBQaXRjaERlZjtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zcmMvcmVuZGVyZXIvZGVmcy9QaXRjaERlZi5qc1xuICoqIG1vZHVsZSBpZCA9IDMxXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbnZhciBTbmFwID0gcmVxdWlyZSgnU25hcCcpO1xuXG4vKipcbiAqIFNWRyBkZWZpbml0aW9uIGZvciB0aW1lIHNpZ25hdHVyZS5cbiAqIEBjbGFzc1xuICogQHBhcmFtIHtzdHJpbmd9IGlkICAgICBbZGVzY3JpcHRpb25dXG4gKiBAcGFyYW0ge1RpbWV9IHRpbWUgICBbZGVzY3JpcHRpb25dXG4gKiBAcGFyYW0ge0xheW91dH0gbGF5b3V0IFtkZXNjcmlwdGlvbl1cbiAqL1xuZnVuY3Rpb24gVGltZURlZihpZCwgdGltZSwgbGF5b3V0KSB7XG4gIHZhciBsbyA9IGxheW91dC5vcHRpb25zO1xuICB2YXIgdGltZUZvbnRTaXplID0gbG8udGltZUZvbnRTaXplO1xuICB2YXIgbGluZUV4dGVuZCA9IHRpbWVGb250U2l6ZSAqIDAuMTtcbiAgdmFyIGVsID0gdGhpcy5lbCA9IGxheW91dC5zdmcuZWwuZygpXG4gICAgLmF0dHIoe1xuICAgICAgaWQ6IGlkLFxuICAgICAgZm9udFNpemU6IHRpbWVGb250U2l6ZSxcbiAgICAgIGZvbnRXZWlnaHQ6IGxvLnRpbWVGb250V2VpZ2h0LFxuICAgICAgdGV4dEFuY2hvcjogJ21pZGRsZSdcbiAgICB9KTtcbiAgdmFyIGxpbmVZID0gLTAuODUgKiB0aW1lRm9udFNpemU7XG4gIHZhciBiYjtcblxuICBlbC50ZXh0KDAsIC0xICogdGltZUZvbnRTaXplLCB0aW1lLmJlYXRzKTtcbiAgZWwudGV4dCgwLCAwLCB0aW1lLmJlYXRUeXBlKTsgICAvLyBiYXNlbGluZSB5ID0gMFxuICBiYiA9IGVsLmdldEJCb3goKTtcbiAgZWwubGluZShiYi54IC0gbGluZUV4dGVuZCwgbGluZVksIGJiLngyICsgbGluZUV4dGVuZCwgbGluZVkpO1xuICBlbC50cmFuc2Zvcm0oU25hcC5tYXRyaXgoKS5zY2FsZSgxLCAwLjgpLnRyYW5zbGF0ZShsaW5lRXh0ZW5kIC0gYmIueCwgMCkpO1xuXG4gIGJiID0gZWwuZ2V0QkJveCgpO1xuICBlbC50b0RlZnMoKTtcblxuICB0aGlzLndpZHRoID0gYmIud2lkdGg7XG4gIHRoaXMuaGVpZ2h0ID0gLWJiLnk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gVGltZURlZjtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zcmMvcmVuZGVyZXIvZGVmcy9UaW1lRGVmLmpzXG4gKiogbW9kdWxlIGlkID0gMzJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcblxudmFyIEJBUl9UT19JRCA9IHtcbiAgc2luZ2xlOiAnYnMnLCBkb3VibGU6ICdiZCcsIGVuZDogJ2JlJyxcbiAgJ3JlcGVhdC1iZWdpbic6ICdicmInLCAncmVwZWF0LWVuZCc6ICdicmUnLCAncmVwZWF0LWJvdGgnOiAnYnJiZSdcbn07XG5cbnZhciBkZWZJZE1peGlucyA9IHtcblxuICAvKipcbiAgICogRGVmIGlkIHVzZWQgaW4gdGhlIFNWRyA8ZGVmcz4gZWxlbWVudC5cbiAgICogYGBgXG4gICAqIGlkIDo9ICd0JyBiZWF0cyAnLScgYmVhdFR5cGVcbiAgICogYGBgXG4gICAqIEUuZy4gYHQzLTRgXG4gICAqIEBtZW1iZXJcbiAgICogQGFsaWFzIG11c2plLlRpbWUjZGVmSWRcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICogQHJlYWRvbmx5XG4gICAqL1xuICBUaW1lOiB7XG4gICAgZGVmSWQ6IHtcbiAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gWyd0JywgdGhpcy5iZWF0cywgJy0nLCB0aGlzLmJlYXRUeXBlXS5qb2luKCcnKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIERlZiBpZCB1c2VkIGluIHRoZSBTVkcgPGRlZnM+IGVsZW1lbnQuXG4gICAqIGBgYFxuICAgKiBkZWZJZCAgICBCYXIgdmFsdWVcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgKiAnYnMnICAgLSBzaW5nbGVcbiAgICogJ2JkJyAgIC0gZG91YmxlXG4gICAqICdiZScgICAtIHJlcGVhdC1lbmRcbiAgICogJ2JyYicgIC0gcmVwZWF0LWJlZ2luXG4gICAqICdicmUnICAtIHJlcGVhdC1lbmRcbiAgICogJ2JyYmUnIC0gcmVwZWF0LWJvdGhcbiAgICogYGBgXG4gICAqIEBtZW1iZXJcbiAgICogQGFsaWFzIG11c2plLkJhciNkZWZJZFxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKiBAcmVhZG9ubHlcbiAgICovXG4gIEJhcjoge1xuICAgIGRlZklkOiB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIEJBUl9UT19JRFt0aGlzLnZhbHVlXTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIFVuaXF1ZSBkZWYgaWQgb2YgdGhlIG5vdGUgdXNlZCBpbiB0aGUgU1ZHIDxkZWZzPiBlbGVtZW50LlxuICAgKiBgYGBcbiAgICogZGVmSWQgOj0gJ24nIGFjY2lkZW50YWwgc3RlcCBvY3RhdmUgdHlwZSBkb3RcbiAgICogYGBgXG4gICAqIEUuZy5cbiAgICogYGBgXG4gICAqIE5vdGUgICAgIGRlZklkXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLVxuICAgKiAxICAgICAgICBuMTA0MFxuICAgKiBiMy0gICAgICBuYjMwMjBcbiAgICogIzUnXy4gICAgbnM1MTgxXG4gICAqIDYsLCAgICAgIG42LTJcbiAgICogYGBgXG4gICAqIEBtZW1iZXJcbiAgICogQGFsaWFzIG11c2plLk5vdGUjZGVmSWRcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICogQHJlYWRvbmx5XG4gICAqL1xuICBOb3RlOiB7XG4gICAgZGVmSWQ6IHtcbiAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcGl0Y2ggPSB0aGlzLnBpdGNoLCBkdXJhdGlvbiA9IHRoaXMuZHVyYXRpb247XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgJ24nLCBwaXRjaC5hY2NpZGVudGFsLnJlcGxhY2UoLyMvZywgJ3MnKSxcbiAgICAgICAgICBwaXRjaC5zdGVwLCBwaXRjaC5vY3RhdmUsIGR1cmF0aW9uLnR5cGUsIGR1cmF0aW9uLmRvdFxuICAgICAgICBdLmpvaW4oJycpO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogVW5pcXVlIGRlZiBpZCBvZiB0aGUgcmVzdCB1c2VkIGluIHRoZSBTVkcgPGRlZnM+IGVsZW1lbnQuXG4gICAqIGBgYFxuICAgKiBkZWZJZCA6PSAncicgdHlwZSBkb3RcbiAgICogYGBgXG4gICAqIEUuZy5cbiAgICogYGBgXG4gICAqIFJlc3QgICAgIGRlZklkXG4gICAqIC0tLS0tLS0tLS0tLS0tLS1cbiAgICogMCAgICAgICAgcjQwXG4gICAqIDAgLSAgICAgIHIyMFxuICAgKiAwPS4gICAgICByMTYxXG4gICAqIGBgYFxuICAgKlxuICAgKiBAbWVtYmVyXG4gICAqIEBhbGlhcyBtdXNqZS5SZXN0I2RlZklkXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqIEByZWFkb25seVxuICAgKi9cbiAgUmVzdDoge1xuICAgIGRlZklkOiB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGR1cmF0aW9uID0gdGhpcy5kdXJhdGlvbjtcbiAgICAgICAgcmV0dXJuICdyJyArIGR1cmF0aW9uLnR5cGUgKyBkdXJhdGlvbi5kb3Q7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBEZWYgaWQgdXNlZCBpbiB0aGUgU1ZHIDxkZWZzPiBlbGVtZW50LlxuICAgKiBgYGBcbiAgICogZGVmSWQgOj0gJ3AnIGFjY2lkZW50YWwgc3RlcCBvY3RhdmVcbiAgICogYGBgXG4gICAqIEBtZW1iZXJcbiAgICogQGFsaWFzIG11c2plLlBpdGNoI2RlZklkXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqIEByZWFkb25seVxuICAgKi9cbiAgUGl0Y2g6IHtcbiAgICBkZWZJZDoge1xuICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBbJ3AnLCB0aGlzLmFjY2lkZW50YWwucmVwbGFjZSgvIy9nLCAncycpLFxuICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGVwLCB0aGlzLm9jdGF2ZV0uam9pbignJyk7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBEZWYgaWQgdXNlZCBpbiB0aGUgU1ZHIDxkZWZzPiBlbGVtZW50LlxuICAgKiBgYGBcbiAgICogZGVmSWQgOj0gJ2QnIHR5cGUgZG90XG4gICAqIGBgYFxuICAgKiAqRS5nLipcbiAgICogYGBgXG4gICAqIE5vdGUgICAgIGRlZklkXG4gICAqIC0tLS0tLS0tLS0tLS0tLS1cbiAgICogMS4gICAgICAgZDQxXG4gICAqIDFfICAgICAgIGQ4MFxuICAgKiAxPSAgICAgICBkMTYwXG4gICAqIDEtLi4gICAgIGQyMlxuICAgKiBgYGBcbiAgICogQG1lbWJlclxuICAgKiBAYWxpYXMgbXVzamUuRHVyYXRpb24jZGVmSWRcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICogQHJlYWRvbmx5XG4gICAqL1xuICBEdXJhdGlvbjoge1xuICAgIGRlZklkOiB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICdkJyArIHRoaXMudHlwZSArIHRoaXMuZG90O1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBkZWZJZE1peGlucztcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zcmMvcmVuZGVyZXIvZGVmcy9kZWZJZE1peGlucy5qc1xuICoqIG1vZHVsZSBpZCA9IDMzXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbnZhciBTbmFwID0gcmVxdWlyZSgnU25hcCcpO1xudmFyIHV0aWwgPSByZXF1aXJlKCcuLi8uLi91dGlsJyk7XG5cbi8qKlxuICogQGNsYXNzXG4gKiBAcGFyYW0gbGF5b3V0IHtMYXlvdXR9XG4gKi9cbmZ1bmN0aW9uIFN2Z0xheW91dChsYXlvdXQpIHtcbiAgdGhpcy5fbGF5b3V0ID0gbGF5b3V0O1xuICB2YXIgbG8gPSBsYXlvdXQub3B0aW9ucztcbiAgdGhpcy5fZWwgPSBTbmFwKGxheW91dC5zdmcpXG4gICAgLmF0dHIoeyBmb250RmFtaWx5OiBsby5mb250RmFtaWx5IH0pXG4gICAgLmFkZENsYXNzKCdtdXNqZScpO1xuICB0aGlzLmVsLmNsZWFyKCk7XG4gIHRoaXMud2lkdGggPSBsby53aWR0aDtcbn1cblxudXRpbC5kZWZpbmVQcm9wZXJ0aWVzKFN2Z0xheW91dC5wcm90b3R5cGUsXG4vKiogQGxlbmRzIFN2Z0xheW91dCMgKi9cbntcbiAgZWw6IHtcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9lbDtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIFdpZHRoIG9mIHRoZSBzdmcuXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICB3aWR0aDoge1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3c7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uICh3KSB7XG4gICAgICB0aGlzLl93ID0gdztcbiAgICAgIHRoaXMuZWwuYXR0cignd2lkdGgnLCB3KTtcbiAgICAgIHZhciBib2R5ID0gdGhpcy5fbGF5b3V0LmJvZHk7XG4gICAgICBpZiAoYm9keSkgeyBib2R5LndpZHRoID0gdzsgfVxuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogSGVpZ2h0IG9mIHRoZSBzdmcuXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICBoZWlnaHQ6IHtcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9oO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiAoaCkge1xuICAgICAgdGhpcy5faCA9IGg7XG4gICAgICB0aGlzLmVsLmF0dHIoJ2hlaWdodCcsIGgpO1xuICAgIH1cbiAgfVxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gU3ZnTGF5b3V0O1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NyYy9yZW5kZXJlci9MYXlvdXQvU3ZnTGF5b3V0LmpzXG4gKiogbW9kdWxlIGlkID0gMzRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcblxudmFyIFNuYXAgPSByZXF1aXJlKCdTbmFwJyk7XG52YXIgdXRpbCA9IHJlcXVpcmUoJy4uLy4uL3V0aWwnKTtcblxuLyoqXG4gKiBCb2R5XG4gKiBAY2xhc3NcbiAqIEBwYXJhbSB7TGF5b3V0fSBsYXlvdXRcbiAqL1xuZnVuY3Rpb24gQm9keUxheW91dChsYXlvdXQpIHtcbiAgdGhpcy5fbGF5b3V0ID0gbGF5b3V0O1xuICB2YXIgc3ZnID0gbGF5b3V0LnN2ZztcbiAgdmFyIGxvID0gbGF5b3V0Lm9wdGlvbnM7XG4gIHRoaXMuX2VsID0gc3ZnLmVsLmcoKVxuICAgICAgLnRyYW5zZm9ybShTbmFwLm1hdHJpeCgpLnRyYW5zbGF0ZShsby5tYXJnaW5MZWZ0LCBsby5tYXJnaW5Ub3ApKVxuICAgICAgLmFkZENsYXNzKCdtdXMtYm9keScpO1xuICB0aGlzLndpZHRoID0gbG8ud2lkdGggLSBsby5tYXJnaW5MZWZ0IC0gbG8ubWFyZ2luUmlnaHQ7XG59XG5cbnV0aWwuZGVmaW5lUHJvcGVydGllcyhCb2R5TGF5b3V0LnByb3RvdHlwZSxcbi8qKiBAbGVuZHMgQm9keUxheW91dCMgKi9cbntcbiAgZWw6IHtcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9lbDtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIFdpZHRoIG9mIHRoZSBib2R5LlxuICAgKiAtIChHZXR0ZXIpIEdldCB0aGUgYm9keSB3aWR0aC5cbiAgICogLSAoU2V0dGVyKSBTZXQgdGhlIGJvZHkgd2lkdGggYW5kIHRoaXMgYWxzbyBpbmR1Y2VzIHNldHRpbmcgdGhlXG4gICAqIGhlYWRlciBhbmQgY29udGVudCB3aWR0aCBpZiBvbmUgZXhpc3RzLlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgd2lkdGg6IHtcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl93O1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiAodykge1xuICAgICAgdGhpcy5fdyA9IHc7XG4gICAgICB2YXIgbGF5b3V0ID0gdGhpcy5fbGF5b3V0O1xuICAgICAgaWYgKGxheW91dC5oZWFkZXIpIHsgbGF5b3V0LmhlYWRlci53aWR0aCA9IHc7IH1cbiAgICAgIGlmIChsYXlvdXQuY29udGVudCkgeyBsYXlvdXQuY29udGVudC53aWR0aCA9IHc7IH1cbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEhlaWdodCBvZiB0aGUgYm9keS5cbiAgICogLSAoR2V0dGVyKSBHZXQgdGhlIGJvZHkgaGVpZ2h0LlxuICAgKiAtIChTZXR0ZXIpIFNldCB0aGUgYm9keSBoZWlnaHQgYW5kIHRoaXMgd2lsbCBhbHNvIGNhdXNlIHRoZSBoZWlnaHQgb2Ygc3ZnIHRvIHZhcnkuXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICBoZWlnaHQ6IHtcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9oO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiAoaCkge1xuICAgICAgdmFyIGxheW91dCA9IHRoaXMuX2xheW91dCwgbG8gPSBsYXlvdXQub3B0aW9ucztcbiAgICAgIGxheW91dC5zdmcuaGVpZ2h0ID0gaCArIGxvLm1hcmdpblRvcCArIGxvLm1hcmdpbkJvdHRvbTtcbiAgICAgIHRoaXMuX2ggPSBoO1xuICAgIH1cbiAgfVxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gQm9keUxheW91dDtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zcmMvcmVuZGVyZXIvTGF5b3V0L0JvZHlMYXlvdXQuanNcbiAqKiBtb2R1bGUgaWQgPSAzNVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbCA9IHJlcXVpcmUoJy4uLy4uL3V0aWwnKTtcblxuLyoqXG4gKiBIZWFkZXIgbGF5b3V0LlxuICogQGNsYXNzXG4gKiBAcGFyYW0ge0xheW91dH0gbGF5b3V0XG4gKi9cbmZ1bmN0aW9uIEhlYWRlckxheW91dChsYXlvdXQpIHtcbiAgdGhpcy5fbGF5b3V0ID0gbGF5b3V0O1xuICB0aGlzLmVsID0gbGF5b3V0LmJvZHkuZWwuZygpLmFkZENsYXNzKCdtdXMtaGVhZGVyJyk7XG4gIHRoaXMud2lkdGggPSBsYXlvdXQuYm9keS53aWR0aDtcbn1cblxudXRpbC5kZWZpbmVQcm9wZXJ0aWVzKEhlYWRlckxheW91dC5wcm90b3R5cGUsXG4vKiogQGxlbmRzIEhlYWRlckxheW91dCMgKi9cbntcbiAgLyoqXG4gICAqIFdpZHRoIG9mIHRoZSBoZWFkZXIuXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICB3aWR0aDoge1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3c7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uICh3KSB7XG4gICAgICB0aGlzLl93ID0gdztcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEhlaWdodCBvZiB0aGUgaGVhZGVyLlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgaGVpZ2h0OiB7XG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5faDtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gKGgpIHtcbiAgICAgIHRoaXMuX2ggPSBoO1xuICAgICAgdmFyIGxheW91dCA9IHRoaXMuX2xheW91dDtcbiAgICAgIGxheW91dC5jb250ZW50LnkgPSBoID8gaCArIGxheW91dC5vcHRpb25zLmhlYWRlclNlcCA6IDA7XG4gICAgfVxuICB9XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBIZWFkZXJMYXlvdXQ7XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc3JjL3JlbmRlcmVyL0xheW91dC9IZWFkZXJMYXlvdXQuanNcbiAqKiBtb2R1bGUgaWQgPSAzNlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgU25hcCA9IHJlcXVpcmUoJ1NuYXAnKTtcbnZhciB1dGlsID0gcmVxdWlyZSgnLi4vLi4vdXRpbCcpO1xudmFyIFN5c3RlbUxheW91dCA9IHJlcXVpcmUoJy4vU3lzdGVtTGF5b3V0Jyk7XG5cbi8qKlxuICogQGNsYXNzXG4gKiBAcGFyYW0ge09iamVjdH0gbGF5b3V0IC0gUmVmZXJlbmNlIHRvIHRoZSBwYXJlbnQgbGF5b3V0IGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBDb250ZW50TGF5b3V0KGxheW91dCkge1xuICB0aGlzLmxheW91dCA9IGxheW91dDtcbiAgdGhpcy5lbCA9IGxheW91dC5ib2R5LmVsLmcoKS5hZGRDbGFzcygnbXVzLWNvbnRlbnQnKTtcbiAgdGhpcy53aWR0aCA9IGxheW91dC5ib2R5LndpZHRoO1xufVxuXG51dGlsLmRlZmluZVByb3BlcnRpZXMoQ29udGVudExheW91dC5wcm90b3R5cGUsXG4vKiogQGxlbmRzIENvbnRlbnRMYXlvdXQjICovXG57XG4gIHk6IHtcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl95O1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiAoeSkge1xuICAgICAgdGhpcy5feSA9IHk7XG4gICAgICB0aGlzLmVsLnRyYW5zZm9ybShTbmFwLm1hdHJpeCgpLnRyYW5zbGF0ZSgwLCB5KSk7XG4gICAgICByZXNpemVCb2R5KHRoaXMpO1xuICAgIH1cbiAgfSxcblxuICB3aWR0aDoge1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3c7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uICh3KSB7XG4gICAgICB0aGlzLl93ID0gdztcbiAgICB9XG4gIH0sXG5cbiAgaGVpZ2h0OiB7XG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgbGFzdCA9IHRoaXMuc3lzdGVtc1t0aGlzLnN5c3RlbXMubGVuZ3RoIC0gMV07XG4gICAgICByZXR1cm4gbGFzdCA/IGxhc3QueSArIGxhc3QuaGVpZ2h0IDogMDtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwYXJhbSBzY29yZU1lYXN1cmUge211c2plLlRpbWV3aXNlTWVhc3VyZXN9IFRoZSB0aW1ld2lzZSBzY29yZSBtZWFzdXJlLlxuICAgKi9cbiAgZmxvdzogZnVuY3Rpb24gKHNjb3JlTWVhc3VyZXMpIHtcbiAgICBtYWtlU3lzdGVtcyh0aGlzLCBzY29yZU1lYXN1cmVzKTtcbiAgICBiYWxhbmNlU3lzdGVtcyh0aGlzKTtcbiAgICB0aGlzLnN5c3RlbXMuZm9yRWFjaChmdW5jdGlvbiAoc3lzdGVtKSB7IHN5c3RlbS5mbG93KCk7IH0pO1xuICB9XG59KTtcblxuZnVuY3Rpb24gcmVzaXplQm9keSh0aGF0KSB7XG4gIHZhciBsYXlvdXQgPSB0aGF0LmxheW91dCwgaEhlaWdodCA9IGxheW91dC5oZWFkZXIuaGVpZ2h0O1xuXG4gIGxheW91dC5ib2R5LmhlaWdodCA9IHRoYXQuaGVpZ2h0ICtcbiAgICAgICAgKGhIZWlnaHQgPyBoSGVpZ2h0ICsgbGF5b3V0Lm9wdGlvbnMuaGVhZGVyU2VwIDogMCk7XG59XG5cbi8qKlxuICogRGl2aWRlIG1lYXN1cmVzIGluIHRpbWV3aXNlIHNjb3JlIGludG8gdGhlIHN5c3RlbXMuXG4gKiBAcGFyYW0gc2NvcmVNZWFzdXJlIHttdXNqZS5UaW1ld2lzZU1lYXN1cmVzfSBUaGUgdGltZXdpc2Ugc2NvcmUgbWVhc3VyZS5cbiAqL1xuZnVuY3Rpb24gbWFrZVN5c3RlbXModGhhdCwgc2NvcmVNZWFzdXJlcykge1xuICB2YXIgbGF5b3V0ID0gdGhhdC5sYXlvdXQ7XG4gIHZhciBsbyA9IGxheW91dC5vcHRpb25zO1xuICB2YXIgbWVhc3VyZVBhZGRpbmcgPSBsby5tZWFzdXJlUGFkZGluZ0xlZnQgKyBsby5tZWFzdXJlUGFkZGluZ1JpZ2h0O1xuICB2YXIgc3lzdGVtID0gbmV3IFN5c3RlbUxheW91dChsYXlvdXQsIDApO1xuICB2YXIgc3lzdGVtcyA9IHRoYXQuc3lzdGVtcyA9IFtzeXN0ZW1dO1xuXG4gIHNjb3JlTWVhc3VyZXMuZm9yRWFjaChmdW5jdGlvbiAobWVhc3VyZSkge1xuICAgIHZhciBtaW5XaWR0aCA9IG1lYXN1cmUubWluV2lkdGggKyBtZWFzdXJlUGFkZGluZyArXG4gICAgICAgICAgICAgICAgICAobWVhc3VyZS5iYXJMZWZ0SW5TeXN0ZW0ud2lkdGggK1xuICAgICAgICAgICAgICAgICAgIG1lYXN1cmUuYmFyUmlnaHRJblN5c3RlbS53aWR0aCkgLyAyO1xuXG4gICAgLy8gQ29udGludWUgcHV0IHRoaXMgbWVhc3VyZSBpbiB0aGUgc3lzdGVtLlxuICAgIGlmIChzeXN0ZW0ubWluV2lkdGggKyBtaW5XaWR0aCA8IHRoYXQud2lkdGgpIHtcbiAgICAgIHN5c3RlbS5tZWFzdXJlcy5wdXNoKG1lYXN1cmUpO1xuXG4gICAgLy8gTmV3IHN5c3RlbVxuICAgIH0gZWxzZSB7XG4gICAgICBzeXN0ZW0gPSBuZXcgU3lzdGVtTGF5b3V0KGxheW91dCwgc3lzdGVtcy5sZW5ndGgpO1xuICAgICAgc3lzdGVtcy5wdXNoKHN5c3RlbSk7XG4gICAgICBzeXN0ZW0ubWVhc3VyZXMucHVzaChtZWFzdXJlKTtcbiAgICB9XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBnZXRNYXhMZW5ndGhTeXN0ZW0odGhhdCkge1xuICB2YXIgbWF4TGVuZ3RoID0gMCwgaSwgc3lzdGVtO1xuXG4gIHRoYXQuc3lzdGVtcy5mb3JFYWNoKGZ1bmN0aW9uIChzeXN0ZW0pIHtcbiAgICBtYXhMZW5ndGggPSBNYXRoLm1heChtYXhMZW5ndGgsIHN5c3RlbS5tZWFzdXJlcy5sZW5ndGgpO1xuICB9KTtcblxuICAvLyBGaW5kIHRoZSBmaXJzdCBtYXggbGVuZ3RoIHN5c3RlbSBiYWNrd2FyZC5cbiAgZm9yKGkgPSB0aGF0LnN5c3RlbXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICBzeXN0ZW0gPSB0aGF0LnN5c3RlbXNbaV07XG4gICAgaWYgKHN5c3RlbS5tZWFzdXJlcy5sZW5ndGggPT09IG1heExlbmd0aCkgeyByZXR1cm4gc3lzdGVtOyB9XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNOb3RCYWxhbmNhYmxlKHRoYXQpIHtcbiAgdmFyIHN5c3RlbXMgPSB0aGF0LnN5c3RlbXM7XG4gIHZhciBsZW4gPSBzeXN0ZW1zLmxlbmd0aDtcbiAgcmV0dXJuIGxlbiA9PT0gMSB8fCAgICAgICAvLyBvbmx5IDEgc3lzdGVtXG4gICAgICAgIChsZW4gPT09IDIgJiYgc3lzdGVtc1sxXS5taW5XaWR0aCA8IHRoYXQud2lkdGggKiAwLjQpOyAvLyAxIDIvNSBzeXN0ZW1zXG59XG5cbmZ1bmN0aW9uIGJhbGFuY2VTeXN0ZW1zKHRoYXQpIHtcbiAgaWYgKGlzTm90QmFsYW5jYWJsZSh0aGF0KSkgeyByZXR1cm47IH1cblxuICB2YXIgc3lzdGVtcyA9IHRoYXQuc3lzdGVtcztcbiAgdmFyIGxhc3QgPSBzeXN0ZW1zW3N5c3RlbXMubGVuZ3RoIC0gMV07XG4gIHZhciBzeXN0ZW0gPSBnZXRNYXhMZW5ndGhTeXN0ZW0odGhhdCk7XG4gIHZhciBuZXh0LCBwcmV2O1xuXG4gIC8vIE1vdmUgbWVhc3VyZXMgZG93biB0byBiYWxhbmNlIHRoZSBsYXN0IHN5c3RlbS5cbiAgd2hpbGUgKGxhc3QubWVhc3VyZXMubGVuZ3RoIDwgc3lzdGVtLm1lYXN1cmVzLmxlbmd0aCAtIDEpIHtcblxuICAgIC8vIE1vdmUgYSBtZWFzdXJlIHRhaWwtdG8taGVhZCBkb3dud2FyZCB0byB0aGUgbGFzdCBtZWFzdXJlLlxuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICBuZXh0ID0gc3lzdGVtLm5leHQ7XG4gICAgICBpZiAoIW5leHQpIHsgYnJlYWs7IH1cbiAgICAgIG5leHQubWVhc3VyZXMudW5zaGlmdChzeXN0ZW0ubWVhc3VyZXMucG9wKCkpO1xuICAgICAgc3lzdGVtID0gbmV4dDtcbiAgICB9XG4gICAgc3lzdGVtID0gZ2V0TWF4TGVuZ3RoU3lzdGVtKHRoYXQpO1xuICB9XG5cbiAgLy8gTW92ZSBiYWNrIG1lYXN1cmVzIGlmIHRoZSBzeXN0ZW0gZXhjZWVkcyB0aGUgY29udGVudCB3aWR0aC5cbiAgc3lzdGVtID0gbGFzdDtcbiAgd2hpbGUgKHN5c3RlbSkge1xuICAgIHByZXYgPSBzeXN0ZW0ucHJldjtcbiAgICB3aGlsZSAoc3lzdGVtLm1pbldpZHRoID4gdGhhdC53aWR0aCkge1xuICAgICAgcHJldi5tZWFzdXJlcy5wdXNoKHN5c3RlbS5tZWFzdXJlcy5zaGlmdCgpKTtcbiAgICB9XG4gICAgc3lzdGVtID0gcHJldjtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IENvbnRlbnRMYXlvdXQ7XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc3JjL3JlbmRlcmVyL0xheW91dC9Db250ZW50TGF5b3V0LmpzXG4gKiogbW9kdWxlIGlkID0gMzdcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcblxudmFyIFNuYXAgPSByZXF1aXJlKCdTbmFwJyk7XG52YXIgdXRpbCA9IHJlcXVpcmUoJy4uLy4uL3V0aWwnKTtcblxuLyoqXG4gKiBAY2xhc3NcbiAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleFxuICogQHBhcmFtIHtMYXlvdXR9IGxheW91dFxuICovXG5mdW5jdGlvbiBTeXN0ZW1MYXlvdXQobGF5b3V0LCBpbmRleCkge1xuICB0aGlzLl9pbmRleCA9IGluZGV4O1xuICB0aGlzLl9sYXlvdXQgPSBsYXlvdXQ7XG4gIHRoaXMuX2VsID0gbGF5b3V0LmNvbnRlbnQuZWwuZygpLmFkZENsYXNzKCdtdXMtc3lzdGVtJyk7XG59XG5cbnV0aWwuZGVmaW5lUHJvcGVydGllcyhTeXN0ZW1MYXlvdXQucHJvdG90eXBlLFxuLyoqIEBsZW5kcyBTeXN0ZW1MYXlvdXQjICovXG57XG4gIGVsOiB7XG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZWw7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBNZWFzdXJlcyBpbiBhIHN5c3RlbS5cbiAgICogQHR5cGUge0FycmF5LjxUaW1ld2lzZU1lYXN1cmU+fVxuICAgKiBAcmVhZG9ubHlcbiAgICovXG4gIG1lYXN1cmVzOiB7XG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fbWVhc3VyZXMgfHwgKHRoaXMuX21lYXN1cmVzID0gW10pO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogUHJldmlvdXMgc3lzdGVtLlxuICAgKiBAdHlwZSB7U3lzdGVtTGF5b3V0fVxuICAgKi9cbiAgcHJldjoge1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2xheW91dC5jb250ZW50LnN5c3RlbXNbdGhpcy5faW5kZXggLSAxXTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIE5leHQgc3lzdGVtLlxuICAgKiBAdHlwZSB7U3lzdGVtTGF5b3V0fVxuICAgKi9cbiAgbmV4dDoge1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2xheW91dC5jb250ZW50LnN5c3RlbXNbdGhpcy5faW5kZXggKyAxXTtcbiAgICB9XG4gIH0sXG5cbiAgeToge1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3k7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uICh5KSB7XG4gICAgICB0aGlzLl95ID0geTtcbiAgICAgIHRoaXMuZWwudHJhbnNmb3JtKFNuYXAubWF0cml4KCkudHJhbnNsYXRlKDAsIHkpKTtcbiAgICB9XG4gIH0sXG5cbiAgd2lkdGg6IHtcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9sYXlvdXQuY29udGVudC53aWR0aDtcbiAgICB9XG4gIH0sXG5cbiAgbWluV2lkdGg6IHtcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBtaW4gPSAwO1xuICAgICAgdGhpcy5tZWFzdXJlcy5mb3JFYWNoKGZ1bmN0aW9uIChtZWFzdXJlKSB7XG4gICAgICAgIG1pbiArPSBtZWFzdXJlLm1pbldpZHRoO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gbWluO1xuICAgIH1cbiAgfSxcblxuICBjb250ZW50OiB7XG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fbGF5b3V0LmNvbnRlbnQ7XG4gICAgfVxuICB9LFxuXG4gIHN5c3RlbXM6IHtcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLmNvbnRlbnQuc3lzdGVtcztcbiAgICB9XG4gIH0sXG5cbiAgZmxvdzogZnVuY3Rpb24gKCkge1xuICAgIHZhciBzeXN0ZW0gPSB0aGlzO1xuICAgIHZhciBtaW5IZWlnaHQgPSAwO1xuICAgIHZhciB4ID0gMDtcblxuICAgIHR1bmVNZWFzdXJlc1dpZHRocyh0aGlzKTtcblxuICAgIHRoaXMubWVhc3VyZXMuZm9yRWFjaChmdW5jdGlvbiAobWVhc3VyZSwgbSkge1xuICAgICAgbWVhc3VyZS5zeXN0ZW0gPSBzeXN0ZW07XG4gICAgICBtZWFzdXJlLl9zSW5kZXggPSBtO1xuICAgICAgbWVhc3VyZS5mbG93KCk7XG4gICAgICBtZWFzdXJlLnggPSB4O1xuICAgICAgeCArPSBtZWFzdXJlLndpZHRoO1xuICAgICAgbWluSGVpZ2h0ID0gTWF0aC5tYXgobWluSGVpZ2h0LCBtZWFzdXJlLm1pbkhlaWdodCk7XG4gICAgfSk7XG5cbiAgICB2YXIgcHJldiA9IHRoaXMucHJldjtcbiAgICB0aGlzLnkgPSBwcmV2ID8gcHJldi55ICsgcHJldi5oZWlnaHQgKyB0aGlzLl9sYXlvdXQub3B0aW9ucy5zeXN0ZW1TZXAgOiAwO1xuICAgIHRoaXMuaGVpZ2h0ID0gbWluSGVpZ2h0O1xuICB9XG59KTtcblxuZnVuY3Rpb24gdHVuZU1lYXN1cmVzV2lkdGhzKHRoYXQpIHtcbiAgaWYgKCFpc1R1bmFibGUodGhhdCkpIHsgcmV0dXJuOyB9XG5cbiAgdmFyIHBhaXJzID0gZ2V0UGFpcnModGhhdC5tZWFzdXJlcyk7XG4gIHZhciBsZW5ndGggPSBwYWlycy5sZW5ndGg7XG4gIHZhciB3aWR0aExlZnQgPSB0aGF0LndpZHRoO1xuICB2YXIgaXRlbUxlZnQgPSBsZW5ndGg7XG4gIHZhciBpID0gMDsgICAgLy8gaSArIGl0ZW1MZWZ0ID09PSBsZW5ndGhcbiAgdmFyIHdpZHRoO1xuXG4gIHdoaWxlIChpIDwgbGVuZ3RoKSB7XG4gICAgaWYgKHdpZHRoTGVmdCA+PSBwYWlyc1tpXS53aWR0aCAqIGl0ZW1MZWZ0KSB7XG4gICAgICB3aWR0aCA9IHdpZHRoTGVmdCAvIGl0ZW1MZWZ0O1xuICAgICAgZG8ge1xuICAgICAgICBwYWlyc1tpXS5tZWFzdXJlLndpZHRoID0gd2lkdGg7XG4gICAgICAgIGkrKztcbiAgICAgIH0gd2hpbGUgKGkgPCBsZW5ndGgpO1xuICAgICAgYnJlYWs7XG4gICAgfSBlbHNlIHtcbiAgICAgIHdpZHRoID0gcGFpcnNbaV0ud2lkdGg7XG4gICAgICBwYWlyc1tpXS5tZWFzdXJlLndpZHRoID0gd2lkdGg7XG4gICAgICB3aWR0aExlZnQgLT0gd2lkdGg7XG4gICAgICBpKys7XG4gICAgICBpdGVtTGVmdC0tO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBpc1R1bmFibGUodGhhdCkge1xuICB2YXIgY3RXaWR0aCA9IHRoYXQuY29udGVudC53aWR0aDtcbiAgdmFyIHMgPSB0aGF0Ll9pbmRleDtcbiAgdmFyIHNzTGVuID0gdGhhdC5zeXN0ZW1zLmxlbmd0aDtcbiAgcmV0dXJuIHNzTGVuID4gMiB8fFxuICAgICAoc3NMZW4gPT09IDEgJiYgdGhhdC5taW5XaWR0aCA+IGN0V2lkdGggKiAwLjcpIHx8XG4gICAgIChzc0xlbiA9PT0gMiAmJiAocyA9PT0gMCB8fFxuICAgICAgICAgICAgICAgICAgICAgKHMgPT09IDEgJiYgdGhhdC5taW5XaWR0aCA+IGN0V2lkdGggKiAwLjQpKSk7XG59XG5cbmZ1bmN0aW9uIGRlc2NlbmRpbmdTb3J0KGEsIGIpIHsgcmV0dXJuIGIud2lkdGggLSBhLndpZHRoOyB9XG5cbmZ1bmN0aW9uIGdldFBhaXJzKG1lYXN1cmVzKSB7XG4gIHJldHVybiBtZWFzdXJlcy5tYXAoZnVuY3Rpb24gKG1lYXN1cmUpIHtcbiAgICByZXR1cm4ge1xuICAgICAgd2lkdGg6IG1lYXN1cmUubWluV2lkdGgsXG4gICAgICBtZWFzdXJlOiBtZWFzdXJlXG4gICAgfTtcbiAgfSkuc29ydChkZXNjZW5kaW5nU29ydCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gU3lzdGVtTGF5b3V0O1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NyYy9yZW5kZXJlci9MYXlvdXQvU3lzdGVtTGF5b3V0LmpzXG4gKiogbW9kdWxlIGlkID0gMzhcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcblxudmFyIFNuYXAgPSByZXF1aXJlKCdTbmFwJyk7XG5cbi8qKlxuICogVGltZXdpc2VNZWFzdXJlIExheW91dCBtaXhpbi5cbiAqIEBtaXhpblxuICovXG52YXIgVGltZXdpc2VNZWFzdXJlTGF5b3V0TWl4aW4gPSB7XG5cbiAgLyoqXG4gICAqIE1lYXN1cmUgU1ZHIGdyb3VwIGVsZW1lbnQuXG4gICAqIEB0eXBlIHtTbmFwLkVsZW1lbnR9XG4gICAqIEByZWFkb25seVxuICAgKi9cbiAgZWw6IHtcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9lbDtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIE1pbmltdW4gd2lkdGggb2YgdGhlIG1lYXN1cmUuXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICBtaW5XaWR0aDoge1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIG1pbldpZHRoID0gMDtcbiAgICAgIHRoaXMucGFydHMuZm9yRWFjaChmdW5jdGlvbiAoY2VsbCkge1xuICAgICAgICBtaW5XaWR0aCA9IE1hdGgubWF4KG1pbldpZHRoLCBjZWxsLm1pbldpZHRoKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIG1pbldpZHRoICsgdGhpcy5wYWRkaW5nO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogUmVmZXJlbmNlIHRvIHRoZSBwYXJlbnQgc3lzdGVtIG9mIHRoaXMgbWVhc3VyZS5cbiAgICogLSAoR2V0dGVyKVxuICAgKiAtIChTZXR0ZXIpIFRoZSBtZWFzdXJlIGVsIHdpbGwgYmUgY3JlYXRlZCwgYW5kIHRoZSBoZWlnaHQgb2YgdGhlIG1lYXN1cmUgd2lsbCBiZSBzZXQuXG4gICAqIEB0eXBlIHtTeXN0ZW1MYXlvdXR9XG4gICAqL1xuICBzeXN0ZW06IHtcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9zO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiAoc3lzdGVtKSB7XG4gICAgICB0aGlzLl9zID0gc3lzdGVtO1xuICAgICAgdGhpcy5fZWwgPSBzeXN0ZW0uZWwuZygpLmFkZENsYXNzKCdtdXMtbWVhc3VyZScpO1xuICAgIH1cbiAgfSxcblxuICBwYWRkaW5nOiB7XG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgbG8gPSB0aGlzLmxheW91dC5vcHRpb25zO1xuICAgICAgcmV0dXJuIGxvLm1lYXN1cmVQYWRkaW5nUmlnaHQgKyBsby5tZWFzdXJlUGFkZGluZ0xlZnQ7XG4gICAgfVxuICB9LFxuXG4gIG91dGVyV2lkdGg6IHtcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLm91dGVyV2lkdGhMZWZ0ICsgdGhpcy5vdXRlcldpZHRoUmlnaHQ7XG4gICAgfVxuICB9LFxuXG4gIG91dGVyV2lkdGhMZWZ0OiB7XG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5sYXlvdXQub3B0aW9ucy5tZWFzdXJlUGFkZGluZ0xlZnQgK1xuICAgICAgICAgICAgICB0aGlzLmJhckxlZnRJblN5c3RlbS53aWR0aCAvIDI7XG4gICAgfVxuICB9LFxuXG4gIG91dGVyV2lkdGhSaWdodDoge1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMubGF5b3V0Lm9wdGlvbnMubWVhc3VyZVBhZGRpbmdSaWdodCArXG4gICAgICAgICAgICAgIHRoaXMuYmFyUmlnaHRJblN5c3RlbS53aWR0aCAvIDI7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBXaWR0aCBvZiB0aGUgbWVhc3VyZS5cbiAgICogLSAoR2V0dGVyKVxuICAgKiAtIChTZXR0ZXIpIFNldCB3aWR0aCBvZiB0aGUgbWVhc3VyZSBhbmQgYWxzbyBzZXQgdGhlIHdpZHRocyBvZiB0aGUgY29udGFpbmluZyBjZWxscy5cbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIHdpZHRoOiB7XG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fdyB8fCAodGhpcy5fdyA9IHRoaXMubWluV2lkdGgpO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiAodykge1xuICAgICAgdGhpcy5fdyA9IHc7XG4gICAgICB2YXIgb3V0ZXJXaWR0aCA9IHRoaXMub3V0ZXJXaWR0aDtcblxuICAgICAgdGhpcy5wYXJ0cy5mb3JFYWNoKGZ1bmN0aW9uIChjZWxsKSB7XG4gICAgICAgIGNlbGwud2lkdGggPSB3IC0gb3V0ZXJXaWR0aDtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSxcblxuICBoZWlnaHQ6IHtcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLnN5c3RlbS5oZWlnaHQ7XG4gICAgfVxuICB9LFxuXG4gIG1pbkhlaWdodDoge1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyXG4gICAgICAgIG1pbkhlaWdodCA9IDAsXG4gICAgICAgIHBhcnRTZXAgPSB0aGlzLmxheW91dC5vcHRpb25zLnBhcnRTZXA7XG5cbiAgICAgIHRoaXMucGFydHMuZm9yRWFjaChmdW5jdGlvbiAoY2VsbCkge1xuICAgICAgICBtaW5IZWlnaHQgKz0gY2VsbC5oZWlnaHQgKyBwYXJ0U2VwO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gbWluSGVpZ2h0ID8gbWluSGVpZ2h0IC0gcGFydFNlcCA6IDA7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBUaGUgeCBwb3NpdGlvbiBvZiB0aGUgbWVhc3VyZSBpbiB0aGUgc3lzdGVtLlxuICAgKiAtIChHZXR0ZXIpXG4gICAqIC0gKFNldHRlcikgU2V0IHggY2F1c2UgdGhlIG1lYXN1cmUgZWxlbWVudCB0byB0cmFuc2xhdGUuXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICB4OiB7XG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5feDtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gKHgpIHtcbiAgICAgIHRoaXMuX3ggPSB4O1xuICAgICAgdGhpcy5lbC50cmFuc2Zvcm0oU25hcC5tYXRyaXgoKS50cmFuc2xhdGUoeCwgMCkpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogSWYgdGhlIG1lYXN1cmUgaW4gdGhlIGJlZ2lubmluZyBvZiB0aGUgc3lzdGVtLlxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICogQHJlYWRvbmx5XG4gICAqL1xuICBpblN5c3RlbUJlZ2luOiB7XG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fc0luZGV4ID09PSAwO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogSWYgdGhlIG1lYXN1cmUgaW4gdGhlIGVuZCBvZiB0aGUgc3lzdGVtLlxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICogQHJlYWRvbmx5XG4gICAqL1xuICBpblN5c3RlbUVuZDoge1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3NJbmRleCA9PT0gdGhpcy5zeXN0ZW0ubWVhc3VyZXMubGVuZ3RoIC0gMTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIExlZnQgYmFyIG9mIHRoZSBtZWFzdXJlIGluIHN5c3RlbS5cbiAgICogQHR5cGUge211c2plLkJhcn1cbiAgICogQHJlYWRvbmx5XG4gICAqL1xuICBiYXJMZWZ0SW5TeXN0ZW06IHtcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLnBhcnRzWzBdLmJhckxlZnRJblN5c3RlbTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJpZ2h0IGJhciBvZiB0aGUgbWVhc3VyZSBpbiBzeXN0ZW0uXG4gICAqIEB0eXBlIHtCYXJ9XG4gICAqIEByZWFkb25seVxuICAgKi9cbiAgYmFyUmlnaHRJblN5c3RlbToge1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMucGFydHNbMF0uYmFyUmlnaHRJblN5c3RlbTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEZsb3cgdGhlIG1lYXN1cmUuXG4gICAqL1xuICBmbG93OiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG1lYXN1cmUgPSB0aGlzO1xuICAgIG1lYXN1cmUucGFydHMuZm9yRWFjaChmdW5jdGlvbiAoY2VsbCkge1xuXG4gICAgICAvKipcbiAgICAgICAqIENlbGwgU1ZHIGdyb3VwIGVsZW1lbnQuXG4gICAgICAgKiBAbWVtYmVyb2YgQ2VsbExheW91dCNcbiAgICAgICAqIEBhbGlhcyBlbFxuICAgICAgICogQHR5cGUge1NuYXAuRWxlbWVudH1cbiAgICAgICAqIEByZWFkb25seVxuICAgICAgICovXG4gICAgICBjZWxsLmVsID0gbWVhc3VyZS5lbC5nKCkuYWRkQ2xhc3MoJ211cy1jZWxsJyk7XG5cbiAgICAgIGNlbGwueCA9IG1lYXN1cmUub3V0ZXJXaWR0aExlZnQ7XG5cbiAgICAgIC8vIGNlbGwuZHJhd0JveCgpO1xuICAgIH0pO1xuICB9LFxuXG4gIC8qKlxuICAgKiBEcmF3IGJveCBvZiB0aGUgY2VsbC5cbiAgICogQHJldHVybiB7U25hcC5FbGVtZW50fSBUaGUgYm94IFNWRyByZWN0IGVsZW1lbnQuXG4gICAqL1xuICBkcmF3Qm94OiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5fYm94RWwgPSB0aGlzLmVsLnJlY3QoMCwgMCwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoeyBzdHJva2U6ICdncmVlbicsIGZpbGw6ICdub25lJyB9KTtcbiAgfSxcblxuICAvKipcbiAgICogQ2xlYXIgdGhlIGJveCBTVkcgZWxlbWVudC5cbiAgICovXG4gIGNsZWFyQm94OiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5fYm94RWwucmVtb3ZlKCk7XG4gICAgdGhpcy5fYm94RWwgPSB1bmRlZmluZWQ7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gVGltZXdpc2VNZWFzdXJlTGF5b3V0TWl4aW47XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc3JjL3JlbmRlcmVyL0xheW91dC9UaW1ld2lzZU1lYXN1cmVMYXlvdXRNaXhpbi5qc1xuICoqIG1vZHVsZSBpZCA9IDM5XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbnZhciBTbmFwID0gcmVxdWlyZSgnU25hcCcpO1xudmFyIEJhciA9IHJlcXVpcmUoJy4uLy4uL21vZGVsL0JhcicpO1xuXG4vKipcbiAqIEBtaXhpblxuICovXG52YXIgQ2VsbExheW91dE1peGluID0ge1xuXG4gIC8qKlxuICAgKiBXaWR0aFxuICAgKiAtIChHZXR0ZXIpIEdldCB0aGUgY2VsbCB3aWR0aC5cbiAgICogLSAoU2V0dGVyKSBTZXQgdGhlIGNlbGwgd2lkdGgsIGFuZCB0aGlzIHdpbGwgY2F1c2UgdGhlIGNlbGwgdG8gcmVmbG93LlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgd2lkdGg6IHtcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl93O1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiAodykge1xuICAgICAgdGhpcy5fdyA9IHc7XG4gICAgICByZWZsb3codGhpcyk7XG4gICAgfVxuICB9LFxuXG4gIGhlaWdodDoge1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMubGF5b3V0Lm9wdGlvbnMucGFydEhlaWdodDtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIFRoZSB4IHBvc2l0aW9uIG9mIHRoZSBjZWxsIGluIHBhcmVudCB0aW1ld2lzZSBtZWFzdXJlLlxuICAgKiAtIFNldCB0aGUgeCB2YWx1ZSB3aWxsIGNhdXNlIHRoZSBjZWxsIGVsZW1lbnQgdHJhbnNsYXRlLlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgeDoge1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3g7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uICh4KSB7XG4gICAgICB0aGlzLl94ID0geDtcbiAgICAgIHRoaXMuZWwudHJhbnNmb3JtKFNuYXAubWF0cml4KCkudHJhbnNsYXRlKHgsIHRoaXMueTIpKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIFRoZSB5MiBwb3NpdGlvbiBvZiB0aGUgY2VsbCBpbiBwYXJlbnQgdGltZXdpc2UgbWVhc3VyZS5cbiAgICogLSBTZXQgdGhlIHkyIHZhbHVlIHdpbGwgY2F1c2UgdGhlIGNlbGwgZWxlbWVudCB0cmFuc2xhdGUuXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICB5Mjoge1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyXG4gICAgICAgIGxvID0gdGhpcy5sYXlvdXQub3B0aW9ucyxcbiAgICAgICAgcCA9IHRoaXMuX3BJbmRleDtcblxuICAgICAgcmV0dXJuIHAgPyAocCArIDEpICogbG8ucGFydEhlaWdodCArIHAgKiBsby5wYXJ0U2VwIDogbG8ucGFydEhlaWdodDtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIFRoZSBsZWZ0IGJhciBvZiB0aGlzIGNlbGwuXG4gICAqIC0gYmFyTGVmdCBhdCBmaXJzdCBtZWFzdXJlIG9mIGEgc3lzdGVtOlxuICAgKiBgYGBcbiAgICogfF0gIC0+IHxcbiAgICogOnwgIC0+IHxcbiAgICogOnw6IC0+IHw6XG4gICAqIGBgYFxuICAgKiBAdHlwZSB7bXVzamUuQmFyfVxuICAgKiBAcmVhZG9ubHlcbiAgICovXG4gIGJhckxlZnRJblN5c3RlbToge1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGJhciA9IHRoaXMuYmFyTGVmdDtcbiAgICAgIGlmICghYmFyKSB7IHJldHVybiB7IHdpZHRoOiAwLCBoZWlnaHQ6IDAgfTsgfVxuXG4gICAgICAvLyBGaXJzdCBtZWFzdXJlIGluIHRoZSBzeXN0ZW0uXG4gICAgICBpZiAodGhpcy5tZWFzdXJlLmluU3lzdGVtQmVnaW4pIHtcbiAgICAgICAgaWYgKGJhci52YWx1ZSA9PT0gJ2VuZCcgfHwgYmFyLnZhbHVlID09PSAncmVwZWF0LWVuZCcpIHtcbiAgICAgICAgICBiYXIgPSBuZXcgQmFyKCdzaW5nbGUnKTtcbiAgICAgICAgfSBlbHNlIGlmIChiYXIudmFsdWUgPT09ICdyZXBlYXQtYm90aCcpIHtcbiAgICAgICAgICBiYXIgPSBuZXcgQmFyKCdyZXBlYXQtYmVnaW4nKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYmFyLmRlZiA9IHRoaXMubGF5b3V0LmRlZnMuZ2V0KGJhcik7XG4gICAgICByZXR1cm4gYmFyO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogVGhlIHJpZ2h0IGJhciBvZiB0aGlzIGNlbGwuXG4gICAqIC0gYmFyUmlnaHQgYXQgbGFzdCBtZWFzdXJlIG9mIGEgc3lzdGVtOlxuICAgKiBgYGBcbiAgICogIHw6IC0+ICB8XG4gICAqIDp8OiAtPiA6fFxuICAgKiBgYGBcbiAgICogQHR5cGUge211c2plLkJhcn1cbiAgICogQHJlYWRvbmx5XG4gICAqL1xuICBiYXJSaWdodEluU3lzdGVtOiB7XG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXJcbiAgICAgICAgYmFyID0gdGhpcy5iYXJSaWdodCxcbiAgICAgICAgc3lzdGVtID0gdGhpcy5tZWFzdXJlLnN5c3RlbTtcblxuICAgICAgaWYgKCFiYXIpIHsgcmV0dXJuIHsgd2lkdGg6IDAsIGhlaWdodDogMCB9OyB9XG5cbiAgICAgIC8vIExhc3QgbWVhc3VyZSBpbiB0aGUgc3lzdGVtLlxuICAgICAgaWYgKHN5c3RlbSAmJiB0aGlzLm1lYXN1cmUuaW5TeXN0ZW1FbmQpIHtcbiAgICAgICAgaWYgKGJhci52YWx1ZSA9PT0gJ3JlcGVhdC1iZWdpbicpIHtcbiAgICAgICAgICBiYXIgPSBuZXcgQmFyKCdzaW5nbGUnKTtcbiAgICAgICAgfSBlbHNlIGlmIChiYXIudmFsdWUgPT09ICdyZXBlYXQtYm90aCcpIHtcbiAgICAgICAgICBiYXIgPSBuZXcgQmFyKCdyZXBlYXQtZW5kJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGJhci5kZWYgPSB0aGlzLmxheW91dC5kZWZzLmdldChiYXIpO1xuICAgICAgcmV0dXJuIGJhcjtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEZsb3cgdGhlIGNlbGwuXG4gICAqL1xuICBmbG93OiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGRlZnMgPSB0aGlzLmxheW91dC5kZWZzO1xuICAgIHZhciBsbyA9IHRoaXMubGF5b3V0Lm9wdGlvbnM7XG4gICAgdmFyIHggPSAwO1xuICAgIHZhciBtaW5IZWlnaHQ7XG5cbiAgICB0aGlzLmRhdGEuZm9yRWFjaChmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgdmFyIGRlZiA9IGRhdGEuZGVmID0gZGVmcy5nZXQoZGF0YSk7XG4gICAgICBkYXRhLnggPSB4O1xuICAgICAgZGF0YS55ID0gMDtcbiAgICAgIHggKz0gZGVmLndpZHRoICsgbG8ubXVzaWNEYXRhU2VwO1xuICAgICAgbWluSGVpZ2h0ID0gTWF0aC5taW4obWluSGVpZ2h0LCBkZWYuaGVpZ2h0KTtcbiAgICB9KTtcblxuICAgIHRoaXMubWluV2lkdGggPSB4O1xuICAgIHRoaXMubWluSGVpZ2h0ID0gbWluSGVpZ2h0O1xuICB9LFxuXG4gIC8qKlxuICAgKiBEcmF3IGJveCBvZiB0aGUgY2VsbC5cbiAgICogQHJldHVybiB7RWxlbWVudH0gVGhlIGJveCBTVkcgcmVjdCBlbGVtZW50LlxuICAgKi9cbiAgZHJhd0JveDogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX2JveEVsID0gdGhpcy5lbC5yZWN0KDAsIC10aGlzLmhlaWdodCwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgLmFkZENsYXNzKCdiYm94Jyk7XG4gICAgcmV0dXJuIHRoaXMuX2JveEVsO1xuICB9LFxuXG4gIC8qKlxuICAgKiBDbGVhciB0aGUgYm94IFNWRyBlbGVtZW50LlxuICAgKi9cbiAgY2xlYXJCb3g6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl9ib3hFbC5yZW1vdmUoKTtcbiAgICB0aGlzLl9ib3hFbCA9IHVuZGVmaW5lZDtcbiAgfVxufTtcblxuLy8gUmVmbG93IHRoZSBjZWxsLlxuZnVuY3Rpb24gcmVmbG93KHRoYXQpIHtcbiAgdGhhdC5kYXRhLmZvckVhY2goZnVuY3Rpb24gKGRhdGEpIHtcbiAgICBkYXRhLnggKj0gdGhhdC53aWR0aCAvIHRoYXQubWluV2lkdGg7XG4gIH0pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IENlbGxMYXlvdXRNaXhpbjtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zcmMvcmVuZGVyZXIvTGF5b3V0L0NlbGxMYXlvdXRNaXhpbi5qc1xuICoqIG1vZHVsZSBpZCA9IDQwXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogTGF5b3V0IG1peGluIGZvciB0aGUgbXVzaWMgZGF0YVxuICogQG1peGluXG4gKi9cbnZhciBNdXNpY0RhdGFMYXlvdXRNaXhpbiA9IHtcblxuICAvKipcbiAgICogVGhlIHggcG9zaXRpb24gb2YgdGhlIG11c2ljIGRhdGEgaW4gdGhlIGNlbGwuXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICB4OiB7XG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5feDtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gKHgpIHtcbiAgICAgIHRoaXMuX3ggPSB4O1xuICAgICAgaWYgKHRoaXMuZWwpIHtcbiAgICAgICAgdGhpcy5lbC5hdHRyKCd4JywgeCk7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBUaGUgeSBwb3NpdGlvbiBvZiB0aGUgbXVzaWMgZGF0YSBpbiB0aGUgY2VsbC5cbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIHk6IHtcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl95O1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiAoeSkge1xuICAgICAgdGhpcy5feSA9IHk7XG4gICAgICBpZiAodGhpcy5lbCkgeyB0aGlzLmVsLmF0dHIoJ3knLCB5KTsgfVxuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogVGhlIHggcG9zaXRpb24gb2YgdGhlIG11c2ljIGRhdGEgaW4gdGhlIHN5c3RlbS5cbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIHN5c3RlbVg6IHtcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLnggKyB0aGlzLmNlbGwueCArIHRoaXMuY2VsbC5tZWFzdXJlLng7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBUaGUgd2lkdGggb2YgdGhlIG11c2ljIGRhdGEuXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqIEByZWFkb25seVxuICAgKi9cbiAgd2lkdGg6IHtcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLmRlZi53aWR0aDtcbiAgICB9XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gTXVzaWNEYXRhTGF5b3V0TWl4aW47XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc3JjL3JlbmRlcmVyL0xheW91dC9NdXNpY0RhdGFMYXlvdXRNaXhpbi5qc1xuICoqIG1vZHVsZSBpZCA9IDQxXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbnZhciBTbmFwID0gcmVxdWlyZSgnU25hcCcpO1xuXG4vLyBAcGFyYW0gbSB7bnVtYmVyfSBNZWFzdXJlIGluZGV4IGluIG1lYXN1cmVzLlxuLy8gQHBhcmFtIGxlbiB7bnVtYmVyfSBMZW5ndGggb2YgbWVhc3VyZXMuXG5mdW5jdGlvbiByZW5kZXJCYXIobWVhc3VyZSwgbG8pIHtcbiAgdmFyIGJhciA9IG1lYXN1cmUuYmFyUmlnaHRJblN5c3RlbTtcbiAgdmFyIGVsO1xuXG4gIGlmIChiYXIuZGVmKSB7XG4gICAgZWwgPSByZW5kZXIoYmFyLCBtZWFzdXJlLCBsbyk7XG5cbiAgICAvLyBBbGlnbiBlbmQgaW4gc3lzdGVtIGVuZC5cbiAgICBpZiAobWVhc3VyZS5pblN5c3RlbUVuZCkge1xuICAgICAgdHJhbnNsYXRlKGVsLCBtZWFzdXJlLndpZHRoIC0gYmFyLndpZHRoKTtcblxuICAgIC8vIE90aGVycyBhbGlnbiBtaWRkbGUuXG4gICAgfSBlbHNlIHtcbiAgICAgIHRyYW5zbGF0ZShlbCwgbWVhc3VyZS53aWR0aCAtIGJhci53aWR0aCAvIDIpO1xuICAgIH1cbiAgfVxuXG4gIC8vIFJlbmRlciByaWdodCBiYXIgYW5kIGFsaWduIGJlZ2luIGluIHN5c3RlbSBiZWdpbi5cbiAgaWYgKG1lYXN1cmUuaW5TeXN0ZW1CZWdpbikge1xuICAgIGJhciA9IG1lYXN1cmUuYmFyTGVmdEluU3lzdGVtO1xuICAgIGlmIChiYXIuZGVmKSB7XG4gICAgICByZW5kZXIoYmFyLCBtZWFzdXJlLCBsbyk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHJlbmRlckRvdHMoZWwsIHgsIHJhZGl1cywgbWVhc3VyZUhlaWdodCkge1xuICB2YXIgY3kgPSBtZWFzdXJlSGVpZ2h0IC8gMjtcbiAgdmFyIGR5ID0gbWVhc3VyZUhlaWdodCAqIDAuMTU7XG5cbiAgZWwuY2lyY2xlKHgsIGN5IC0gZHksIHJhZGl1cyk7XG4gIGVsLmNpcmNsZSh4LCBjeSArIGR5LCByYWRpdXMpO1xufVxuXG5mdW5jdGlvbiByZW5kZXIoYmFyLCBtZWFzdXJlLCBsbykge1xuICB2YXIgZWwgPSBtZWFzdXJlLmVsLmcoKS5hZGRDbGFzcygnbXVzLWJhcmxpbmUnKTtcblxuICBlbC51c2UoYmFyLmRlZi5lbCkudHJhbnNmb3JtKFNuYXAubWF0cml4KCkuc2NhbGUoMSwgbWVhc3VyZS5oZWlnaHQpKTtcblxuICBzd2l0Y2ggKGJhci52YWx1ZSkge1xuICBjYXNlICdyZXBlYXQtYmVnaW4nOlxuICAgIHJlbmRlckRvdHMoZWwsIGJhci53aWR0aCAtIGxvLmJhcmxpbmVEb3RSYWRpdXMsIGxvLmJhcmxpbmVEb3RSYWRpdXMsIG1lYXN1cmUuaGVpZ2h0KTtcbiAgICBicmVhaztcbiAgY2FzZSAncmVwZWF0LWVuZCc6XG4gICAgcmVuZGVyRG90cyhlbCwgbG8uYmFybGluZURvdFJhZGl1cywgbG8uYmFybGluZURvdFJhZGl1cywgbWVhc3VyZS5oZWlnaHQpO1xuICAgIGJyZWFrO1xuICBjYXNlICdyZXBlYXQtYm90aCc6XG4gICAgcmVuZGVyRG90cyhlbCwgYmFyLndpZHRoIC0gbG8uYmFybGluZURvdFJhZGl1cywgbG8uYmFybGluZURvdFJhZGl1cywgbWVhc3VyZS5oZWlnaHQpO1xuICAgIHJlbmRlckRvdHMoZWwsIGxvLmJhcmxpbmVEb3RSYWRpdXMsIGxvLmJhcmxpbmVEb3RSYWRpdXMsIG1lYXN1cmUuaGVpZ2h0KTtcbiAgICBicmVhaztcbiAgfVxuXG4gIHJldHVybiBlbDtcbn1cblxuZnVuY3Rpb24gdHJhbnNsYXRlKGVsLCB4KSB7XG4gIGVsLnRyYW5zZm9ybShTbmFwLm1hdHJpeCgpLnRyYW5zbGF0ZSh4LCAwKSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gcmVuZGVyQmFyO1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NyYy9yZW5kZXJlci9SZW5kZXJlci9yZW5kZXJCYXIuanNcbiAqKiBtb2R1bGUgaWQgPSA0MlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgU25hcCA9IHJlcXVpcmUoJ1NuYXAnKTtcblxuZnVuY3Rpb24gcmVuZGVyRHVyYXRpb24obm90ZSwgbG8pIHtcbiAgdmFyIGR1cmF0aW9uRGVmID0gbm90ZS5kZWYuZHVyYXRpb25EZWY7XG4gIHZhciBwaXRjaERlZiA9IG5vdGUuZGVmLnBpdGNoRGVmO1xuICB2YXIgdW5kZXJiYXIgPSBub3RlLmR1cmF0aW9uLnVuZGVyYmFyO1xuICB2YXIgeSA9IDA7XG5cbiAgLy8gV2hvbGUgYW5kIGhhbGYgbm90ZXNcbiAgaWYgKG5vdGUuZHVyYXRpb24udHlwZSA8IDQpIHtcbiAgICBub3RlLmVsLnVzZShkdXJhdGlvbkRlZi5lbCkuYXR0cih7XG4gICAgICB4OiBwaXRjaERlZi53aWR0aCxcbiAgICAgIHk6IHBpdGNoRGVmLnN0ZXBDeVxuICAgIH0pO1xuXG4gIC8vIFF1YXJ0ZXIgb3Igc2hvcnRlciBub3Rlc1xuICB9IGVsc2Uge1xuXG4gICAgLy8gQWRkIGRvdHNcbiAgICBpZiAobm90ZS5kdXJhdGlvbi5kb3QpIHtcbiAgICAgIG5vdGUuZWwuZygpLnRyYW5zZm9ybShTbmFwLm1hdHJpeCgpLnRyYW5zbGF0ZShwaXRjaERlZi53aWR0aCwgMCkpXG4gICAgICAgIC51c2UoZHVyYXRpb25EZWYuZWwpLnRyYW5zZm9ybShwaXRjaERlZi5tYXRyaXgpO1xuICAgIH1cblxuICAgIC8vIEFkZCB1bmRlcmJhcnMgZm9yIGVpZ3RoIG9yIHNob3J0ZXIgbm90ZXNcbiAgICBpZiAodW5kZXJiYXIpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdW5kZXJiYXI7IGkrKykge1xuXG4gICAgICAgIC8vIE9ubHkgcmVuZGVyIGJlYW0gZm9yIHRoZSBiZWdpbiBvbmUuXG4gICAgICAgIGlmIChub3RlLmJlYW1zW2ldKSB7XG4gICAgICAgICAgaWYgKG5vdGUuYmVhbXNbaV0udmFsdWUgPT09ICdiZWdpbicpIHtcbiAgICAgICAgICAgIHJlbmRlclVuZGVyYmFyKG5vdGUsIG5vdGUuYmVhbXNbaV0uZW5kRHVyYWJsZSwgeSwgbG8pO1xuICAgICAgICAgIH1cblxuICAgICAgICAvLyBVbmJlYW1lZCB1bmRlcmJhclxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlbmRlclVuZGVyYmFyKG5vdGUsIG5vdGUsIHksIGxvKTtcbiAgICAgICAgfVxuICAgICAgICB5IC09IGxvLnVuZGVyYmFyU2VwO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiByZW5kZXJVbmRlcmJhcihub3RlMSwgbm90ZTIsIHksIGxvKSB7XG4gIG5vdGUxLmVsLmxpbmUoMCwgeSwgbm90ZTIueCAtIG5vdGUxLnggKyBub3RlMi53aWR0aCwgeSlcbiAgICAgICAgIC5hdHRyKCdzdHJva2Utd2lkdGgnLCBsby50eXBlU3Ryb2tlV2lkdGgpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHJlbmRlckR1cmF0aW9uO1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NyYy9yZW5kZXJlci9SZW5kZXJlci9yZW5kZXJEdXJhdGlvbi5qc1xuICoqIG1vZHVsZSBpZCA9IDQzXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbnZhciBTbmFwID0gcmVxdWlyZSgnU25hcCcpO1xuXG5mdW5jdGlvbiByZW5kZXJDdXJ2ZSh0eXBlLCBub3RlKSB7XG4gIHZhciBuZXh0LCBwcmV2LCBwcmV2SGFzRXJyb3IsIG5leHRIYXNFcnJvcjtcblxuICBpZiAobm90ZVt0eXBlXS5lbmQpIHtcbiAgICBwcmV2ID0gbm90ZVt0eXBlXS5wcmV2UGFyZW50O1xuICAgIHByZXZIYXNFcnJvciA9IG5vdGVbdHlwZV0ucHJldkhhc0Vycm9yO1xuXG4gICAgaWYgKCFwcmV2IHx8IHByZXYuc3lzdGVtICE9PSBub3RlLnN5c3RlbSkge1xuICAgICAgcmVuZGVyRW5kQ3VydmUobm90ZSwgcHJldkhhc0Vycm9yKTtcbiAgICB9IGVsc2UgaWYgKHByZXZIYXNFcnJvcikge1xuICAgICAgcmVuZGVyQ29tcGxldGVDdXJ2ZShub3RlLCBwcmV2LCBwcmV2SGFzRXJyb3IpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChub3RlW3R5cGVdLmJlZ2luKSB7XG4gICAgbmV4dCA9IG5vdGVbdHlwZV0ubmV4dFBhcmVudDtcbiAgICBuZXh0SGFzRXJyb3IgPSBub3RlW3R5cGVdLm5leHRIYXNFcnJvcjtcblxuICAgIGlmICghbmV4dCB8fCBuZXh0LnN5c3RlbSAhPT0gbm90ZS5zeXN0ZW0pIHtcbiAgICAgIHJlbmRlckJlZ2luQ3VydmUobm90ZSwgbmV4dEhhc0Vycm9yKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVuZGVyQ29tcGxldGVDdXJ2ZShub3RlLCBuZXh0LCBuZXh0SGFzRXJyb3IpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRDdXJ2ZVBhdGgoeDEsIHkxLCB4MiwgeTIpIHtcbiAgdmFyIGR4ID0geDIgLSB4MTtcbiAgdmFyIGR5ID0geTIgLSB5MTtcbiAgdmFyIGMxeCA9IDA7IC8vLTAuMSAqIGR4O1xuICB2YXIgYzF5ID0gMDsgLy8tMC4xICogZHk7XG4gIHZhciBjMnggPSBkeDsgLy8xLjEgKiBkeDtcbiAgdmFyIGMyeSA9IGR5OyAvLzEuMSAqIGR5O1xuXG4gIHJldHVybiBTbmFwLmZvcm1hdCgnTXt4MX0se3kxfWN7YzF4fSx7YzF5fSB7YzJ4fSx7YzJ5fSB7ZHh9LHtkeX1je2MzeH0se2MzeX0ge2M0eH0se2M0eX0ge25lZ0R4fSx7bmVnRHl9Jywge1xuICAgIHgxOiB4MSxcbiAgICB5MTogeTEsXG4gICAgYzF4OiBjMXgsXG4gICAgYzF5OiBjMXkgLSA4LFxuICAgIGMyeDogYzJ4LFxuICAgIGMyeTogYzJ5IC0gOCxcbiAgICBkeDogZHgsXG4gICAgZHk6IGR5LFxuICAgIGMzeDogLWMxeCxcbiAgICBjM3k6IC1jMXkgLSAxMCxcbiAgICBjNHg6IC1jMngsXG4gICAgYzR5OiAtYzJ5IC0gMTAsXG4gICAgbmVnRHg6IC1keCxcbiAgICBuZWdEeTogLWR5XG4gIH0pO1xufVxuXG5mdW5jdGlvbiByZW5kZXJFbmRDdXJ2ZShub3RlLCBlcnJvcikge1xuICB2YXIgeDEgPSBub3RlLmRlZi5waXRjaERlZi5zdGVwQ3g7XG4gIHZhciB5MSA9IG5vdGUuZGVmLnBpdGNoRGVmLnN0ZXBUb3A7XG4gIHZhciB4MiA9IC0gbm90ZS5zeXN0ZW1YIC0gMztcbiAgdmFyIGVsID0gbm90ZS5lbC5wYXRoKGdldEN1cnZlUGF0aCh4MSwgeTEsIHgyLCB5MSAtIDMpKTtcblxuICBpZiAoZXJyb3IpIHsgZWwuYWRkQ2xhc3MoJ211cy1lcnJvcicpOyB9XG4gIHJldHVybiBlbDtcbn1cblxuZnVuY3Rpb24gcmVuZGVyQmVnaW5DdXJ2ZShub3RlLCBlcnJvcikge1xuICB2YXIgeDEgPSBub3RlLmRlZi5waXRjaERlZi5zdGVwQ3g7XG4gIHZhciB5MSA9IG5vdGUuZGVmLnBpdGNoRGVmLnN0ZXBUb3A7XG4gIHZhciB4MiA9IG5vdGUuc3lzdGVtLndpZHRoIC0gbm90ZS5zeXN0ZW1YICsgMztcbiAgdmFyIGVsID0gbm90ZS5lbC5wYXRoKGdldEN1cnZlUGF0aCh4MSwgeTEsIHgyLCB5MSAtIDMpKTtcblxuICBpZiAoZXJyb3IpIHsgZWwuYWRkQ2xhc3MoJ211cy1lcnJvcicpOyB9XG4gIHJldHVybiBlbDtcbn1cblxuZnVuY3Rpb24gcmVuZGVyQ29tcGxldGVDdXJ2ZShub3RlMSwgbm90ZTIsIGVycm9yKSB7XG4gIHZhciB4MSA9IG5vdGUxLmRlZi5waXRjaERlZi5zdGVwQ3g7XG4gIHZhciB5MSA9IG5vdGUxLmRlZi5waXRjaERlZi5zdGVwVG9wO1xuICB2YXIgeDIgPSBub3RlMi5kZWYucGl0Y2hEZWYuc3RlcEN4O1xuICB2YXIgeTIgPSBub3RlMi5kZWYucGl0Y2hEZWYuc3RlcFRvcDtcbiAgdmFyIG5vdGVEeCA9IG5vdGUyLnN5c3RlbVggLSBub3RlMS5zeXN0ZW1YO1xuICB2YXIgZWwgPSBub3RlMS5lbC5wYXRoKGdldEN1cnZlUGF0aCh4MSwgeTEsIG5vdGVEeCArIHgyLCB5MikpO1xuXG4gIGlmIChlcnJvcikgeyBlbC5hZGRDbGFzcygnbXVzLWVycm9yJyk7IH1cbiAgcmV0dXJuIGVsO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHJlbmRlckN1cnZlO1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NyYy9yZW5kZXJlci9SZW5kZXJlci9yZW5kZXJDdXJ2ZS5qc1xuICoqIG1vZHVsZSBpZCA9IDQ0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbnZhciBNSURJID0gcmVxdWlyZSgnTUlESScpO1xuXG52YXIgdGltZW91dHMgPSBbXTtcblxuLyoqXG4gKiBQbGF5ZXIgbWl4aW4uXG4gKiBAbWl4aW5cbiAqL1xudmFyIFBsYXllck1peGluID0ge1xuXG4gIC8qKlxuICAgKiBTdGFydCBwbGF5aW5nIHRoZSBzb25nLlxuICAgKi9cbiAgcGxheTogZnVuY3Rpb24oKSB7XG4gICAgdmFyIG1lYXN1cmVzID0gdGhpcy5wYXJ0c1swXS5tZWFzdXJlcztcbiAgICB2YXIgdGltZSA9IDA7IC8vYXVkaW9DdHguY3VycmVudFRpbWVcblxuICAgIG1lYXN1cmVzLmZvckVhY2goZnVuY3Rpb24gKGNlbGwpIHtcbiAgICAgIGNlbGwuZGF0YS5mb3JFYWNoKGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIHN3aXRjaCAoZGF0YS4kdHlwZSkge1xuICAgICAgICBjYXNlICdub3RlJzpcbiAgICAgICAgICAvLyBwbGF5Tm90ZSh0aW1lLCBkdXIsIGZyZXEpO1xuICAgICAgICAgIHRpbWVvdXRzLnB1c2gobWlkaVBsYXlOb3RlKGRhdGEsIHRpbWUpKTtcbiAgICAgICAgICB0aW1lICs9IGRhdGEuZHVyYXRpb24uc2Vjb25kO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdyZXN0JzpcbiAgICAgICAgICB0aW1lICs9IGRhdGEuZHVyYXRpb24uc2Vjb25kO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfSxcblxuICAvKipcbiAgICogU3RvcCBwbGF5aW5nIHRoZSBzb25nLlxuICAgKi9cbiAgc3RvcDogZnVuY3Rpb24gKCkge1xuICAgIHRpbWVvdXRzLmZvckVhY2goZnVuY3Rpb24gKHRpbWVvdXQpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICB9KTtcbiAgICB0aW1lb3V0cyA9IFtdO1xuICB9XG59O1xuXG4vLyBpZiAod2luZG93LkF1ZGlvQ29udGV4dCkge1xuLy8gICB2YXIgYXVkaW9DdHggPSBuZXcgd2luZG93LkF1ZGlvQ29udGV4dCgpO1xuLy8gICB2YXIgZ2Fpbk5vZGUgPSBhdWRpb0N0eC5jcmVhdGVHYWluKCk7XG4vLyAgIGdhaW5Ob2RlLmNvbm5lY3QoYXVkaW9DdHguZGVzdGluYXRpb24pO1xuLy8gICBnYWluTm9kZS5nYWluLnZhbHVlID0gMC41OyAgLy8gc2V0IHRoZSB2b2x1bWVcbi8vIH1cblxuLy8gLy8gdmFyIG9zY2lsbGF0b3IgPSBhdWRpb0N0eC5jcmVhdGVPc2NpbGxhdG9yKCk7XG4vLyAvLyBvc2NpbGxhdG9yLmNvbm5lY3QoZ2Fpbk5vZGUpO1xuLy8gLy8gb3NjaWxsYXRvci50eXBlID0gJ3NxdWFyZSc7IC8vIHNpbmUgfCBzcXVhcmUgfCBzYXd0b290aCB8IHRyaWFuZ2xlIHwgY3VzdG9tXG5cbi8vIGZ1bmN0aW9uIHBsYXlOb3RlKHRpbWUsIGR1ciwgZnJlcSkge1xuLy8gICBpZiAoIWF1ZGlvQ3R4KSB7IHJldHVybjsgfVxuXG4vLyAgIHZhciBvc2NpbGxhdG9yID0gYXVkaW9DdHguY3JlYXRlT3NjaWxsYXRvcigpO1xuLy8gICBvc2NpbGxhdG9yLnR5cGUgPSAnc2luZSc7XG4vLyAgIG9zY2lsbGF0b3IuY29ubmVjdChhdWRpb0N0eC5kZXN0aW5hdGlvbik7XG4vLyAgIG9zY2lsbGF0b3IuZnJlcXVlbmN5LnZhbHVlID0gZnJlcTtcbi8vICAgb3NjaWxsYXRvci5zdGFydCh0aW1lKTtcbi8vICAgb3NjaWxsYXRvci5zdG9wKHRpbWUgKyBkdXIgLSAwLjA1KTtcbi8vIH1cblxuZnVuY3Rpb24gbWlkaVBsYXlOb3RlKG5vdGUsIHRpbWUpIHtcbiAgdmFyIG1pZGlOdW1iZXIgPSBub3RlLnBpdGNoLm1pZGlOdW1iZXI7XG4gIHZhciBkdXIgPSBub3RlLmR1cmF0aW9uLnNlY29uZDtcblxuICBmdW5jdGlvbiBwbGF5KCkge1xuICAgIGlmICghbm90ZS50aWUucHJldlBhcmVudCB8fCBub3RlLnRpZS5wcmV2SGFzRXJyb3IpIHtcbiAgICAgIE1JREkubm90ZU9uKDAsIG1pZGlOdW1iZXIsIDEwMCwgMCk7XG4gICAgfVxuICAgIGlmICghbm90ZS50aWUubmV4dFBhcmVudCB8fCBub3RlLnRpZS5uZXh0SGFzRXJyb3IpIHtcbiAgICAgIE1JREkubm90ZU9mZigwLCBtaWRpTnVtYmVyLCBkdXIpO1xuICAgIH1cblxuICAgIG5vdGUuZWwuYWRkQ2xhc3MoJ211cy1wbGF5aW5nJyk7XG5cbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIG5vdGUuZWwucmVtb3ZlQ2xhc3MoJ211cy1wbGF5aW5nJyk7XG4gICAgfSwgZHVyICogODAwICsgMTAwKTtcblxuICAgIGNvbnNvbGUubG9nKCdQbGF5OiAnICsgbm90ZSwgdGltZSwgZHVyLCBtaWRpTnVtYmVyKTtcbiAgfVxuXG4gIHJldHVybiBzZXRUaW1lb3V0KHBsYXksIHRpbWUgKiA4MDApO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFBsYXllck1peGluO1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NyYy9wbGF5ZXIvUGxheWVyTWl4aW4uanNcbiAqKiBtb2R1bGUgaWQgPSA0NVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFXzQ2X187XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiBleHRlcm5hbCBcIk1JRElcIlxuICoqIG1vZHVsZSBpZCA9IDQ2XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iXSwic291cmNlUm9vdCI6IiJ9